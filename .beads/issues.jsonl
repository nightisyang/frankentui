{"id":"bd-10i","title":"FrankenTUI: Complete Implementation Epic","description":"# FrankenTUI (ftui) - Master Epic\n\n## Vision\nFrankenTUI is a deliberately minimal, high-performance terminal UI kernel that fuses the best surviving abstractions from three Rust codebases (rich_rust, charmed_rust, opentui_rust) into one coherent system.\n\n## Core Promise\nftui is designed so you can build a Claude Code / Codex-class agent harness UI without flicker, without cursor corruption, and without sacrificing native scrollback.\n\n## Three-Library Synthesis (conceptual)\n- opentui_rust: Cell grid, diff algorithm, alpha blending, scissor/opacity stacks, grapheme pool (cache-optimal 16-byte cells)\n- rich_rust: Segment abstraction, markup parser, measurement protocol (Cow<str> for zero-copy)\n- charmed_rust: LipGloss styling, CSS-like properties, theme system, Elm architecture (bitflags property tracking)\n\n## Non-Negotiables (Engineering Contract)\n1. One writer owns the terminal - serialized output\n2. Untrusted bytes never executed - sanitize by default\n3. Diffed + buffered UI only - no ad-hoc println\n4. Inline-first is real - preserve scrollback\n5. Safe by default, unsafe isolated (repo policy: unsafe forbidden)\n6. Deterministic by design\n7. Correctness continuously verified\n\n## Performance Budgets (v1)\n- Present (80x24, 5% changed): p50 < 1.0ms\n- Cell comparison: < 1ns\n- 16 bytes per cell (4 per cache line)\n\n## Success Criteria (v1 = Done)\n(Directly derived from plan Section 0.11.)\n\n- [ ] Inline mode default is stable (streaming logs + UI does not corrupt scrollback/cursor).\n- [ ] PTY tests confirm cleanup on normal exit and panic.\n- [ ] Presenter/diff correctness validated by terminal-model tests.\n- [ ] Unicode width correctness proven by corpus tests (ZWJ/emoji/combining).\n- [ ] Style system is deterministic and documented (explicit masks + inheritance).\n- [ ] Runtime supports update/view loop + ticks + batch/sequence cmds + deterministic simulator.\n- [ ] Harness-essential widgets exist and are tested (viewport/log viewer, status/panel, prompt/text input, progress/spinner).\n- [ ] Docs exist: agent harness tutorial, inline vs alt-screen trade-offs, one-writer rule guidance, windows limitations, compatibility matrix.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-31T22:04:22.713361602Z","created_by":"ubuntu","updated_at":"2026-01-31T23:24:44.775656345Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-10i.1","title":"Phase -1: Decision Spikes","description":"# Phase -1: Decision Spikes\n\n## Purpose\nBefore building a big structure, run small spikes that de-risk the hardest unknowns. These are tiny experiments for fast learning.\n\n## Why This Phase Exists\nThe plan is ambitious and certain decisions could cause multi-week churn if not resolved early. Decision spikes force us to confront reality before committing to architecture.\n\n## Exit Criteria\nOne ADR (Architecture Decision Record) per spike capturing:\n- Context: What problem are we solving?\n- Decision: What did we choose?\n- Alternatives considered\n- Consequences: What are the tradeoffs?\n- Test plan: How we'll know it worked\n\n## Key Spikes Required\n1. Inline mode spike: Implement both scroll-region and overlay strategies in tiny prototype\n2. Presenter validation spike: Build terminal-model harness to validate output\n3. Backend spike: Validate raw mode + resize + input reading across platforms\n\n## Relationship to Other Phases\nThis phase BLOCKS Phase 0 (Contracts + Workspace Skeleton). We must not proceed with architecture until we've validated our assumptions through concrete experiments.\n\n## Success Criteria\n- [ ] Spikes are completed with runnable prototypes (even if throwaway) and notes.\n- [ ] ADR-001/002/003 are unblocked and written based on spike outcomes.\n- [ ] We have a clear go/no-go decision for:\n  - inline mode strategy baseline\n  - presenter emission baseline\n  - backend selection","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:04:34.363862676Z","created_by":"ubuntu","updated_at":"2026-01-31T23:24:55.666699497Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:04:34.363862676Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.1.1","title":"Spike: Inline Mode Strategies","description":"# Spike: Inline Mode Strategies\n\n## Objective\nValidate a **correctness-first** inline mode strategy for FrankenTUI: stable UI chrome + streaming logs without flicker, cursor drift, or scrollback corruption.\n\nThis spike is explicitly about **choosing and proving** the baseline policy before we harden API and implementation.\n\n## Background: Why Inline Mode Is Hard\nInline mode + streaming logs is where most TUIs fail in practice:\n- Logs write while UI is mid-draw (multiple writers, interleaving)\n- Cursor position gets lost or restored incorrectly\n- Full-screen clears destroy scrollback\n- tmux/screen and terminal emulators differ in behavior for cursor save/restore, margins, and sync output\n\nThis project’s core promise depends on nailing the policy and cleanup invariants early.\n\n## Strategies Under Test\n\n### Strategy A: Scroll-Region Anchoring (DECSTBM / scroll margins)\nUse CSI `t;b r` to set top/bottom margins:\n- Constrains scrolling to a region (e.g., log region)\n- UI region stays pinned while logs scroll within the region\n\nPros:\n- Can reduce redraw work and cursor thrash\n- More \"native\" scrolling behavior when it works\n\nCons:\n- Muxes (tmux/screen) and some terminals may handle margins inconsistently\n- Must be carefully reset on exit, panic, and when switching modes\n\n### Strategy B: Overlay Redraw (universal fallback)\nBefore writing logs:\n1. Save cursor position\n2. Temporarily move cursor / clear UI region\n3. Write logs (so they land in native scrollback)\n4. Redraw UI region\n5. Restore cursor\n\nPros:\n- Works in the widest set of environments (baseline correctness)\n\nCons:\n- More redraw work\n- Requires an explicit “UI region” policy and predictable redraw sequence\n\n### Strategy C: Hybrid (likely default)\n- **Overlay redraw** is always available as the correctness baseline\n- Scroll-region anchoring is an internal optimization **only** where proven safe\n- Public API exposes policy (“inline mode”) not mechanism (“DECSTBM”) to avoid leaking terminal quirks into user code\n\n## Environments / Compatibility Matrix To Validate\nMinimum environments for this spike:\n- Plain terminal (no mux)\n- Kitty\n- WezTerm\n- Alacritty\n- Ghostty\n- tmux\n- screen (if available)\n\nAlso record:\n- Whether DEC 2026 synchronized output is supported and affects flicker\n- Whether cursor save/restore should use DEC (`ESC7`/`ESC8`) vs ANSI (`CSI s`/`CSI u`) vs emulation\n\n## Instrumentation Requirements\nThis spike must produce useful evidence, not vibes.\n\n- Structured logs (via `tracing`) for:\n  - enter/exit inline mode\n  - log-write begin/end\n  - UI redraw begin/end\n  - cursor save/restore operations\n  - any fallback taken (mux detected, feature probe disabled, etc.)\n- In PTY tests, capture and store:\n  - the raw byte stream written to the terminal\n  - parsed “terminal model” invariants (cursor position, mode flags) where possible\n\n## Deliverables\n- A tiny prototype (~200 LOC is fine) that demonstrates both A and B, and the selection logic.\n- A written decision (ADR-001) that records:\n  - decision\n  - fallback rules\n  - observed incompatibilities\n  - required cleanup invariants\n\n## Tests Required\n- PTY integration tests that assert:\n  - cursor is restored after each frame present in inline mode\n  - terminal modes are restored on normal exit and on panic\n  - no full-screen clears are used in inline mode unless explicitly configured\n- \"Sustained output\" scenario: continuous log stream + periodic UI redraw + resize events.\n\n## Acceptance Criteria\n- [ ] Both Strategy A and B can be exercised by a single prototype with an explicit switch.\n- [ ] We have a documented default policy (likely Hybrid) with explicit fallback triggers.\n- [ ] PTY test demonstrates no cursor drift and correct cleanup on both normal exit and panic.\n- [ ] ADR-001 is unblocked with concrete observations (not just theoretical pros/cons).","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:07:24.429895270Z","created_by":"ubuntu","updated_at":"2026-02-01T00:22:29.714466156Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1.1","depends_on_id":"bd-10i.1","type":"parent-child","created_at":"2026-01-31T22:07:24.429895270Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.1.2","title":"Spike: Presenter Validation with Terminal Model","description":"# Spike: Presenter Validation with Terminal Model\n\n## Objective\nBuild a minimal **terminal model** (a deliberately small emulator) to validate that a `present()` cycle produces the expected grid and cursor state.\n\nThis spike exists to turn presenter correctness from “looks right on my terminal” into something testable, repeatable, and CI-friendly.\n\n## Why This Spike Matters\nThe Presenter is the inverse-function layer of the whole system:\n- incorrect SGR sequencing leaks style across cells\n- incorrect cursor moves corrupt subsequent renders or user input location\n- incorrectly terminated OSC 8 hyperlinks cause \"sticky\" links\n- missing resets break muxes and downstream output\n\nIf Presenter correctness isn’t proven, every later feature becomes suspect.\n\n## Scope: Terminal Model (Not A Full Emulator)\nThe model only needs to understand the subset of sequences we emit.\n\nIt must track:\n- a grid of cells (char/grapheme + style)\n- cursor position\n- current SGR state\n- hyperlink state (OSC 8)\n- mode flags relevant to correctness (cursor visibility, alt-screen if applicable, sync output nesting)\n\nOut of scope:\n- full VT parsing\n- scrollback buffer modeling\n- alternate character sets\n- full mouse/keyboard decoding\n\n## Sequences To Support (v1 model)\nMinimum set (aligned to our planned Presenter behavior):\n- CUP: `CSI r ; c H`\n- relative cursor moves (CUU/CUD/CUF/CUB) if we emit them\n- SGR: `CSI ... m` (at least reset + fg/bg + basic attrs)\n- EL/ED: `CSI n K` / `CSI n J` (only the variants we emit)\n- OSC 8 hyperlinks: start/end\n- DEC 2026 synchronized output: begin/end (track nesting but can ignore visual effects)\n\n## Test Strategy\n\n### Deterministic unit tests\n- Known buffers → Presenter output → Model apply → exact grid match\n- Explicit cases for:\n  - style reset boundaries\n  - cursor position after present\n  - hyperlink open/close correctness\n\n### Property tests\n- Generate random buffers (within constraints) and validate:\n  - Presenter output is parseable by the model\n  - Model grid equals desired buffer\n  - No dangling style or hyperlink state after present\n\n### Debuggability requirements\nWhen a property test fails, we need:\n- a small minimized failing case (proptest shrink)\n- a readable diff of expected vs actual grid\n- a dump of emitted escape sequences (escaped and annotated)\n\n## Deliverables\n- `TerminalModel` test harness\n- A small “Presenter contract” suite that runs in CI and blocks regressions\n\n## Acceptance Criteria\n- [ ] TerminalModel supports the subset of sequences we emit (explicit list above).\n- [ ] Unit tests cover representative edge cases (style/link/cursor correctness).\n- [ ] Property tests run in CI and have actionable failure output (diff + byte dump).\n- [ ] The model is used as a gate for presenter changes (documented in the operational playbook).","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:07:38.682217640Z","created_by":"ubuntu","updated_at":"2026-02-01T00:22:45.232531690Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1.2","depends_on_id":"bd-10i.1","type":"parent-child","created_at":"2026-01-31T22:07:38.682217640Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.1.3","title":"Spike: Terminal Backend Validation","description":"# Spike: Terminal Backend Validation\n\n## Objective\nValidate raw mode + resize + input reading across platforms with the candidate backend.\n\nThis spike exists to produce a confident, written backend decision (ADR-003) before we commit to API surfaces and cleanup invariants.\n\n## Why This Spike Matters\nThe terminal backend is foundational and extremely hard to swap later:\n- raw mode enter/exit must be reliable\n- resize delivery must be accurate\n- input reading must be robust under high throughput (pastes, mouse)\n- panic cleanup must restore the user’s terminal\n\nIf we get this wrong, the project becomes permanently flaky.\n\n## Candidate Backend(s)\nPrimary candidate to evaluate first:\n- Crossterm\n\nExplicit alternatives (only if Crossterm is insufficient):\n- termwiz\n- termion (Unix-only)\n- minimal custom termios (last resort; highest control, highest maintenance)\n\n## Evaluation Matrix\n\n### Functionality\n- raw mode\n- alternate screen (optional)\n- cursor show/hide\n- mouse mode enable/disable (SGR)\n- bracketed paste enable/disable + correct parsing\n- focus events enable/disable (if supported)\n- resize events\n\n### Robustness\n- bounded-time input reads (avoid deadlocks)\n- handles partial / malformed sequences without panics\n- does not allocate unbounded memory on adversarial inputs\n\n### Cleanup Discipline\nFor both normal exit and panic:\n- raw mode restored\n- cursor shown\n- bracketed paste disabled\n- mouse mode disabled\n- scroll region reset if used\n- alt-screen exited if used\n\n### Platform coverage (v1 reality)\n- Linux: required\n- macOS: required\n- Windows: “best effort” acceptable, but must not corrupt terminal\n\n## Test Approach\n- Minimal wrapper that exercises:\n  - enter raw mode\n  - read events\n  - resize notifications\n  - exit/cleanup\n- PTY tests for Linux/macOS to assert cleanup invariants (where applicable)\n- Manual validation notes where automation is not possible\n\n## Deliverables\n- A written backend decision (ADR-003) with:\n  - decision\n  - rationale\n  - limitations\n  - fallback strategy (if backend lacks a feature)\n- A small compatibility note to feed into the terminal compatibility matrix\n\n## Acceptance Criteria\n- [ ] Backend choice is backed by evidence (tests + notes), not assumptions.\n- [ ] Cleanup invariants are validated (PTY where possible) for normal exit and panic.\n- [ ] ADR-003 is completed and blocks downstream implementation appropriately.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:07:51.564188110Z","created_by":"ubuntu","updated_at":"2026-02-01T00:22:58.245602229Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.1.3","depends_on_id":"bd-10i.1","type":"parent-child","created_at":"2026-01-31T22:07:51.564188110Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10","title":"ADRs: Architecture Decision Records","description":"# ADRs: Architecture Decision Records\n\n## Purpose\nLock the 'churn-magnets' - decisions that most often cause multi-week churn if not resolved early. Each ADR follows the format:\n- Context\n- Decision\n- Alternatives considered\n- Consequences\n- Test plan\n\n## Why ADRs Matter\nThese are not bureaucratic paperwork. They are the decisions that:\n- Could cause weeks of refactoring if changed later\n- Have non-obvious tradeoffs\n- Need documented rationale for future contributors\n- Serve as the 'why' behind the code\n\n## ADRs Required for v1\n\n### ADR-001: Inline Mode Strategy\nHybrid anchoring: overlay redraw baseline + scroll-region optimization\n- Most impactful decision for agent harness behavior\n\n### ADR-002: Presenter Emission Strategy\nReset+apply for v1 correctness; incremental behind feature flag\n- Affects output size and correctness guarantees\n\n### ADR-003: Terminal Backend Selection\nCrossterm as v1 default\n- Affects portability and maintenance burden\n\n### ADR-004: Windows v1 Scope\nWhat's supported vs best-effort\n- Sets user expectations and testing requirements\n\n### ADR-005: One-Writer Rule Enforcement\nType-level ownership model\n- Core correctness invariant for inline mode\n\n### ADR-006: Untrusted Output Policy\nSanitize-by-default for security\n- Prevents escape sequence injection attacks\n\n## ADR Discipline Rules\n- Every controversial design choice gets an ADR\n- ADRs are short and opinionated\n- Once written and reviewed, ADRs are locked\n- Changes require new ADR or amendment with rationale\n\n## Success Criteria\n- [ ] ADR-001..ADR-006 are each written with: Context / Decision / Alternatives / Consequences / Test Plan.\n- [ ] Each ADR includes explicit stop-ship tests (PTY/terminal-model/property tests as appropriate).\n- [ ] Any future changes to a locked decision require a new ADR (no silent drift).","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-31T22:06:50.475979143Z","created_by":"ubuntu","updated_at":"2026-01-31T23:24:29.339053736Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:50.475979143Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.1","title":"ADR-001: Inline Mode Strategy","description":"# ADR-001: Inline Mode Strategy\n\n## Status\nPROPOSED\n\n## Context\nWe need stable UI chrome + scrollback-native logs, with no flicker or cursor corruption, across terminals and multiplexers.\n\nInline mode plus streaming output is the hardest real-world requirement. Most flicker/corruption bugs come from broken assumptions about terminal ownership and write interleaving.\n\n## Options Considered\n\n### Option A: Scroll-Region Anchoring (DECSTBM)\n- Pros: UI truly pinned, logs scroll naturally, fewer UI redraws\n- Cons: Tricky interactions (cursor save/restore, origin mode), mux quirks, needs serious PTY coverage\n\n### Option B: Overlay Redraw\n- Pros: Portable baseline, correctness-first, simplest mental model\n- Cons: Needs careful 'clear only UI region', buffered output to avoid flicker\n\n### Option C: Hybrid (RECOMMENDED)\n- Pros: Best of both; baseline works everywhere, optimization where safe\n- Cons: Complexity; requires capability policy and more tests\n\n## Decision\n**Hybrid approach**:\n1. Overlay redraw is always available and is the correctness baseline\n2. Scroll-region anchoring is an internal optimization enabled only when proven safe\n3. Public API exposes policy, not mechanism\n\n## Implementation Notes (Baseline Overlay)\n1. Begin synchronized output if supported\n2. Save cursor position (prefer robust option)\n3. Move cursor to UI anchor\n4. Clear only the UI region (localized EL/ED)\n5. Present diffed UI frame\n6. Restore cursor position\n7. End synchronized output; flush\n\n## Implementation Notes (Scroll-Region Optimization)\nWhen enabled:\n- Set scroll region to log area: top..(h-ui_height)\n- Ensure UI writes land outside scroll region\n- Restore scroll region on exit and mode switches\n- Disable by default in tmux/screen\n\n## Consequences\n- More complex than pure overlay or pure scroll-region\n- Requires capability detection and policy logic\n- Requires PTY tests for both strategies\n- Better user experience when optimization is safe\n\n## Test Plan\n- PTY test: log spam + UI tick does not corrupt scrollback\n- Cursor contract test: cursor restored after every present\n- Resize test: changing ui_height and terminal height re-anchors correctly\n- Mux tests: verify tmux/screen behavior and fallback","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:08:10.132311732Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:35.588316533Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.1","depends_on_id":"bd-10i.1.1","type":"blocks","created_at":"2026-01-31T22:21:35.588286787Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.10.1","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:10.132311732Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.2","title":"ADR-002: Presenter Emission Strategy","description":"# ADR-002: Presenter Emission Strategy\n\n## Status\nPROPOSED\n\n## Context\nSGR and link state tracking can either be simple and correct or minimal-bytes and complex. The Presenter must emit ANSI sequences that transform the terminal from current state to desired state.\n\n## Options Considered\n\n### Option A: Reset+Apply Always\nEmit SGR 0 then re-apply all attributes for each style change.\n- Pros: Simplest, correctness is trivial\n- Cons: More bytes emitted\n\n### Option B: Incremental SGR Diffs\nTrack previous style, emit only changed attributes.\n- Pros: Fewer bytes, faster on slow terminals\n- Cons: Complex, risk of 'dangling attributes' bugs\n\n### Option C: Hybrid (RECOMMENDED for future)\nReset on hard cases, incremental on small diffs.\n- Pros: Best of both\n- Cons: Needs heuristics and benchmarks\n\n## Decision\n**v1 default: Reset+Apply** for correctness.\n**Add incremental/hybrid behind feature flag** until benchmarks + PTY coverage justify enabling by default.\n\n## Rationale\nCorrectness beats optimization at this stage. Reset+apply is:\n- Trivially correct\n- Easy to test and verify\n- Good enough for most workloads\n- Foundation for future optimization\n\nIncremental emission can be added later when:\n- We have comprehensive terminal-model tests\n- Benchmarks show meaningful benefit\n- PTY tests cover edge cases\n\n## Consequences\n- Higher byte output than theoretically minimal\n- Simpler implementation and maintenance\n- Clear path to optimization via feature flag\n- No 'dangling attribute' bugs possible\n\n## Test Plan\n- Terminal-model tests: style state cannot leak across runs\n- PTY tests: links (OSC 8) cannot remain open after present/exit\n- Benchmark: measure bytes/frame for representative workloads\n- Regression: track byte output in CI","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:08:24.426412320Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:35.878559287Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.2","depends_on_id":"bd-10i.1.2","type":"blocks","created_at":"2026-01-31T22:21:35.878528890Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.10.2","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:24.426412320Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.3","title":"ADR-003: Terminal Backend Selection","description":"# ADR-003: Terminal Backend Selection\n\n## Status\nPROPOSED\n\n## Context\nWe must support raw mode, key/mouse input, resize, and reliable cleanup on Unix and Windows.\n\n## Options Considered\n\n### Option A: Crossterm\n- Pros: Widely used, cross-platform, avoids bespoke termios/Windows plumbing\n- Cons: Another dependency, abstractions may not fit perfectly\n\n### Option B: termion\n- Pros: Pure Rust, simpler\n- Cons: Unix-only, no Windows support\n\n### Option C: Raw termios + Windows Console API\n- Pros: Maximum control\n- Cons: Significant implementation effort, platform-specific code\n\n### Option D: termwiz\n- Pros: Feature-rich, from wezterm project\n- Cons: Heavier dependency, may include more than we need\n\n## Decision\n**v1 default: Crossterm**\n\nKernel remains backend-agnostic at the conceptual level, but v1 does NOT over-abstract. Ship one backend 'batteries included'; treat alternatives as experimental.\n\n## Rationale\n- Crossterm is widely used and tested\n- Cross-platform without custom code\n- Fits our Event model reasonably well\n- Community support and maintenance\n- We can switch later if needed (abstraction in place)\n\n## Consequences\n- Dependency on crossterm crate\n- Must work within crossterm's event model\n- Windows support comes 'for free' (with caveats)\n- Path to alternatives via feature flags\n\n## Test Plan\n- Spike validates Crossterm functionality (bd-10i.1.3)\n- PTY tests verify raw mode + cleanup\n- Multi-platform CI (Linux, macOS, Windows)\n- Document any Crossterm limitations in Windows ADR","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:08:38.701607178Z","created_by":"ubuntu","updated_at":"2026-01-31T23:14:45.713690490Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.3","depends_on_id":"bd-10i.1","type":"blocks","created_at":"2026-01-31T23:14:45.713641407Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.10.3","depends_on_id":"bd-10i.1.3","type":"blocks","created_at":"2026-01-31T22:21:36.119868797Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.10.3","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:38.701607178Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.4","title":"ADR-004: Windows v1 Scope","description":"# ADR-004: Windows v1 Scope\n\n## Status\nPROPOSED\n\n## Context\nWindows terminal support varies significantly from Unix. We need to decide what's fully supported vs best-effort for v1.\n\n## Supported in v1\n- Raw mode enter/exit and cleanup on panic\n- Key input and resize events\n- Basic mouse (where Crossterm supports it)\n- Color where available (16/256/truecolor when exposed)\n\n## Best-Effort / May Be Missing in v1\n- DEC synchronized output (mode 2026) - not widely supported\n- OSC 8 hyperlinks - limited Windows Terminal support\n- Bracketed paste differences across terminals\n- Focus events differences\n- Kitty keyboard protocol - not supported\n\n## Decision\nAccept Windows as 'supported with documented limitations' for v1.\n\n## Rationale\n- Primary target is agent harness UIs (likely Unix/macOS)\n- Windows Terminal is improving but not at feature parity\n- Full Windows feature parity would delay v1 significantly\n- Honest documentation is better than broken promises\n\n## Consequences\n- Windows users may have reduced functionality\n- Must clearly document limitations\n- Future versions can improve Windows support\n- CI must include Windows builds (even if tests are limited)\n\n## Documentation Requirement\nA 'Windows Limitations' section must exist and be honest about:\n- Which features work fully\n- Which features are degraded\n- Which features are missing\n- Workarounds if any\n\n## Test Plan\n- Windows CI build must pass\n- Core functionality tests on Windows (raw mode, basic input)\n- Document behavior differences","status":"open","priority":1,"issue_type":"docs","created_at":"2026-01-31T22:08:51.697779300Z","created_by":"ubuntu","updated_at":"2026-01-31T22:08:51.697779300Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.4","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:08:51.697779300Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.5","title":"ADR-005: One-Writer Rule Enforcement","description":"# ADR-005: One-Writer Rule Enforcement\n\n## Status\nPROPOSED\n\n## Context\nInline mode guarantees break if other code writes to stdout/stderr concurrently. The terminal is a shared mutable resource that doesn't support concurrent access safely.\n\n## Problem\nIf multiple sources write to the terminal simultaneously:\n- Cursor position becomes undefined\n- Partial escape sequences corrupt output\n- UI and logs interleave unpredictably\n- Scrollback gets corrupted\n\n## Decision\nEnforce the one-writer rule through type-level ownership:\n- TerminalOwner / TerminalSession owns raw mode and output handle\n- TerminalWriter is the only way to write logs and present UI\n- Provide routing helpers for subprocess and in-process logs\n\n## Type-Level Enforcement\nTerminalSession takes ownership of stdout:\n- Only TerminalWriter can produce output\n- Cannot accidentally println! while ftui is active\n- Drop returns terminal to normal state\n\n## Supported Routing Patterns\n\n### Pattern A: LogSink (In-Process Logs)\nProvide a LogSink: Write that application code uses instead of println!\n- Discourage raw println! during inline mode\n- Route through TerminalWriter with sanitization\n\n### Pattern B: PTY Capture (Subprocess Output)\nSpawn tool subprocesses under PTY:\n- Read their stdout/stderr streams\n- Write as log stream through ftui\n- Preserves scrollback and UI stability\n- Feature-gated (adds dependency on PTY crate)\n\n### Pattern C: Stdio Capture (Optional)\nPipe + reader thread that forwards through ftui:\n- Captures accidental println! from libraries\n- Best-effort, may miss some output\n- Feature-gated\n\n## Consequences\n- Application code must use ftui APIs for output\n- Libraries that write directly may cause issues\n- Subprocess output requires explicit handling\n- More disciplined but more work for users\n\n## What Happens If Violated\nIf external code writes to stdout during inline mode:\n- Behavior is undefined\n- Cursor may drift\n- UI may corrupt\n- This is documented as unsupported\n\n## Test Plan\n- PTY tests with concurrent log writes via supported mux path\n- Assert stability under parallel output\n- Document undefined behavior for unsupported patterns","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:09:09.275630145Z","created_by":"ubuntu","updated_at":"2026-01-31T22:09:09.275630145Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.5","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:09:09.275630145Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.10.6","title":"ADR-006: Untrusted Output Policy (Sanitize-by-Default)","description":"# ADR-006: Untrusted Output Policy (Sanitize-by-Default)\n\n## Status\nPROPOSED\n\n## Context\nAgent harnesses display tool output, LLM streams, and logs. Malicious or buggy content can smuggle ANSI/OSC sequences that:\n- Manipulate terminal state\n- Deceive users (fake prompts, hidden commands)\n- Persist changes after the app exits\n- Exfiltrate data via terminal queries\n\nThis is a real security concern for AI agent UIs.\n\n## Decision\n**Sanitize by default**: Any text flowing through write_log() or rendered as user-provided content has control sequences stripped or escaped.\n\n**Explicit opt-in for raw passthrough**: An API like write_raw() or Text::raw() allows trusted content to include ANSI.\n\n## What Gets Sanitized\n- ESC (0x1B) and all CSI/OSC/DCS/APC sequences\n- C0 controls except: TAB (0x09), LF (0x0A), CR (0x0D)\n- Option for semi-trusted mode: allow SGR styling only\n\n## Sanitization Strategies\n1. **Strip**: Remove escape sequences entirely\n2. **Escape**: Convert to visible representation (e.g., ^[ for ESC)\n3. **Replace**: Substitute with placeholder character\n\nDefault: Strip (cleanest output)\n\n## API Design\n// Sanitized by default\nharness.write_log('User provided text with \\x1b[31mattack\\x1b[0m');\n// -> 'User provided text with attack'\n\n// Explicit opt-in for trusted content\nharness.write_raw(trusted_ansi_bytes);\n\n// Text with explicit trust level\nText::sanitized(user_input);\nText::raw(trusted_source);\n\n## Consequences\n- User content is safe by default\n- Trusted content must be explicitly marked\n- Some legitimate ANSI in logs will be stripped\n- Security posture matches threat model\n\n## Test Plan\n- PTY tests feeding adversarial sequences into logs\n- Assert terminal invariants remain intact\n- Fuzz tests with random byte streams in log paths\n- Verify no state leakage after malicious input","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T22:09:25.501690222Z","created_by":"ubuntu","updated_at":"2026-01-31T22:09:25.501690222Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.10.6","depends_on_id":"bd-10i.10","type":"parent-child","created_at":"2026-01-31T22:09:25.501690222Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11","title":"Testing + QA: Verification Suite","description":"# Testing + QA: Verification Suite\n\n## Purpose\nKernel must be 'boringly correct'. Testing is not optional - it's how we prove our claims and prevent regressions.\n\n## Test Categories\n\n### Unit Tests (Kernel)\n- Cell packing/equality\n- Buffer bounds + scissor/opacity invariants\n- GraphemePool refcount correctness\n- LinkRegistry correctness\n- Width measurement accuracy\n\n### Property Tests (Randomized)\n- Diff correctness: applying changes reproduces target buffer\n- Presenter state tracking never emits malformed sequences\n- Width correctness: rendering never writes beyond frame bounds\n\n### Snapshot Tests (Widgets/Apps)\n- Frame buffers across themes and widths\n- Segment streams for export pipelines\n- Deterministic outputs in simulator mode\n\n### PTY Integration Tests (Terminal Reality)\nSpawn a PTY, run minimal ftui app, capture output, assert:\n- Cursor restored after each present() in Inline mode\n- Raw mode restored on exit\n- Cursor visibility restored (show cursor)\n- Bracketed paste/mouse modes disabled on exit\n- Alt screen exited on exit\n\nTest scenarios:\n- Normal exit\n- Panic during render\n- IO error mid-write\n\n### Fuzzing (Input Parser)\n- Random byte streams\n- No panics\n- Sequence length limits enforced\n- Linear time for worst-case inputs\n\n### Terminal-Model Tests\nValidate presenter output by:\n- Building a terminal emulator model (subset of sequences)\n- Running presenter output through model\n- Asserting resulting grid + cursor state matches expected\n\n## Quality Gates (Stop-Ship)\n1. Inline mode stability - no cursor corruption\n2. Diff/presenter correctness - terminal-model passes\n3. Unicode width correctness - ZWJ/emoji corpus passes\n4. Terminal cleanup - PTY tests verify panic cleanup\n\n## CI Enforcement\n- clippy + fmt\n- All test categories run\n- Performance benchmarks tracked (non-blocking initially)\n- Feature matrix: default, +extras\n\n## Success Criteria\n- [ ] All stop-ship gates are enforced by automated tests.\n- [ ] A contributor can reproduce failures locally with clear logs/artifacts.\n- [ ] PTY + terminal-model coverage prevents cursor corruption regressions.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:07:07.502368766Z","created_by":"ubuntu","updated_at":"2026-01-31T23:27:18.513550331Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:07:07.502368766Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T22:21:29.525092512Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11.1","title":"Build terminal-model test harness","description":"# Build terminal-model test harness\n\n## Background\nPlan Section 0.7 Quality Gate 2 requires: \"Property tests validate that applying presenter output to a terminal-model yields the expected grid for supported ops.\"\n\nThe terminal-model is a simplified terminal emulator that we use to verify presenter output correctness WITHOUT needing a real terminal.\n\n## Purpose\nA terminal model that:\n1. Parses ANSI escape sequences\n2. Updates internal grid state\n3. Tracks cursor position\n4. Tracks style state\n5. Enables property testing of presenter output\n\n## Terminal Model Structure\n\n```rust\n/// Simplified terminal model for testing presenter output\n/// \n/// # Supported Sequences\n/// - SGR (Select Graphic Rendition): styles\n/// - CUP (Cursor Position): CSI row ; col H\n/// - Cursor movement: CSI n A/B/C/D\n/// - EL (Erase Line): CSI n K\n/// - ED (Erase Display): CSI n J\n/// - OSC 8 (Hyperlinks): basic support\n/// - DEC synchronized output markers (ignored)\npub struct TerminalModel {\n    grid: Vec<Vec<ModelCell>>,\n    cursor_x: u16,\n    cursor_y: u16,\n    current_style: ModelStyle,\n    current_link: Option<String>,\n    width: u16,\n    height: u16,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct ModelCell {\n    pub char: char,\n    pub style: ModelStyle,\n    pub link: Option<String>,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug, Default)]\npub struct ModelStyle {\n    pub fg: Option<Rgb>,\n    pub bg: Option<Rgb>,\n    pub bold: bool,\n    pub dim: bool,\n    pub italic: bool,\n    pub underline: bool,\n    pub blink: bool,\n    pub reverse: bool,\n    pub strikethrough: bool,\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\npub struct Rgb {\n    pub r: u8,\n    pub g: u8,\n    pub b: u8,\n}\n```\n\n## ANSI Parser\n\n```rust\nimpl TerminalModel {\n    /// Feed bytes to the terminal model\n    pub fn feed(&mut self, bytes: &[u8]) {\n        let mut parser = AnsiParser::new();\n        for &byte in bytes {\n            if let Some(action) = parser.advance(byte) {\n                self.execute(action);\n            }\n        }\n    }\n    \n    fn execute(&mut self, action: AnsiAction) {\n        match action {\n            AnsiAction::Print(c) => {\n                self.put_char(c);\n                self.cursor_x += 1;\n                if self.cursor_x >= self.width {\n                    self.cursor_x = 0;\n                    self.cursor_y = (self.cursor_y + 1).min(self.height - 1);\n                }\n            }\n            AnsiAction::CursorPosition(row, col) => {\n                self.cursor_y = row.saturating_sub(1).min(self.height - 1);\n                self.cursor_x = col.saturating_sub(1).min(self.width - 1);\n            }\n            AnsiAction::CursorUp(n) => {\n                self.cursor_y = self.cursor_y.saturating_sub(n);\n            }\n            AnsiAction::CursorDown(n) => {\n                self.cursor_y = (self.cursor_y + n).min(self.height - 1);\n            }\n            AnsiAction::CursorForward(n) => {\n                self.cursor_x = (self.cursor_x + n).min(self.width - 1);\n            }\n            AnsiAction::CursorBack(n) => {\n                self.cursor_x = self.cursor_x.saturating_sub(n);\n            }\n            AnsiAction::EraseLine(mode) => {\n                self.erase_line(mode);\n            }\n            AnsiAction::EraseDisplay(mode) => {\n                self.erase_display(mode);\n            }\n            AnsiAction::Sgr(params) => {\n                self.apply_sgr(&params);\n            }\n            AnsiAction::Osc8Start(url) => {\n                self.current_link = Some(url);\n            }\n            AnsiAction::Osc8End => {\n                self.current_link = None;\n            }\n            AnsiAction::SyncStart | AnsiAction::SyncEnd => {\n                // Ignored - just markers\n            }\n        }\n    }\n    \n    fn put_char(&mut self, c: char) {\n        let x = self.cursor_x as usize;\n        let y = self.cursor_y as usize;\n        if y < self.grid.len() && x < self.grid[y].len() {\n            self.grid[y][x] = ModelCell {\n                char: c,\n                style: self.current_style.clone(),\n                link: self.current_link.clone(),\n            };\n        }\n    }\n}\n```\n\n## SGR Parsing\n\n```rust\nimpl TerminalModel {\n    fn apply_sgr(&mut self, params: &[u16]) {\n        let mut i = 0;\n        while i < params.len() {\n            match params[i] {\n                0 => {\n                    self.current_style = ModelStyle::default();\n                }\n                1 => self.current_style.bold = true,\n                2 => self.current_style.dim = true,\n                3 => self.current_style.italic = true,\n                4 => self.current_style.underline = true,\n                5 => self.current_style.blink = true,\n                7 => self.current_style.reverse = true,\n                9 => self.current_style.strikethrough = true,\n                22 => {\n                    self.current_style.bold = false;\n                    self.current_style.dim = false;\n                }\n                23 => self.current_style.italic = false,\n                24 => self.current_style.underline = false,\n                25 => self.current_style.blink = false,\n                27 => self.current_style.reverse = false,\n                29 => self.current_style.strikethrough = false,\n                38 => {\n                    // Foreground color\n                    if i + 4 < params.len() && params[i + 1] == 2 {\n                        self.current_style.fg = Some(Rgb {\n                            r: params[i + 2] as u8,\n                            g: params[i + 3] as u8,\n                            b: params[i + 4] as u8,\n                        });\n                        i += 4;\n                    }\n                }\n                48 => {\n                    // Background color\n                    if i + 4 < params.len() && params[i + 1] == 2 {\n                        self.current_style.bg = Some(Rgb {\n                            r: params[i + 2] as u8,\n                            g: params[i + 3] as u8,\n                            b: params[i + 4] as u8,\n                        });\n                        i += 4;\n                    }\n                }\n                _ => {}\n            }\n            i += 1;\n        }\n    }\n}\n```\n\n## Comparison with Buffer\n\n```rust\nimpl TerminalModel {\n    /// Compare terminal model state with an ftui Buffer\n    /// Returns list of differences for debugging\n    pub fn diff_with_buffer(&self, buffer: &Buffer) -> Vec<CellDiff> {\n        let mut diffs = Vec::new();\n        \n        for y in 0..self.height.min(buffer.height()) {\n            for x in 0..self.width.min(buffer.width()) {\n                let model_cell = &self.grid[y as usize][x as usize];\n                let buffer_cell = buffer.get(x, y).unwrap();\n                \n                if !cells_match(model_cell, buffer_cell) {\n                    diffs.push(CellDiff {\n                        x, y,\n                        model: model_cell.clone(),\n                        buffer: describe_cell(buffer_cell),\n                    });\n                }\n            }\n        }\n        \n        diffs\n    }\n    \n    /// Assert terminal model matches buffer exactly\n    pub fn assert_matches(&self, buffer: &Buffer) {\n        let diffs = self.diff_with_buffer(buffer);\n        if !diffs.is_empty() {\n            panic!(\"Terminal model does not match buffer:\\\\n{:#?}\", diffs);\n        }\n    }\n}\n```\n\n## Property Testing\n\n```rust\nuse proptest::prelude::*;\n\nproptest! {\n    /// Presenter output applied to terminal model produces expected grid\n    #[test]\n    fn presenter_roundtrip(buffer in arb_buffer(80, 24)) {\n        // Start with empty terminal model\n        let mut model = TerminalModel::new(80, 24);\n        \n        // Present buffer to get ANSI output\n        let mut output = Vec::new();\n        let mut presenter = Presenter::new(&mut output, caps);\n        presenter.present_full(&buffer, &pool, &links)?;\n        \n        // Feed output to terminal model\n        model.feed(&output);\n        \n        // Verify model matches buffer\n        model.assert_matches(&buffer);\n    }\n    \n    /// Diff-based present matches full present\n    #[test]\n    fn diff_matches_full(\n        buffer1 in arb_buffer(80, 24),\n        buffer2 in arb_buffer(80, 24)\n    ) {\n        // Full present of buffer2\n        let mut model_full = TerminalModel::new(80, 24);\n        let mut output_full = Vec::new();\n        Presenter::new(&mut output_full, caps).present_full(&buffer2, ...)?;\n        model_full.feed(&output_full);\n        \n        // Diff present from buffer1 to buffer2\n        let mut model_diff = TerminalModel::new(80, 24);\n        model_diff.feed(&present_full_output(&buffer1)); // Start state\n        let diff = BufferDiff::compute(&buffer1, &buffer2);\n        let mut output_diff = Vec::new();\n        Presenter::new(&mut output_diff, caps).present(&buffer2, &diff, ...)?;\n        model_diff.feed(&output_diff);\n        \n        // Both should produce same final state\n        assert_eq!(model_full.grid, model_diff.grid);\n    }\n}\n```\n\n## Logging for Test Debugging\n\n```rust\nimpl TerminalModel {\n    /// Dump model state for debugging\n    pub fn dump(&self) -> String {\n        let mut out = String::new();\n        for (y, row) in self.grid.iter().enumerate() {\n            out.push_str(&format!(\"{:3}| \", y));\n            for cell in row {\n                out.push(cell.char);\n            }\n            out.push('\\\\n');\n        }\n        out.push_str(&format!(\"Cursor: ({}, {})\\\\n\", self.cursor_x, self.cursor_y));\n        out.push_str(&format!(\"Style: {:?}\\\\n\", self.current_style));\n        out\n    }\n}\n\n#[test]\nfn test_with_logging() {\n    tracing_test::init();\n    \n    let mut model = TerminalModel::new(80, 24);\n    tracing::debug!(\"Initial state:\\\\n{}\", model.dump());\n    \n    model.feed(output);\n    tracing::debug!(\"After feed:\\\\n{}\", model.dump());\n    \n    let diffs = model.diff_with_buffer(&buffer);\n    if !diffs.is_empty() {\n        tracing::error!(\"Differences found: {:#?}\", diffs);\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Parses SGR sequences correctly\n- [ ] Tracks cursor position correctly\n- [ ] Handles CUP (cursor position) correctly\n- [ ] Handles erase operations (EL, ED)\n- [ ] Handles OSC 8 hyperlinks\n- [ ] Property tests pass (100+ iterations)\n- [ ] Detailed logging for debugging failures\n- [ ] Model matches buffer for all supported sequences\n\n## Dependencies\n- Requires: bd-10i.4.3 (Presenter to test)\n- Blocks: bd-2x0j (Property tests use this)\n- Blocks: bd-2gx (Quality Gate 2)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:15:13.041157455Z","created_by":"ubuntu","updated_at":"2026-02-01T00:28:09.733707114Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11.1","depends_on_id":"bd-10i.11","type":"parent-child","created_at":"2026-01-31T22:15:13.041157455Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.1","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:22:44.711973170Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11.2","title":"Create PTY test framework (ftui-pty)","description":"# Create PTY test framework (ftui-pty)\n\n## Objective\nBuild a test utility crate for running ftui apps in a PTY and validating terminal behavior.\n\n## Why PTY Tests?\n- Verify real terminal behavior (not mocked)\n- Test cleanup on panic\n- Test cursor restoration\n- Validate inline mode works correctly\n- Catch issues terminal-model cannot\n\n## PTY Test Capabilities\n\n### Spawn App in PTY\n```rust\npub fn spawn_app<F>(f: F) -> PtySession\nwhere F: FnOnce(&mut TerminalSession) -> io::Result<()>\n```\n\n- Fork process\n- Set up PTY pair\n- Run closure in child\n- Capture output in parent\n\n### Capture Terminal Output\n```rust\nimpl PtySession {\n    fn read_output(&mut self) -> Vec<u8>;\n    fn read_until(&mut self, pattern: &[u8], timeout: Duration) -> Result<Vec<u8>>;\n    fn send_input(&mut self, bytes: &[u8]);\n    fn wait(&mut self) -> ExitStatus;\n}\n```\n\n### Assert Terminal State\nAfter app exits, verify terminal is restored:\n```rust\npub fn assert_terminal_restored(output: &[u8]) {\n    // Check for:\n    // - SGR 0 (reset style)\n    // - CSI ? 25 h (show cursor)\n    // - CSI ? 1049 l (exit alt screen) if was used\n    // - CSI ? 1000 l (disable mouse) if was enabled\n    // - CSI ? 2004 l (disable bracketed paste) if was enabled\n}\n```\n\n### Test Panic Cleanup\n```rust\n#[test]\nfn panic_cleanup() {\n    let session = spawn_app(|term| {\n        term.enter_raw_mode()?;\n        term.enable_mouse()?;\n        panic\\!(\"deliberate panic for testing cleanup\");\n    });\n\n    let output = session.read_output();\n    assert_terminal_restored(&output);\n}\n```\n\n## Inline Mode Tests\n\n### Test Cursor Contract\n```rust\n#[test]\nfn inline_cursor_restored() {\n    let session = spawn_app(|term| {\n        let harness = AgentHarness::new(ScreenMode::Inline { ui_height: 3 });\n        // Write logs and present UI multiple times\n        for _ in 0..100 {\n            harness.write_log(\"log line\\n\")?;\n            harness.present()?;\n        }\n        // Cursor should be at consistent position\n        Ok(())\n    });\n\n    // Verify no cursor drift in output\n    assert_cursor_stable(&session.output);\n}\n```\n\n### Test Scrollback Preservation\n```rust\n#[test]\nfn inline_scrollback_preserved() {\n    // Verify scrollback content not corrupted\n    // by inline mode rendering\n}\n```\n\n## Detailed Logging Requirements\n\n### Test Output Format\n```\n[2026-01-31T12:00:00Z] PTY_TEST_START: panic_cleanup\n[2026-01-31T12:00:00Z] PTY_SPAWN: child_pid=12345\n[2026-01-31T12:00:00Z] PTY_OUTPUT: captured 1234 bytes\n[2026-01-31T12:00:00Z] PTY_CHECK: SGR_RESET found at offset 1200\n[2026-01-31T12:00:00Z] PTY_CHECK: CURSOR_SHOW found at offset 1220\n[2026-01-31T12:00:00Z] PTY_TEST_PASS: panic_cleanup (elapsed: 0.5s)\n```\n\n### On Failure\n```\n[2026-01-31T12:00:00Z] PTY_TEST_FAIL: panic_cleanup\n[2026-01-31T12:00:00Z] PTY_FAILURE_REASON: Missing SGR_RESET sequence\n[2026-01-31T12:00:00Z] PTY_OUTPUT_DUMP: (hex)\n  0000: 1b 5b 48 1b 5b 32 4a ...\n[2026-01-31T12:00:00Z] PTY_OUTPUT_DUMP: (printable)\n  ESC[H ESC[2J ...\n[2026-01-31T12:00:00Z] PTY_EXPECTED: SGR 0 (1b 5b 30 6d) before exit\n```\n\n## Platform Considerations\n- Use `nix` crate for Unix PTY (forkpty, openpty)\n- Windows: may need ConPTY or skip tests with `#[cfg(unix)]`\n- CI: ensure PTY available (not all containers have it)\n\n## Tests Required\n- [ ] spawn_app works on Linux/macOS\n- [ ] Normal exit restores terminal\n- [ ] Panic exit restores terminal (panic hook works)\n- [ ] Inline mode cursor contract maintained\n- [ ] Alt screen enter/exit works\n- [ ] Mouse mode cleanup verified\n- [ ] Bracketed paste cleanup verified\n- [ ] Focus events cleanup verified\n- [ ] Resize during operation handled\n\n## Acceptance Criteria\n- [ ] `ftui-pty` crate with spawn_app and assert helpers\n- [ ] Works on Linux and macOS\n- [ ] CI can run PTY tests (documented requirements)\n- [ ] Cleanup verified for all exit paths (normal, panic, signal)\n- [ ] Detailed logging for debugging failures\n- [ ] Timeout handling (tests do not hang)\n\n## Location: ftui-pty crate (test-only helper)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:15:31.768264464Z","created_by":"ubuntu","updated_at":"2026-01-31T23:54:27.372628954Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11.2","depends_on_id":"bd-10i.11","type":"parent-child","created_at":"2026-01-31T22:15:31.768264464Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.2","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T22:22:44.982133948Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.2","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T22:22:45.226347218Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.11.3","title":"Implement input parser fuzzing","description":"# Implement input parser fuzzing\n\n## Objective\nFuzz the InputParser to ensure it handles all possible byte sequences without panicking or excessive resource usage.\n\n## Why Fuzzing?\n- Terminal input is untrusted\n- Malformed sequences are common\n- DoS via crafted input is possible\n- Parser must be robust\n\n## Fuzz Targets\n\n### Target 1: Raw Byte Parsing\nfuzz_target\\!(|data: &[u8]| {\n    let mut parser = InputParser::new();\n    let _ = parser.parse(data);\n    // Must not panic\n    // Must not hang\n    // Must not exceed memory limits\n});\n\n### Target 2: Structured Fuzzing\n// Generate semi-valid sequences\n#[derive(Arbitrary)]\nenum FuzzSequence {\n    Char(u8),\n    Escape,\n    Csi(Vec<u8>),\n    Osc(Vec<u8>),\n    Mouse { button: u8, x: u16, y: u16 },\n    Paste(Vec<u8>),\n}\n\n### Target 3: Long Sequences\n// Specifically test DoS limits\nfuzz_target\\!(|len: u16| {\n    let data = vec\\![0x1b, b'[']  // CSI\n        .into_iter()\n        .chain(std::iter::repeat(b'0').take(len as usize))\n        .chain(std::iter::once(b'm'))\n        .collect::<Vec<_>>();\n\n    let mut parser = InputParser::new();\n    let _ = parser.parse(&data);\n    // Should not allocate unbounded memory\n});\n\n## Properties to Verify\n1. No panics on any input\n2. Memory bounded (no OOM from crafted input)\n3. Time bounded (no quadratic behavior)\n4. Always returns to Ground state eventually\n5. DoS limits enforced\n\n## Corpus Seeds\n- Valid key sequences\n- Valid mouse sequences\n- Bracketed paste boundaries\n- OSC 8 links\n- Malformed UTF-8\n- Truncated sequences\n\n## Running Fuzzer\ncargo +nightly fuzz run input_parser -- -max_len=4096\n\n## Integration with CI\n- Run fuzzer for limited time on each PR\n- Maintain corpus in repo\n- Report new crashes immediately\n\n## Tests Required\n- [ ] Fuzz harness builds\n- [ ] Initial corpus covers major cases\n- [ ] No crashes in 1-hour fuzz session\n- [ ] Memory limits enforced\n\n## Acceptance Criteria\n- [ ] Fuzzer integrated in CI\n- [ ] No panics found\n- [ ] Corpus maintained\n- [ ] Coverage tracked","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:15:47.811194117Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:45.486723842Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.11.3","depends_on_id":"bd-10i.11","type":"parent-child","created_at":"2026-01-31T22:15:47.811194117Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.11.3","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:22:45.486693585Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.12","title":"Docs: Playbook, Glossary, References","description":"# Docs: Playbook, Glossary, References\n\n## Purpose\nEncode the *non-code* parts of PLAN_TO_CREATE_FRANKENTUI__OPUS.md into durable, discoverable docs so future work does **not** require rereading the plan document.\n\nThis epic is about:\n- capturing the project's intent, constraints, and invariants\n- preventing churn (ADRs + playbook)\n- making the library *pleasant to adopt* (tutorials + examples)\n\n## Scope (v1)\n- Operational Playbook (Chapter 17)\n- Terminal Compatibility Matrix (Chapter 16)\n- Glossary (Appendix B)\n- Risk Register (Appendix C)\n- ANSI Reference extraction (Appendix A)\n- Migration map / \"what we kept\" from the three libraries (Chapter 14 + 1.5)\n- Public API docs + examples (Section 0.8)\n\n## Non-goals\n- Duplicating ADRs here (ADRs remain in bd-10i.10)\n- Writing long-form tutorials before the kernel is stable\n\n## Success Criteria\n- [ ] Every doc deliverable in PLAN_TO_CREATE_FRANKENTUI__OPUS.md (Chapter 16/17 + Appendices A/B/C + Chapter 14) has a corresponding issue with acceptance criteria and test hooks where applicable.\n- [ ] Docs are written with enough context that a contributor can implement features without reopening the original plan.\n- [ ] Docs include explicit \"undefined behavior\" and \"out of scope\" notes where the plan is opinionated (one-writer rule, inline mode, sanitize-by-default).","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T23:07:35.746628357Z","created_by":"ubuntu","updated_at":"2026-01-31T23:14:45.174558275Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.12","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T23:07:35.746628357Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.12","depends_on_id":"bd-10i.10","type":"blocks","created_at":"2026-01-31T23:14:45.174515294Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.12.1","title":"Write Operational Playbook (Chapter 17)","description":"# Write Operational Playbook (Chapter 17)\n\n## Background\nChapter 17 exists to prevent the common failure mode of kernel projects: infinite refinement without a stable deliverable.\n\nThe playbook is part technical, part process:\n- which PRs require which test gates\n- how ADRs are written and frozen\n- the recommended shipping order (avoid the widget trap)\n- what \"agent-ergonomic\" means in concrete UX terms\n\n## Deliverable\nCreate a durable doc (e.g. `docs/operational-playbook.md`) that captures:\n\n### Merge-gate rules (from 17.1)\n- Any change touching: inline mode cursor policy, presenter output sequencing, input parser, width measurement\n  must include appropriate tests (unit/property/pty/snapshot) and must cite which invariants are preserved.\n\n### ADR discipline (from 17.2)\n- ADR template (Context / Decision / Alternatives / Consequences / Test Plan)\n- Rules for when an ADR is required\n\n### Minimal deliverables order (from 17.3)\n1) Kernel (buffer/diff/presenter + terminal session + inline stability)\n2) Runtime (update/view + simulator + snapshot)\n3) Harness (reference app proving inline/log/UI)\n4) Widgets (only harness essentials)\n5) Extras (feature-gated)\n\n### Agent-ergonomic checklist (from 17.4)\n- Hello world harness in <200 LOC\n- Tool output streaming is one function call\n- Pinned bottom UI is one config option\n- Temporary full-screen modal supported\n\n### Immediate Next Steps checklist (from 17.5)\nConvert the listed \"first PRs\" into checkboxes and link them to the relevant Beads tasks.\n\n## Acceptance Criteria\n- [ ] Doc exists with the sections above.\n- [ ] Doc explicitly ties each rule to a reason (cursor safety, one-writer, determinism).\n- [ ] Doc links to the relevant ADR issues and test-suite epics.\n- [ ] Doc includes an \"Out of scope\" section to prevent accidental widget creep.","status":"open","priority":1,"issue_type":"docs","created_at":"2026-01-31T23:07:50.447594010Z","created_by":"ubuntu","updated_at":"2026-01-31T23:07:50.447594010Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.12.1","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:07:50.447594010Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.12.2","title":"Write Glossary (Appendix B)","description":"# Write Glossary (Appendix B)\n\n## Background\nThe plan includes a short glossary of terms that recur throughout the kernel design. This needs to be in-repo so future contributors don't need the plan doc to understand terminology.\n\n## Deliverable\nCreate `docs/glossary.md` containing (at minimum) the glossary table below, plus any additional terms introduced by implementation.\n\n| Term | Definition |\n|------|------------|\n| **Cell** | Single grid position (content + fg + bg + attrs) |\n| **Buffer** | 2D array of Cells representing display state |\n| **Frame** | Buffer + metadata for a render pass |\n| **Diff** | Set of (x, y) positions that changed between buffers |\n| **Presenter** | State-tracked ANSI emitter |\n| **Grapheme** | User-perceived character (may be multiple codepoints) |\n| **GraphemePool** | Interned storage for complex grapheme clusters |\n| **LinkRegistry** | URL storage for OSC 8 hyperlinks |\n| **Scissor** | Clipping rectangle for rendering |\n| **SGR** | Select Graphic Rendition (style codes) |\n| **OSC** | Operating System Command (escape sequence) |\n| **CSI** | Control Sequence Introducer (`\\x1b[`) |\n| **DEC** | Digital Equipment Corporation (terminal standard) |\n| **ZWJ** | Zero Width Joiner (connects graphemes into compound) |\n| **Porter-Duff** | Compositing algebra for alpha blending |\n\n## Acceptance Criteria\n- [ ] `docs/glossary.md` exists.\n- [ ] Table is present and correct.\n- [ ] Any additional ftui-specific terms (e.g., TerminalWriter, ScreenMode, UiAnchor) are added with concise definitions.","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T23:08:02.312315920Z","created_by":"ubuntu","updated_at":"2026-01-31T23:08:02.312315920Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.12.2","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:08:02.312315920Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.12.3","title":"Write Risk Register + Mitigation Links (Appendix C)","description":"# Write Risk Register + Mitigation Links (Appendix C)\n\n## Background\nThe plan includes a small Risk Register to keep engineering effort focused on the failure modes that destroy trust in a terminal UI kernel (cursor corruption, escape injection, width bugs, capability mismatches, unsafe creep, byte bloat, interleaved writes).\n\nWe want this risk list in-repo so:\n- mitigations stay attached to code and tests\n- adding features doesn't silently reintroduce known risks\n\n## Deliverable\nCreate `docs/risk-register.md` that includes the plan's risks and extends them with:\n- the *actual* Beads issue IDs that mitigate the risk\n- the *actual* test suites / scripts that enforce the mitigation\n\n## Required risks (from plan)\n1) Inline mode cursor corruption\n- Mitigation: PTY tests + strict cursor policy + centralized writer API for logs/UI.\n\n1b) ANSI / OSC injection via untrusted log content\n- Mitigation: sanitize-by-default + explicit opt-in raw passthrough + adversarial PTY tests.\n\n2) Unicode width bugs\n- Mitigation: curated test corpus + snapshot tests + ASCII fast path only when proven.\n\n3) Terminal capability mismatches\n- Mitigation: conservative defaults + feature detection + robust fallbacks.\n\n4) Unsafe creep\n- Mitigation: forbid unsafe by default; isolate any perf tricks; require tests + benches.\n\n5) Presenter byte bloat\n- Mitigation: run grouping + style-run coalescing + output-length benchmarks in CI.\n\n6) Interleaved stdout writes from user code\n- Mitigation: one-writer rule; TerminalSession/TerminalWriter; routing/capture patterns.\n\n## Acceptance Criteria\n- [ ] `docs/risk-register.md` exists and contains the risks above.\n- [ ] Each mitigation links to specific Beads issues and/or specific test suites (unit/property/pty/e2e).\n- [ ] The risk register includes a short section \"How to add a new risk\" and \"When to revisit\".","status":"open","priority":1,"issue_type":"docs","created_at":"2026-01-31T23:08:14.246182Z","created_by":"ubuntu","updated_at":"2026-01-31T23:08:14.246182Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.12.3","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:08:14.246182Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.12.4","title":"Extract ANSI Escape Reference into docs","description":"# Extract ANSI Escape Reference into docs\n\n## Background\nAppendix A of the plan contains a minimal ANSI escape sequence reference. Keeping this in-repo helps:\n- implement Presenter/TerminalWriter correctly\n- write terminal-model tests that parse the exact sequences we emit\n- avoid \"tribal knowledge\" and copy/paste drift\n\n## Deliverable\nCreate `docs/ansi-reference.md` with:\n- SGR codes used by ftui\n- Cursor movement + save/restore (ANSI + DEC)\n- Screen control (alt screen, clear line, cursor show/hide)\n- Synchronized output (DEC 2026)\n- OSC 8 hyperlinks\n- Mouse mode enables (SGR encoding)\n- Bracketed paste enables + boundaries\n- Focus events enables + events\n\nSeed content (from plan):\n\n### SGR\n- `\\x1b[0m` reset\n- `\\x1b[1m` bold\n- `\\x1b[3m` italic\n- `\\x1b[4m` underline\n- `\\x1b[38;2;R;G;Bm` truecolor fg\n- `\\x1b[48;2;R;G;Bm` truecolor bg\n- `\\x1b[38;5;Nm` 256 fg\n- `\\x1b[48;5;Nm` 256 bg\n\n### Cursor\n- `\\x1b[{r};{c}H` move\n- `\\x1b[s` save (ANSI)\n- `\\x1b[u` restore (ANSI)\n- `\\x1b7` save (DEC)\n- `\\x1b8` restore (DEC)\n\n### Synchronized Output\n- `\\x1b[?2026h` begin\n- `\\x1b[?2026l` end\n\n### OSC 8\n- `\\x1b]8;;URL\\x1b\\\\` start\n- `\\x1b]8;;\\x1b\\\\` end\n\n(Include the rest from Appendix A.)\n\n## Acceptance Criteria\n- [ ] `docs/ansi-reference.md` exists.\n- [ ] Reference is sufficient to implement the presenter and terminal-model parser without consulting external docs.\n- [ ] Doc explicitly notes which sequences are *emitted* vs merely *parsed*.","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T23:08:26.761368523Z","created_by":"ubuntu","updated_at":"2026-01-31T23:08:26.761368523Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.12.4","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:08:26.761368523Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.12.5","title":"Write Migration Map + Source→ftui mapping (Chapter 14 + 1.5)","description":"# Write Migration Map + Source→ftui mapping (Chapter 14 + 1.5)\n\n## Background\nThe plan explicitly says FrankenTUI is *not* a 1:1 port. We keep concepts, not types.\n\nHowever, future contributors will still ask:\n- \"Where did this idea come from?\"\n- \"Which library handled X well?\"\n- \"What did we intentionally drop?\"\n\nChapter 14 (Migration Map) and Chapter 1.5 (What survives vs what gets dropped) answer that.\n\n## Deliverable\nCreate `docs/migration-map.md` that includes:\n- Migration principles (Chapter 14.1)\n- Conceptual mapping: source concept → ftui concept (Chapter 14.2)\n- Compatibility strategy notes (Chapter 14.3)\n- Explicit \"survives vs dropped\" lists (Chapter 1.5)\n\n## Acceptance Criteria\n- [ ] Doc exists and is understandable without the plan.\n- [ ] Doc includes a clear \"Dropped / de-scoped\" section to prevent accidental scope creep (widget zoo, full terminal emulation, etc.).\n- [ ] Doc includes a section \"When to add a new crate vs extend an existing crate\" aligned with the three-ring architecture.","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T23:08:35.526344211Z","created_by":"ubuntu","updated_at":"2026-01-31T23:08:35.526344211Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.12.5","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:08:35.526344211Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.12.6","title":"Write One-Writer Rule Guidance + Routing Patterns","description":"# Write One-Writer Rule Guidance + Routing Patterns\n\n## Background\nThe plan's one-writer rule is the cornerstone that makes inline mode + streaming logs robust.\n\nWe already have ADR-005 describing *why* the rule exists and what breaks if violated.\nThis doc is about *how users actually comply* in real apps.\n\n## Deliverable\nCreate a user-facing doc (e.g. `docs/one-writer-rule.md`) that covers:\n\n- What \"one-writer\" means (which bytes count as terminal state mutations)\n- What is explicitly unsupported / undefined behavior (e.g., third-party `println!` while inline mode is active)\n- Supported routing patterns (from ADR-005):\n  - LogSink / in-process logs routed through ftui (sanitization applies)\n  - PTY capture for subprocess output (preferred for harnesses)\n  - Optional stdio capture / forwarding (best-effort)\n- Concrete examples:\n  - \"stream tool output\" example\n  - \"capture stderr\" example\n  - \"mux policy\" notes for tmux/screen\n- Safety notes:\n  - sanitize-by-default\n  - when to use raw passthrough and why it is dangerous\n\n## Acceptance Criteria\n- [ ] Doc exists and is linked from the main README/API docs.\n- [ ] Doc includes at least 2 copy/paste-ready examples.\n- [ ] Doc explicitly references ADR-005 and ADR-006.","status":"open","priority":1,"issue_type":"docs","created_at":"2026-01-31T23:09:22.706274596Z","created_by":"ubuntu","updated_at":"2026-01-31T23:09:22.706274596Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.12.6","depends_on_id":"bd-10i.10.5","type":"blocks","created_at":"2026-01-31T23:09:22.706274596Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.12.6","depends_on_id":"bd-10i.10.6","type":"blocks","created_at":"2026-01-31T23:09:22.706274596Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.12.6","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:09:22.706274596Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.13","title":"Formal Specs + Invariants (Chapter 2/3)","description":"# Formal Specs + Invariants (Chapter 2/3)\n\n## Purpose\nCapture the \"math-informed\" parts of the plan as durable specifications and executable checks so correctness claims remain explicit.\n\nThis is not about proving everything; it's about making the kernel invariants *obvious* and keeping regressions from creeping in.\n\n## Scope\nFrom the plan:\n- Chapter 2: Terminal state machine (TLA+-style sketch), rendering pipeline state machine, buffer invariants.\n- Chapter 3: Cache hierarchy analysis and the 16-byte Cell rationale.\n\n## Outputs\n- Human-readable spec docs (in `docs/spec/` or similar)\n- Executable checks:\n  - unit tests for invariants (dimensions, scissor/opacity stack laws, grapheme pool refcount laws)\n  - property tests where meaningful (diff correctness, presenter invariants)\n\n## Success Criteria\n- [ ] The terminal/pipeline state-machine sketches are translated into a contributor-friendly spec doc.\n- [ ] The \"16 bytes per Cell\" and row-major scan rationale is recorded next to the code-level constraints/tests.\n- [ ] Each named invariant has an associated test or a conscious rationale for why it is not testable.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T23:09:42.157052080Z","created_by":"ubuntu","updated_at":"2026-01-31T23:09:42.157052080Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.13","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T23:09:42.157052080Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.13.1","title":"Write Spec Doc: Terminal + Rendering Pipeline State Machines","description":"# Write Spec Doc: Terminal + Rendering Pipeline State Machines\n\n## Background\nPlan Chapter 2 provides:\n- a TLA+-style sketch for a terminal state machine\n- a rendering pipeline state machine\n\nWe want these written down in a way that directly informs implementation and testing.\n\n## Deliverable\nCreate `docs/spec/state-machines.md` that captures:\n\n### Terminal State Machine (plan 2.1)\n- State variables: cursor, style, grid, mode\n- Allowed modes: Normal, Raw, AltScreen (and any ftui-specific submodes)\n- Safety invariants: cursor bounds, grid cell validity\n\n### Rendering Pipeline State Machine (plan 2.2)\nStates: Idle, Measuring, Rendering, Diffing, Presenting, Error\n\nInvariants (from plan):\n- In Rendering, only back buffer is modified\n- In Presenting, only ANSI output is produced\n- After Presenting, front buffer == desired grid\n- Error state restores terminal to a safe state\n- Scissor stack intersection monotonically decreases on push\n- Opacity stack product stays in [0,1]\n\n## Acceptance Criteria\n- [ ] Doc exists and matches the plan's states/invariants.\n- [ ] Doc links to the exact code modules that implement each state/transition.\n- [ ] Doc lists which invariants are enforced by type system vs runtime checks vs tests.","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T23:09:55.712585863Z","created_by":"ubuntu","updated_at":"2026-01-31T23:09:55.712585863Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.13.1","depends_on_id":"bd-10i.13","type":"parent-child","created_at":"2026-01-31T23:09:55.712585863Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.13.2","title":"Add Executable Invariant Tests (Chapter 2.3)","description":"# Add Executable Invariant Tests (Chapter 2.3)\n\n## Background\nPlan 2.3 lists explicit invariants for Buffer, scissor/opacity stacks, and GraphemePool validity.\n\nWe want these invariants to be enforced by tests so regressions are caught immediately.\n\n## Invariants to encode (from plan)\n- Buffer dimensions: width/height immutable; cells length == width*height\n- Cell access bounds: safe get/set reject out-of-bounds\n- Scissor stack intersection monotonically decreases on push\n- Opacity stack product stays in [0,1]\n- GraphemePool: slot.refcount > 0 implies slot is valid\n- CellContent with GraphemeId implies id is valid in associated pool\n\n## Test Strategy\n- Unit tests for the deterministic invariants (stack behaviors, bounds)\n- Property tests for randomized sequences of push/pop (scissor/opacity)\n- Explicit regression tests for tricky cases (empty stacks, nested clips, full transparency)\n\n## Acceptance Criteria\n- [ ] Unit tests exist for each invariant above.\n- [ ] Property tests cover randomized stack operation sequences.\n- [ ] Tests are fast and deterministic (seeded) and run in CI.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:10:14.263918675Z","created_by":"ubuntu","updated_at":"2026-01-31T23:10:14.263918675Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.13.2","depends_on_id":"bd-10i.13","type":"parent-child","created_at":"2026-01-31T23:10:14.263918675Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.13.2","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T23:10:14.263918675Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.13.2","depends_on_id":"bd-10i.3.5","type":"blocks","created_at":"2026-01-31T23:10:14.263918675Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.13.2","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T23:10:14.263918675Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.13.3","title":"Write Cache/Layout Rationale (16-byte Cell, row-major scan)","description":"# Write Cache/Layout Rationale (16-byte Cell, row-major scan)\n\n## Background\nPlan Chapter 3 explains why the kernel is designed around:\n- a 16-byte Cell (4 cells per 64-byte cache line)\n- row-major, sequential access patterns for diffing and rendering\n\nThis rationale is core to ftui's performance promises and should live next to the code and benchmarks.\n\n## Deliverable\nCreate `docs/spec/cache-and-layout.md` capturing:\n- L1/L2/L3 and cache-line assumptions (as *guidance*, not a hard guarantee)\n- why 16 bytes is the sweet spot (4 per cache line)\n- why we avoid pointer chasing and per-cell allocations\n- why row-major scan is the default diff strategy\n- how the benchmarks validate these choices\n\n## Acceptance Criteria\n- [ ] Doc exists and includes the plan's key points (Chapter 3.1-3.3).\n- [ ] Doc links to `Cell`/`Buffer`/`Diff` code and the perf benchmark suite.\n- [ ] Doc clearly distinguishes \"must-hold\" invariants (e.g., `size_of::<Cell>() == 16`) from \"expected performance behavior\".","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T23:10:26.815219736Z","created_by":"ubuntu","updated_at":"2026-01-31T23:10:26.815219736Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.13.3","depends_on_id":"bd-10i.13","type":"parent-child","created_at":"2026-01-31T23:10:26.815219736Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.13.3","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T23:10:26.815219736Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.13.3","depends_on_id":"bd-19x","type":"blocks","created_at":"2026-01-31T23:10:26.815219736Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2","title":"Phase 0: Contracts + Workspace Skeleton","description":"# Phase 0: Contracts + Workspace Skeleton\n\n## Purpose\nEstablish the foundational structure before any implementation. This phase creates the workspace layout, defines public contracts, and documents locked decisions via ADRs.\n\n## Deliverables\n1. Workspace crate layout (ftui-core/render/style/text/layout/runtime/widgets/extras)\n2. Public contracts for kernel types: Cell, Buffer, Frame, Presenter, TerminalSession, Event\n3. ADRs for all locked decisions from Section 0.6 of the plan\n4. ftui facade crate with thin stable API surface\n5. Safety policy applied consistently (`#![forbid(unsafe_code)]` per AGENTS.md; SIMD must be safe/portable or deferred)\n\n## Exit Criteria\n- Public API compiles\n- Minimal demo crate prints a frame in Inline mode\n- All ADRs written and reviewed\n\n## Why This Phase Matters\nWithout clear contracts and workspace organization, the project will accumulate accidental complexity. This phase forces us to commit to boundaries and interfaces before writing implementation code.\n\n## Workspace Crate Layout (Target)\n- ftui: facade/public API (re-exports stable types)\n- ftui-core: raw mode, lifecycle guards, capability detection, input parsing, screen mode policy\n- ftui-render: Cell, Buffer, Frame, GraphemePool, LinkRegistry, HitGrid, Diff engine, Presenter\n- ftui-style: TextStyle, CellStyle, Theme, semantic colors, color downgrade\n- ftui-text: Text, Segment, width measurement, wrapping, truncation, alignment\n- ftui-layout: Rect, constraints, row/col/grid layout, measurement protocol\n- ftui-runtime: Bubbletea/Elm-like Program, Model, Cmd, scheduler, simulator\n- ftui-widgets: Component library (feature-gated)\n- ftui-extras: Markdown, syntax highlighting, export, SSH, forms (feature-gated)\n- ftui-harness: Agent harness reference implementation\n- ftui-pty: Test-only PTY utilities\n\n## Success Criteria\n- [ ] Workspace layout exists and enforces intended layering boundaries.\n- [ ] Core public contracts are written and reviewed before implementation starts.\n- [ ] Safety policy is explicit and consistent (no accidental unsafe).\n- [ ] ADR epic is unblocked and actively used to lock decisions.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:04:51.251200646Z","created_by":"ubuntu","updated_at":"2026-01-31T23:25:17.592526002Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:04:51.251200646Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2","depends_on_id":"bd-10i.1","type":"blocks","created_at":"2026-01-31T22:21:20.041547122Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2","depends_on_id":"bd-10i.10","type":"blocks","created_at":"2026-01-31T22:21:20.320818635Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.1","title":"Create Cargo workspace with crate layout","description":"# Create Cargo workspace with crate layout\n\n## Objective\nSet up the multi-crate workspace structure that enforces layering boundaries.\n\n## Crate Layout\n\n### ftui (facade)\n- Re-exports stable public types (App, ScreenMode, Event, Frame, Style)\n- Provides prelude, ergonomic builders, sensible defaults\n- What most apps depend on\n\n### ftui-core\n- Raw mode + terminal lifecycle guards (RAII)\n- Capability detection (env heuristics + optional queries)\n- Input parsing into canonical Event\n- Screen mode policy helpers (Inline/AltScreen)\n\n### ftui-render\n- Cell, Buffer, Frame (Frame = buffer + optional hit grid + metadata)\n- GraphemePool, LinkRegistry, optional HitGrid\n- Diff engine (cell-level scan + run grouping)\n- Presenter (ANSI writer, state tracked)\n- Optional simd feature (unsafe isolated)\n\n### ftui-style\n- Visual styling model (TextStyle, CellStyle, Theme)\n- Color downgrade (TrueColor -> 256 -> 16 -> ASCII)\n- Deterministic style merge semantics\n\n### ftui-text\n- Text, Span, Segment (+ markup parser as optional)\n- Width measurement, wrapping, truncation, alignment\n- Caches (LRU widths) and grapheme segmentation\n\n### ftui-layout\n- Rect, constraints, row/col/grid layout, measurement protocol\n\n### ftui-runtime (optional)\n- Bubbletea/Elm-like Program, Model, Cmd, scheduler\n- Deterministic simulator\n\n### ftui-widgets (feature-gated)\n- Component library on kernel + style/text/layout\n\n### ftui-extras (feature-gated)\n- Markdown, syntax highlighting, export, SSH, forms\n\n### ftui-harness (examples)\n- Agent harness reference implementation\n\n### ftui-simd (optional, unsafe allowed)\n- Feature-gated hot loop implementations\n- Strict rules: depends on ftui-render, has scalar fallback\n\n### ftui-pty (test-only)\n- PTY spawning utilities for golden-output harness\n\n## Workspace Cargo.toml\n[workspace]\nmembers = [\n    'ftui',\n    'ftui-core',\n    'ftui-render',\n    'ftui-style',\n    'ftui-text',\n    'ftui-layout',\n    'ftui-runtime',\n    'ftui-widgets',\n    'ftui-extras',\n    'ftui-harness',\n    'ftui-simd',\n    'ftui-pty',\n]\n\n## Safety Policy\nAll crates except ftui-simd: #![forbid(unsafe_code)]\n\n## Acceptance Criteria\n- [ ] Workspace compiles\n- [ ] Each crate has lib.rs with module structure\n- [ ] Dependency graph matches layering (render depends on core, etc.)\n- [ ] forbid(unsafe_code) in place","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:09:47.418333371Z","created_by":"ubuntu","updated_at":"2026-01-31T22:09:47.418333371Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.1","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:09:47.418333371Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.2","title":"Define public Cell API contract","description":"# Define public Cell API contract\n\n## Objective\nDocument and lock the Cell type's public API before implementation. Cell is the most fundamental type - changes here ripple everywhere.\n\n## Cell Contract\n\n### Layout (16 bytes, non-negotiable)\n#[repr(C, align(16))]\npub struct Cell {\n    pub content: CellContent,  // 4 bytes\n    pub fg: PackedRgba,        // 4 bytes\n    pub bg: PackedRgba,        // 4 bytes\n    pub attrs: CellAttrs,      // 4 bytes\n}\n\n### Why 16 Bytes?\n- 4 cells per 64-byte cache line (perfect fit)\n- Single 128-bit SIMD comparison\n- No heap allocation for 99% of cells\n- 24 bytes wastes cache, 32 bytes doubles bandwidth\n\n### CellContent (4 bytes)\nEncoding: [31: type bit][30-0: data]\n- Bit 31 == 0: char (Unicode scalar value)\n- Bit 31 == 1: GraphemeId (pool slot + width)\n\npub struct CellContent(u32);\nimpl CellContent {\n    const EMPTY: Self;\n    fn from_char(c: char) -> Self;\n    fn from_grapheme(id: GraphemeId) -> Self;\n    fn is_grapheme(&self) -> bool;\n    fn width(&self) -> usize;\n}\n\n### PackedRgba (4 bytes)\nLayout: [R:8][G:8][B:8][A:8] native endian\n\npub struct PackedRgba(pub u32);\nimpl PackedRgba {\n    const TRANSPARENT: Self;\n    const BLACK: Self;\n    const WHITE: Self;\n    fn rgb(r: u8, g: u8, b: u8) -> Self;\n    fn rgba(r: u8, g: u8, b: u8, a: u8) -> Self;\n    fn r(&self) -> u8;\n    fn g(&self) -> u8;\n    fn b(&self) -> u8;\n    fn a(&self) -> u8;\n    fn over(self, dst: Self) -> Self;  // Porter-Duff\n    fn with_opacity(self, opacity: f32) -> Self;\n}\n\n### CellAttrs (4 bytes)\nLayout: [31-24: flags][23-0: link_id]\n\npub struct CellAttrs(u32);\nimpl CellAttrs {\n    const NONE: Self;\n    fn new(flags: StyleFlags, link_id: u32) -> Self;\n    fn flags(&self) -> StyleFlags;\n    fn link_id(&self) -> u32;\n    fn with_flags(self, flags: StyleFlags) -> Self;\n    fn with_link(self, link_id: u32) -> Self;\n}\n\n### Cell Methods\nimpl Cell {\n    const CONTINUATION: Self;  // Placeholder for wide chars\n    fn is_continuation(&self) -> bool;\n    fn bits_eq(&self, other: &Self) -> bool;\n    fn width(&self) -> usize;\n}\n\n## Acceptance Criteria\n- [ ] API documented in code comments\n- [ ] Type layout verified with assert_eq!(size_of::<Cell>(), 16)\n- [ ] All methods have doc comments explaining purpose\n- [ ] No pub fields that could break invariants later","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:05.152050042Z","created_by":"ubuntu","updated_at":"2026-01-31T22:10:05.152050042Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.2","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:05.152050042Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.3","title":"Define public Buffer API contract","description":"# Define public Buffer API contract\n\n## Objective\nDocument and lock the Buffer type's public API. Buffer is the 2D grid that holds Cells.\n\n## Buffer Contract\n\n### Core Structure\npub struct Buffer {\n    width: u16,\n    height: u16,\n    cells: Vec<Cell>,\n    scissor_stack: Vec<Rect>,\n    opacity_stack: Vec<f32>,\n}\n\n### Invariants (MUST ALWAYS HOLD)\n1. cells.len() == width * height\n2. width/height never change after creation\n3. Scissor stack intersection monotonically decreases on push\n4. Opacity stack product stays in [0, 1]\n5. Scissor/opacity stacks always have at least one element\n\n### Constructor\nfn new(width: u16, height: u16) -> Self\n- Initializes cells to Cell::default()\n- Scissor stack starts with full buffer rect\n- Opacity stack starts with 1.0\n\n### Cell Access\nfn get(&self, x: u16, y: u16) -> Option<&Cell>\n- Returns None if out of bounds\n\nfn get_unchecked(&self, x: u16, y: u16) -> &Cell\n- No bounds check, panics on OOB (debug) or UB (release)\n- Only use when bounds verified\n\nfn set(&mut self, x: u16, y: u16, cell: Cell)\n- Respects scissor (skips if outside)\n- Applies opacity stack to cell colors\n- Applies alpha compositing if bg has transparency\n- Handles wide character continuation cells\n\n### Scissor Stack\nfn push_scissor(&mut self, rect: Rect)\n- Computes intersection with current scissor\n- Pushes intersected rect\n\nfn pop_scissor(&mut self)\n- Pops if stack.len() > 1 (preserves base)\n\nfn current_scissor(&self) -> Rect\n- Returns top of stack\n\n### Opacity Stack\nfn push_opacity(&mut self, opacity: f32)\n- Clamps to [0, 1]\n- Pushes current * new\n\nfn pop_opacity(&mut self)\n- Pops if stack.len() > 1\n\nfn current_opacity(&self) -> f32\n- Returns top of stack\n\n### Utilities\nfn clear(&mut self)\n- Fills all cells with Cell::default()\n\nfn cells(&self) -> &[Cell]\n- Raw slice for diffing\n\nfn width(&self) -> u16\nfn height(&self) -> u16\n\n## Frame Contract\nFrame = Buffer + render pass metadata\n\npub struct Frame {\n    pub buffer: Buffer,\n    pub hit_grid: Option<HitGrid>,\n    pub cursor_position: Option<(u16, u16)>,\n    pub cursor_visible: bool,\n}\n\n## Acceptance Criteria\n- [ ] All methods documented\n- [ ] Invariants stated in code comments\n- [ ] Test for each invariant\n- [ ] No UB in safe API","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:19.954399597Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:42.521135471Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.3","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:19.954399597Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2.3","depends_on_id":"bd-10i.2.2","type":"blocks","created_at":"2026-01-31T22:21:42.521099182Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.4","title":"Define Event types contract","description":"# Define Event types contract\n\n## Objective\nDocument and lock the canonical Event types used throughout ftui.\n\n## Event Enum\npub enum Event {\n    Key(KeyEvent),\n    Mouse(MouseEvent),\n    Resize { width: u16, height: u16 },\n    Paste(PasteEvent),\n    Focus(bool),  // true = gained, false = lost\n    Clipboard(ClipboardEvent),  // optional, feature-gated\n}\n\n## KeyEvent\npub struct KeyEvent {\n    pub code: KeyCode,\n    pub modifiers: Modifiers,\n    pub kind: KeyEventKind,  // Press/Repeat/Release\n}\n\nimpl KeyEvent {\n    fn is_char(&self, c: char) -> bool;\n}\n\n## KeyCode\npub enum KeyCode {\n    Char(char),\n    Enter, Escape, Backspace, Tab, BackTab,\n    Delete, Insert, Home, End,\n    PageUp, PageDown,\n    Up, Down, Left, Right,\n    F(u8),\n    Null,\n}\n\n## KeyEventKind\npub enum KeyEventKind {\n    Press,    // Key pressed (default)\n    Repeat,   // Key held (when available)\n    Release,  // Key released (when available)\n}\n\n## Modifiers\nbitflags! {\n    pub struct Modifiers: u8 {\n        const SHIFT = 0b0001;\n        const ALT   = 0b0010;\n        const CTRL  = 0b0100;\n        const SUPER = 0b1000;\n    }\n}\n\n## MouseEvent\npub struct MouseEvent {\n    pub kind: MouseEventKind,\n    pub x: u16,\n    pub y: u16,\n    pub modifiers: Modifiers,\n}\n\n## MouseEventKind\npub enum MouseEventKind {\n    Down(MouseButton),\n    Up(MouseButton),\n    Drag(MouseButton),\n    Moved,\n    ScrollUp,\n    ScrollDown,\n}\n\n## MouseButton\npub enum MouseButton {\n    Left, Right, Middle,\n}\n\n## PasteEvent\npub struct PasteEvent {\n    pub text: String,\n    pub bracketed: bool,  // True if from bracketed paste mode\n}\n\n## ClipboardEvent (Optional)\npub struct ClipboardEvent {\n    pub content: String,\n    pub source: ClipboardSource,\n}\n\npub enum ClipboardSource { Osc52, Unknown }\n\n## Design Notes\n- Events are Clone + PartialEq + Eq for use in tests\n- Modifiers use bitflags for easy combination\n- Mouse coordinates are 0-indexed (terminal is 1-indexed)\n- KeyEventKind defaults to Press when not available\n\n## Acceptance Criteria\n- [ ] All types documented\n- [ ] Derive Clone, Debug, PartialEq, Eq where appropriate\n- [ ] Event can be converted From Crossterm events","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:33.715692497Z","created_by":"ubuntu","updated_at":"2026-01-31T22:10:33.715692497Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.4","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:33.715692497Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.5","title":"Define TerminalCapabilities contract","description":"# Define TerminalCapabilities contract\n\n## Objective\nDocument the capability detection model that informs how ftui behaves on different terminals.\n\n## TerminalCapabilities Structure\npub struct TerminalCapabilities {\n    // Color support\n    pub true_color: bool,\n    pub colors_256: bool,\n\n    // Advanced features\n    pub sync_output: bool,       // DEC mode 2026\n    pub osc8_hyperlinks: bool,\n    pub scroll_region: bool,     // DECSTBM\n\n    // Multiplexer detection\n    pub in_tmux: bool,\n    pub in_screen: bool,\n    pub in_zellij: bool,\n\n    // Input features\n    pub kitty_keyboard: bool,\n    pub focus_events: bool,\n    pub bracketed_paste: bool,\n    pub mouse_sgr: bool,\n\n    // Optional features\n    pub osc52_clipboard: bool,   // Best-effort output\n}\n\n## Detection Logic\n\n### Environment Variables\n- COLORTERM: truecolor, 24bit\n- TERM: terminal type (kitty, xterm-256color, etc.)\n- TERM_PROGRAM: iTerm.app, WezTerm, Alacritty, Ghostty\n- NO_COLOR: disable color (de-facto standard)\n- TMUX, STY, ZELLIJ: multiplexer detection\n- KITTY_WINDOW_ID: Kitty detection\n\n### Detection Rules\ntrue_color = \\!NO_COLOR && (COLORTERM contains truecolor/24bit\n             || TERM_PROGRAM in modern terminals)\n\nsync_output = TERM_PROGRAM in [WezTerm, Alacritty, Ghostty]\n              || TERM contains kitty\n\nosc8_hyperlinks = \\!NO_COLOR && TERM_PROGRAM in modern terminals\n\nscroll_region = TERM \\!= dumb (broadly supported)\n\nosc52_clipboard = \\!in_any_mux && TERM \\!= dumb (security restricted)\n\n## Methods\nimpl TerminalCapabilities {\n    fn detect() -> Self;      // From environment\n    fn basic() -> Self;       // Minimal fallback\n    fn in_any_mux(&self) -> bool;  // Any multiplexer?\n}\n\n## Multiplexer Notes\n- TMUX/screen/zellij sit between us and terminal\n- May need passthrough for some features\n- Some features disabled in mux by default\n- WezTerm/Kitty built-in mux doesn't need special handling\n\n## Future: Runtime Probing\nOptional feature-gated probing:\n- Device attribute queries (DA)\n- OSC queries for capabilities\n- Must be bounded with timeouts\n\n## Acceptance Criteria\n- [ ] All fields documented with detection logic\n- [ ] detect() works on common terminals\n- [ ] basic() provides safe fallback\n- [ ] in_any_mux() helper available","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:10:51.010479895Z","created_by":"ubuntu","updated_at":"2026-01-31T22:10:51.010479895Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.5","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:10:51.010479895Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.6","title":"Define TerminalSession lifecycle contract","description":"# Define TerminalSession lifecycle contract\n\n## Objective\nDocument the RAII-based terminal lifecycle management that ensures cleanup even on panic.\n\n## TerminalSession Structure\npub struct TerminalSession<W: Write> {\n    writer: W,\n    raw_mode_active: bool,\n    alt_screen_active: bool,\n    mouse_active: bool,\n    bracketed_paste_active: bool,\n    capabilities: TerminalCapabilities,\n}\n\n## Lifecycle Guarantees\n1. All terminal state changes tracked\n2. Drop restores previous state\n3. Panic hook ensures cleanup\n4. No leaked state on any exit path\n\n## Constructor\nfn new(writer: W) -> io::Result<Self>\n- Detects capabilities\n- Installs panic hook for cleanup\n- Does NOT enter raw mode automatically\n\n## Terminal Modes\nfn enter_raw_mode(&mut self) -> io::Result<()>\n- Enables raw mode (no echo, no line buffering)\n- Tracks state for cleanup\n\nfn enter_alt_screen(&mut self) -> io::Result<()>\n- Switches to alternate screen buffer\n- Emits CSI ? 1049 h\n\nfn enable_mouse(&mut self) -> io::Result<()>\n- Enables SGR mouse mode (1000, 1002, 1006)\n- Tracks for cleanup\n\nfn enable_bracketed_paste(&mut self) -> io::Result<()>\n- Enables bracketed paste mode\n- Emits CSI ? 2004 h\n\nfn enable_focus_events(&mut self) -> io::Result<()>\n- Enables focus tracking\n- Emits CSI ? 1004 h\n\n## Cleanup (Drop)\nimpl<W: Write> Drop for TerminalSession<W> {\n    fn drop(&mut self) {\n        // Disable mouse modes\n        // Disable bracketed paste\n        // Exit alt screen\n        // Reset style (SGR 0)\n        // Show cursor\n        // Restore raw mode (via backend)\n        // Flush\n    }\n}\n\n## Panic Hook\nOn panic, best-effort cleanup:\n- Exit alt screen\n- Show cursor\n- Reset style\n- Disable mouse\n- Disable bracketed paste\n- Flush\n\n## Escape Sequences Reference\n- Alt screen: CSI ? 1049 h/l\n- Mouse: CSI ? 1000/1002/1006 h/l\n- Bracketed paste: CSI ? 2004 h/l\n- Focus events: CSI ? 1004 h/l\n- Show cursor: CSI ? 25 h\n- Reset style: CSI 0 m\n\n## Acceptance Criteria\n- [ ] All state changes tracked\n- [ ] Drop cleans up all active modes\n- [ ] Panic hook installed and tested\n- [ ] PTY test verifies cleanup","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:11:05.056405558Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:42.784922059Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.6","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:11:05.056405558Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2.6","depends_on_id":"bd-10i.2.4","type":"blocks","created_at":"2026-01-31T22:21:42.784885690Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.2.7","title":"Create ftui facade crate with prelude","description":"# Create ftui facade crate with prelude\n\n## Objective\nCreate the user-facing ftui crate that re-exports stable types and provides ergonomic defaults.\n\n## Purpose\n- Single dependency for most apps\n- Stable API surface\n- Hides internal crate complexity\n- Provides sensible prelude\n\n## Re-exports from Internal Crates\n\n### From ftui-core\n- Event, KeyEvent, MouseEvent, KeyCode, Modifiers\n- TerminalCapabilities, TerminalSession\n- ScreenMode (Inline, AltScreen)\n\n### From ftui-render\n- Cell, CellContent, CellAttrs\n- Buffer, Frame\n- GraphemePool, LinkRegistry\n- Presenter (advanced users)\n\n### From ftui-style\n- Style, TextStyle, CellStyle\n- Color, Theme\n- StyleFlags\n\n### From ftui-text\n- Text, Span\n\n### From ftui-layout\n- Rect, Sides, Measurement\n\n### From ftui-runtime (optional)\n- App, Program, Model, Cmd\n- ProgramSimulator\n\n## Prelude\npub mod prelude {\n    pub use crate::{\n        App, Cmd, Event, Frame, Model,\n        ScreenMode, Style, Result,\n    };\n}\n\n## Ergonomic Builders\n// App builder\nApp::new(model)\n    .screen_mode(ScreenMode::Inline { ui_height: 6 })\n    .run()\n\n// Style builder\nStyle::new().fg(Color::Red).bold()\n\n## Result Type\npub type Result<T> = std::result::Result<T, Error>;\n\n## Error Type\npub enum Error {\n    Io(std::io::Error),\n    Terminal(String),\n    // Add as needed\n}\n\n## Acceptance Criteria\n- [ ] All public types re-exported\n- [ ] Prelude provides common types\n- [ ] App builder compiles (even if not implemented)\n- [ ] Rustdoc renders correctly","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:11:17.978848598Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:42.267890083Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.2.7","depends_on_id":"bd-10i.2","type":"parent-child","created_at":"2026-01-31T22:11:17.978848598Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.2.7","depends_on_id":"bd-10i.2.1","type":"blocks","created_at":"2026-01-31T22:21:42.267859596Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3","title":"Phase 1: Core Render Kernel","description":"# Phase 1: Core Render Kernel\n\n## Purpose\nImplement the sacred kernel types that everything else builds upon. This is the most critical phase - these types must be correct, fast, and stable.\n\n## Core Types to Implement\n1. Cell (16 bytes exactly): content + fg + bg + attrs\n2. CellContent: char or GraphemeId encoding\n3. CellAttrs: flags (8 bits) + link_id (24 bits)\n4. PackedRgba: RGBA as u32 with Porter-Duff blending\n5. GraphemeId + GraphemePool: reference-counted interned complex strings\n6. Buffer: 2D grid with scissor/opacity stacks\n7. Rect, Sides, Measurement primitives\n\n## Technical Constraints\n\n### Cell Layout (The 16-Byte Sweet Spot)\n- 16 bytes = exactly 4 cells per 64-byte cache line\n- Layout: content(4B) + fg(4B) + bg(4B) + attrs(4B)\n- Must use repr(C, align(16)) if needed to preserve layout\n\n### Why NOT 24 or 32 bytes?\n- 24 bytes: 2.67 cells/line, wastes 16 bytes per line\n- 32 bytes: 2 cells/line, doubles memory bandwidth\n- 16 bytes: Perfect fit, minimal cache misses\n\n### CellContent Encoding\n- Bit 31 == 0: char (Unicode scalar value)\n- Bit 31 == 1: GraphemeId (pool slot in bits 0-23, width in bits 24-30)\n\n### GraphemePool\n- Reference-counted slots for memory efficiency\n- Intern on first use, reuse existing ID if present\n- Free list for slot reuse\n- Refcount management via incref/decref\n\n## Exit Criteria\n- Unit tests pass for all types\n- Scalar bits_eq is correct\n- Buffer invariants enforced (bounds, scissor monotonicity, opacity in [0,1])\n- No unsafe code in this phase\n\n## Success Criteria\n- [ ] `Cell` is 16 bytes and equality/compare is fast and correct.\n- [ ] `Buffer` is correct-by-construction with enforced scissor/opacity invariants.\n- [ ] Grapheme pooling works (no leaks, correct refcounts, stable IDs).\n- [ ] Unit tests exist for every invariant (plus property tests where appropriate).","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:06.240633451Z","created_by":"ubuntu","updated_at":"2026-01-31T23:25:37.190034987Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:06.240633451Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3","depends_on_id":"bd-10i.2","type":"blocks","created_at":"2026-01-31T22:21:20.563899021Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.1","title":"Implement CellContent with char/grapheme encoding","description":"# Implement CellContent with char/grapheme encoding\n\n## Objective\nImplement the 4-byte CellContent type that efficiently encodes either a single char or a GraphemeId reference.\n\n## Technical Design\n\n### Encoding Scheme\nBit 31 (type discriminator):\n- 0: Direct char (bits 0-30 contain Unicode scalar value)\n- 1: GraphemeId reference (bits 0-23 = slot, bits 24-30 = width)\n\nThis allows:\n- 99% of cells (ASCII/BMP) to be stored without heap\n- Complex graphemes (emoji, ZWJ sequences) stored in pool\n\n### Implementation\n#[derive(Clone, Copy, PartialEq, Eq)]\n#[repr(transparent)]\npub struct CellContent(u32);\n\nimpl CellContent {\n    pub const EMPTY: Self = Self(0);\n\n    #[inline]\n    pub fn from_char(c: char) -> Self {\n        Self(c as u32)\n    }\n\n    #[inline]\n    pub fn from_grapheme(id: GraphemeId) -> Self {\n        Self(0x8000_0000 | id.0)\n    }\n\n    #[inline]\n    pub fn is_grapheme(&self) -> bool {\n        self.0 & 0x8000_0000 != 0\n    }\n\n    #[inline]\n    pub fn as_char(&self) -> Option<char> {\n        if self.is_grapheme() {\n            None\n        } else {\n            char::from_u32(self.0)\n        }\n    }\n\n    #[inline]\n    pub fn width(&self) -> usize {\n        if self.is_grapheme() {\n            ((self.0 >> 24) & 0x7F) as usize\n        } else if self.0 == 0 {\n            0\n        } else {\n            unicode_width::UnicodeWidthChar::width(\n                char::from_u32(self.0).unwrap_or(' ')\n            ).unwrap_or(1)\n        }\n    }\n}\n\n## GraphemeId Structure\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n#[repr(transparent)]\npub struct GraphemeId(u32);\n\nimpl GraphemeId {\n    #[inline]\n    pub fn new(slot: u32, width: u8) -> Self {\n        debug_assert!(slot < 0x00FF_FFFF);\n        debug_assert!(width < 128);\n        Self((slot & 0x00FF_FFFF) | ((width as u32) << 24))\n    }\n\n    #[inline]\n    pub fn slot(&self) -> usize {\n        (self.0 & 0x00FF_FFFF) as usize\n    }\n\n    #[inline]\n    pub fn width(&self) -> usize {\n        ((self.0 >> 24) & 0x7F) as usize\n    }\n}\n\n## Tests Required\n- [ ] from_char roundtrip for ASCII\n- [ ] from_char roundtrip for BMP chars\n- [ ] from_char roundtrip for supplementary planes\n- [ ] from_grapheme encodes slot and width\n- [ ] width() correct for narrow, wide, emoji\n- [ ] EMPTY has width 0\n- [ ] is_grapheme() discriminates correctly\n\n## Acceptance Criteria\n- [ ] size_of::<CellContent>() == 4\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Inline hints on hot paths","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:11:34.587530319Z","created_by":"ubuntu","updated_at":"2026-02-01T00:23:41.551174254Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.1","depends_on_id":"bd-10i.2.2","type":"blocks","created_at":"2026-01-31T22:21:50.998689812Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.1","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:11:34.587530319Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.1","depends_on_id":"bd-rk95","type":"blocks","created_at":"2026-02-01T00:23:41.551123519Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.2","title":"Implement PackedRgba with Porter-Duff blending","description":"# Implement PackedRgba with Porter-Duff blending\n\n## Objective\nImplement the 4-byte packed RGBA color type with efficient alpha compositing.\n\n## Technical Design\n\n### Layout\n[R:8][G:8][B:8][A:8] in native endian as u32\n\n### Why Packed?\n- 4 bytes fits in Cell's 16-byte budget\n- Fast equality comparison (single u32 compare)\n- SIMD-friendly for bulk operations\n\n### Porter-Duff 'Over' Compositing\nResult = src + dst × (1 - src.alpha)\n\nThis is the standard way to composite translucent colors:\n- Fully opaque src (alpha=255): result = src\n- Fully transparent src (alpha=0): result = dst\n- Partial: blend proportionally\n\n### Implementation\n#[derive(Clone, Copy, PartialEq, Eq, Default)]\n#[repr(transparent)]\npub struct PackedRgba(pub u32);\n\nimpl PackedRgba {\n    pub const TRANSPARENT: Self = Self(0);\n    pub const BLACK: Self = Self::rgb(0, 0, 0);\n    pub const WHITE: Self = Self::rgb(255, 255, 255);\n\n    #[inline]\n    pub const fn rgb(r: u8, g: u8, b: u8) -> Self {\n        Self(((r as u32) << 24) | ((g as u32) << 16) \n             | ((b as u32) << 8) | 255)\n    }\n\n    #[inline]\n    pub const fn rgba(r: u8, g: u8, b: u8, a: u8) -> Self {\n        Self(((r as u32) << 24) | ((g as u32) << 16) \n             | ((b as u32) << 8) | (a as u32))\n    }\n\n    // Component accessors\n    #[inline] pub fn r(&self) -> u8 { (self.0 >> 24) as u8 }\n    #[inline] pub fn g(&self) -> u8 { (self.0 >> 16) as u8 }\n    #[inline] pub fn b(&self) -> u8 { (self.0 >> 8) as u8 }\n    #[inline] pub fn a(&self) -> u8 { self.0 as u8 }\n\n    /// Porter-Duff 'over': src over dst\n    #[inline]\n    pub fn over(self, dst: Self) -> Self {\n        let src_a = self.a() as u32;\n        if src_a == 255 { return self; }\n        if src_a == 0 { return dst; }\n\n        let inv_a = 255 - src_a;\n        let r = ((self.r() as u32 * 255) + (dst.r() as u32 * inv_a)) / 255;\n        let g = ((self.g() as u32 * 255) + (dst.g() as u32 * inv_a)) / 255;\n        let b = ((self.b() as u32 * 255) + (dst.b() as u32 * inv_a)) / 255;\n        let a = src_a + ((dst.a() as u32 * inv_a) / 255);\n\n        Self::rgba(r as u8, g as u8, b as u8, a as u8)\n    }\n\n    /// Apply uniform opacity [0.0, 1.0]\n    #[inline]\n    pub fn with_opacity(self, opacity: f32) -> Self {\n        let a = ((self.a() as f32) * opacity.clamp(0.0, 1.0)) as u8;\n        Self((self.0 & 0xFFFF_FF00) | (a as u32))\n    }\n}\n\n## Tests Required\n- [ ] rgb() creates color with alpha=255\n- [ ] rgba() preserves all components\n- [ ] Component accessors round-trip\n- [ ] over() with opaque src returns src\n- [ ] over() with transparent src returns dst\n- [ ] over() blends correctly for 50% alpha\n- [ ] with_opacity() scales alpha correctly\n\n## Acceptance Criteria\n- [ ] size_of::<PackedRgba>() == 4\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Porter-Duff matches reference implementation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:11:52.455911761Z","created_by":"ubuntu","updated_at":"2026-01-31T22:11:52.455911761Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.2","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:11:52.455911761Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.3","title":"Implement CellAttrs with StyleFlags","description":"# Implement CellAttrs with StyleFlags\n\n## Objective\nImplement the 4-byte packed attributes type that holds style flags and link ID.\n\n## Technical Design\n\n### Layout\n[31-24: flags (8 bits)][23-0: link_id (24 bits)]\n\n### StyleFlags (8 bits)\nUsing bitflags crate for ergonomic flag manipulation:\n- BOLD (1 << 0)\n- DIM (1 << 1)\n- ITALIC (1 << 2)\n- UNDERLINE (1 << 3)\n- BLINK (1 << 4)\n- REVERSE (1 << 5)\n- STRIKETHROUGH (1 << 6)\n- HIDDEN (1 << 7)\n\n### Link ID (24 bits)\n- 0 = no link\n- 1-16777214 = valid link IDs from LinkRegistry\n- Allows ~16 million unique links per frame\n\n### Implementation\nbitflags::bitflags! {\n    #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n    pub struct StyleFlags: u8 {\n        const BOLD          = 0b0000_0001;\n        const DIM           = 0b0000_0010;\n        const ITALIC        = 0b0000_0100;\n        const UNDERLINE     = 0b0000_1000;\n        const BLINK         = 0b0001_0000;\n        const REVERSE       = 0b0010_0000;\n        const STRIKETHROUGH = 0b0100_0000;\n        const HIDDEN        = 0b1000_0000;\n    }\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Default)]\n#[repr(transparent)]\npub struct CellAttrs(u32);\n\nimpl CellAttrs {\n    pub const NONE: Self = Self(0);\n\n    #[inline]\n    pub fn new(flags: StyleFlags, link_id: u32) -> Self {\n        debug_assert!(link_id < 0x00FF_FFFF, 'link_id overflow');\n        Self(((flags.bits() as u32) << 24) | (link_id & 0x00FF_FFFF))\n    }\n\n    #[inline]\n    pub fn flags(&self) -> StyleFlags {\n        StyleFlags::from_bits_truncate((self.0 >> 24) as u8)\n    }\n\n    #[inline]\n    pub fn link_id(&self) -> u32 {\n        self.0 & 0x00FF_FFFF\n    }\n\n    #[inline]\n    pub fn with_flags(self, flags: StyleFlags) -> Self {\n        Self((self.0 & 0x00FF_FFFF) | ((flags.bits() as u32) << 24))\n    }\n\n    #[inline]\n    pub fn with_link(self, link_id: u32) -> Self {\n        Self((self.0 & 0xFF00_0000) | (link_id & 0x00FF_FFFF))\n    }\n\n    #[inline]\n    pub fn has_flag(&self, flag: StyleFlags) -> bool {\n        self.flags().contains(flag)\n    }\n}\n\n## Tests Required\n- [ ] NONE has no flags and link_id = 0\n- [ ] new() stores flags and link_id correctly\n- [ ] flags() retrieves stored flags\n- [ ] link_id() retrieves stored link_id\n- [ ] with_flags() preserves link_id\n- [ ] with_link() preserves flags\n- [ ] Flag combinations work (BOLD | ITALIC)\n- [ ] Boundary: link_id at max value\n\n## Acceptance Criteria\n- [ ] size_of::<CellAttrs>() == 4\n- [ ] All tests pass\n- [ ] bitflags derive works correctly\n- [ ] No unsafe code","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:12:07.470523869Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:51.278476055Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.3","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:12:07.470523869Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.3","depends_on_id":"bd-10i.3.2","type":"blocks","created_at":"2026-01-31T22:21:51.278445687Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.4","title":"Implement Cell struct (16 bytes)","description":"# Implement Cell struct (16 bytes)\n\n## Objective\nImplement the complete Cell struct that combines all components into exactly 16 bytes.\n\n## Technical Design\n\n### Layout\n#[repr(C, align(16))]\npub struct Cell {\n    pub content: CellContent,  // 4 bytes (offset 0)\n    pub fg: PackedRgba,        // 4 bytes (offset 4)\n    pub bg: PackedRgba,        // 4 bytes (offset 8)\n    pub attrs: CellAttrs,      // 4 bytes (offset 12)\n}\n// Total: 16 bytes, aligned to 16-byte boundary\n\n### Why repr(C, align(16))?\n- Predictable memory layout\n- 4 cells per 64-byte cache line\n- Enables SIMD comparison (128-bit)\n- No padding surprises\n\n### Special Cells\n- CONTINUATION: Placeholder for second column of wide chars\n  - content = 0xFFFF_FFFF (invalid Unicode)\n  - Used when wide char occupies 2 cells\n\n### Implementation\nimpl Default for Cell {\n    fn default() -> Self {\n        Self {\n            content: CellContent::EMPTY,\n            fg: PackedRgba::WHITE,\n            bg: PackedRgba::TRANSPARENT,\n            attrs: CellAttrs::NONE,\n        }\n    }\n}\n\nimpl Cell {\n    pub const CONTINUATION: Self = Self {\n        content: CellContent(0xFFFF_FFFF),\n        fg: PackedRgba::TRANSPARENT,\n        bg: PackedRgba::TRANSPARENT,\n        attrs: CellAttrs::NONE,\n    };\n\n    #[inline]\n    pub fn is_continuation(&self) -> bool {\n        self.content.0 == 0xFFFF_FFFF\n    }\n\n    /// Bitwise equality (fast path for diffing)\n    #[inline]\n    pub fn bits_eq(&self, other: &Self) -> bool {\n        self.content == other.content &&\n        self.fg == other.fg &&\n        self.bg == other.bg &&\n        self.attrs == other.attrs\n    }\n\n    #[inline]\n    pub fn width(&self) -> usize {\n        self.content.width()\n    }\n\n    // Builder methods\n    pub fn char(c: char) -> Self {\n        Self {\n            content: CellContent::from_char(c),\n            ..Default::default()\n        }\n    }\n\n    pub fn fg(mut self, color: PackedRgba) -> Self {\n        self.fg = color;\n        self\n    }\n\n    pub fn bg(mut self, color: PackedRgba) -> Self {\n        self.bg = color;\n        self\n    }\n\n    pub fn attrs(mut self, attrs: CellAttrs) -> Self {\n        self.attrs = attrs;\n        self\n    }\n}\n\nimpl PartialEq for Cell {\n    fn eq(&self, other: &Self) -> bool {\n        self.bits_eq(other)\n    }\n}\n\nimpl Eq for Cell {}\n\n## Tests Required\n- [ ] size_of::<Cell>() == 16\n- [ ] align_of::<Cell>() == 16\n- [ ] Default produces expected values\n- [ ] CONTINUATION is distinguishable\n- [ ] bits_eq matches PartialEq\n- [ ] Builder methods work correctly\n- [ ] width() delegates to content\n\n## Acceptance Criteria\n- [ ] Exact 16-byte size verified\n- [ ] 16-byte alignment verified\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Performance: bits_eq in < 1ns","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:12:22.103820544Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:51.806317486Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.4","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:12:22.103820544Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.4","depends_on_id":"bd-10i.3.1","type":"blocks","created_at":"2026-01-31T22:21:51.553544228Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.4","depends_on_id":"bd-10i.3.3","type":"blocks","created_at":"2026-01-31T22:21:51.806289113Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.5","title":"Implement GraphemePool with refcounting","description":"# Implement GraphemePool with refcounting\n\n## Objective\nImplement the reference-counted pool for complex grapheme clusters (emoji, ZWJ sequences).\n\n## Why GraphemePool?\nMost cells are simple ASCII or BMP characters that fit in CellContent's 4 bytes directly. But some graphemes (emoji with skin tone, ZWJ sequences like family emoji) require multiple Unicode codepoints and variable-length strings.\n\nThe pool:\n- Stores these complex strings once\n- Returns a compact GraphemeId (4 bytes)\n- Reference counts for memory management\n- Reuses slots from free list\n\n## Technical Design\n\n### Slot Structure\nstruct GraphemeSlot {\n    text: String,      // The actual grapheme string\n    width: u8,         // Display width (0-127)\n    refcount: u32,     // Reference count\n}\n\n### Pool Structure\npub struct GraphemePool {\n    strings: Vec<Option<GraphemeSlot>>,  // Slot storage\n    lookup: HashMap<String, GraphemeId>, // Fast dedup\n    free_list: Vec<u32>,                 // Reusable slots\n}\n\n### Implementation\nimpl GraphemePool {\n    pub fn new() -> Self {\n        Self {\n            strings: Vec::new(),\n            lookup: HashMap::new(),\n            free_list: Vec::new(),\n        }\n    }\n\n    /// Intern a grapheme, returning existing ID if present\n    pub fn intern(&mut self, s: &str) -> GraphemeId {\n        // Check if already interned\n        if let Some(&id) = self.lookup.get(s) {\n            self.incref(id);\n            return id;\n        }\n\n        // Calculate display width\n        let width = unicode_width::UnicodeWidthStr::width(s)\n            .min(127) as u8;\n\n        // Find or create slot\n        let slot_idx = self.free_list.pop().unwrap_or_else(|| {\n            let idx = self.strings.len() as u32;\n            self.strings.push(None);\n            idx\n        });\n\n        let id = GraphemeId::new(slot_idx, width);\n        self.strings[slot_idx as usize] = Some(GraphemeSlot {\n            text: s.to_string(),\n            width,\n            refcount: 1,\n        });\n        self.lookup.insert(s.to_string(), id);\n        id\n    }\n\n    /// Get string for ID\n    pub fn get(&self, id: GraphemeId) -> Option<&str> {\n        self.strings.get(id.slot())\n            .and_then(|slot| slot.as_ref())\n            .map(|s| s.text.as_str())\n    }\n\n    /// Increment refcount\n    fn incref(&mut self, id: GraphemeId) {\n        if let Some(Some(slot)) = self.strings.get_mut(id.slot()) {\n            slot.refcount = slot.refcount.saturating_add(1);\n        }\n    }\n\n    /// Decrement refcount, freeing if zero\n    pub fn decref(&mut self, id: GraphemeId) {\n        let slot_idx = id.slot();\n        if let Some(Some(slot)) = self.strings.get_mut(slot_idx) {\n            slot.refcount = slot.refcount.saturating_sub(1);\n            if slot.refcount == 0 {\n                self.lookup.remove(&slot.text);\n                self.strings[slot_idx] = None;\n                self.free_list.push(slot_idx as u32);\n            }\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.strings.iter().filter(|s| s.is_some()).count()\n    }\n}\n\n## Invariants\n- slot.refcount > 0 implies slot is valid\n- GraphemeId only created via pool.intern()\n- lookup and strings are consistent\n- Free list contains only None slots\n\n## Tests Required\n- [ ] intern() returns same ID for same string\n- [ ] intern() increments refcount on reuse\n- [ ] get() retrieves correct string\n- [ ] decref() frees at refcount 0\n- [ ] Free list reuses slots\n- [ ] Width calculation correct for emoji\n- [ ] ZWJ sequences handled\n\n## Acceptance Criteria\n- [ ] All invariants maintained\n- [ ] All tests pass\n- [ ] Intern hit: < 100ns\n- [ ] Intern miss: < 1us","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:12:41.853594562Z","created_by":"ubuntu","updated_at":"2026-02-01T00:23:42.125912103Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.5","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:12:41.853594562Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.5","depends_on_id":"bd-10i.3.1","type":"blocks","created_at":"2026-01-31T22:21:52.050825272Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.5","depends_on_id":"bd-rk95","type":"blocks","created_at":"2026-02-01T00:23:42.125868852Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.6","title":"Implement Buffer with scissor/opacity stacks","description":"# Implement Buffer with scissor/opacity stacks\n\n## Objective\nImplement the 2D cell grid with support for scissor (clipping) and opacity stacks for compositing.\n\n## Technical Design\n\n### Structure\npub struct Buffer {\n    width: u16,\n    height: u16,\n    cells: Vec<Cell>,\n    scissor_stack: Vec<Rect>,\n    opacity_stack: Vec<f32>,\n}\n\n### Invariants\n1. cells.len() == width * height (always)\n2. width/height immutable after creation\n3. Scissor intersection monotonically decreases on push\n4. Opacity product stays in [0, 1]\n5. Both stacks always have at least one element\n\n### Implementation\nimpl Buffer {\n    pub fn new(width: u16, height: u16) -> Self {\n        let size = (width as usize) * (height as usize);\n        Self {\n            width,\n            height,\n            cells: vec![Cell::default(); size],\n            scissor_stack: vec![Rect::new(0, 0, width, height)],\n            opacity_stack: vec![1.0],\n        }\n    }\n\n    // Accessors\n    #[inline]\n    pub fn width(&self) -> u16 { self.width }\n    \n    #[inline]\n    pub fn height(&self) -> u16 { self.height }\n\n    // Cell access with bounds check\n    #[inline]\n    pub fn get(&self, x: u16, y: u16) -> Option<&Cell> {\n        if x < self.width && y < self.height {\n            Some(&self.cells[self.index(x, y)])\n        } else {\n            None\n        }\n    }\n\n    // Unchecked access (for diffing hot path)\n    #[inline]\n    pub fn get_unchecked(&self, x: u16, y: u16) -> &Cell {\n        &self.cells[self.index(x, y)]\n    }\n\n    #[inline]\n    fn index(&self, x: u16, y: u16) -> usize {\n        (y as usize) * (self.width as usize) + (x as usize)\n    }\n\n    // Cell mutation with scissor/opacity\n    pub fn set(&mut self, x: u16, y: u16, mut cell: Cell) {\n        if !self.in_scissor(x, y) { return; }\n\n        // Apply opacity\n        let opacity = self.current_opacity();\n        if opacity < 1.0 {\n            cell.fg = cell.fg.with_opacity(opacity);\n            cell.bg = cell.bg.with_opacity(opacity);\n        }\n\n        // Alpha composite if bg transparent\n        if cell.bg.a() < 255 {\n            if let Some(existing) = self.get(x, y) {\n                cell.bg = cell.bg.over(existing.bg);\n            }\n        }\n\n        let idx = self.index(x, y);\n        self.cells[idx] = cell;\n\n        // Wide char continuation\n        if cell.width() == 2 && x + 1 < self.width {\n            self.cells[idx + 1] = Cell::CONTINUATION;\n        }\n    }\n\n    // Scissor stack\n    pub fn push_scissor(&mut self, rect: Rect) {\n        let current = self.current_scissor();\n        self.scissor_stack.push(current.intersection(&rect));\n    }\n\n    pub fn pop_scissor(&mut self) {\n        if self.scissor_stack.len() > 1 {\n            self.scissor_stack.pop();\n        }\n    }\n\n    fn current_scissor(&self) -> Rect {\n        *self.scissor_stack.last().unwrap()\n    }\n\n    fn in_scissor(&self, x: u16, y: u16) -> bool {\n        self.current_scissor().contains(x, y)\n    }\n\n    // Opacity stack\n    pub fn push_opacity(&mut self, opacity: f32) {\n        let current = self.current_opacity();\n        self.opacity_stack.push(current * opacity.clamp(0.0, 1.0));\n    }\n\n    pub fn pop_opacity(&mut self) {\n        if self.opacity_stack.len() > 1 {\n            self.opacity_stack.pop();\n        }\n    }\n\n    fn current_opacity(&self) -> f32 {\n        *self.opacity_stack.last().unwrap()\n    }\n\n    // Utilities\n    pub fn clear(&mut self) {\n        self.cells.fill(Cell::default());\n    }\n\n    pub fn cells(&self) -> &[Cell] {\n        &self.cells\n    }\n}\n\n## Tests Required\n- [ ] new() creates correct size\n- [ ] get() returns None for OOB\n- [ ] set() respects scissor\n- [ ] push_scissor intersects correctly\n- [ ] pop_scissor preserves base\n- [ ] Opacity multiplies correctly\n- [ ] Wide chars create continuation\n- [ ] clear() resets all cells\n\n## Acceptance Criteria\n- [ ] All invariants tested\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Memory: exactly width*height*16 bytes for cells","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:13:01.324377225Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:52.811032251Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.2.3","type":"blocks","created_at":"2026-01-31T22:21:52.810995362Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:13:01.324377225Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T22:21:52.290284214Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.3.6","depends_on_id":"bd-10i.3.5","type":"blocks","created_at":"2026-01-31T22:21:52.547476017Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.3.7","title":"Implement Rect, Sides, Measurement primitives","description":"# Implement Rect, Sides, Measurement primitives\n\n## Objective\nImplement the layout primitives used throughout ftui.\n\n## Rect (Rectangle)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub struct Rect {\n    pub x: u16,\n    pub y: u16,\n    pub width: u16,\n    pub height: u16,\n}\n\nimpl Rect {\n    pub fn new(x: u16, y: u16, width: u16, height: u16) -> Self {\n        Self { x, y, width, height }\n    }\n\n    pub fn contains(&self, x: u16, y: u16) -> bool {\n        x >= self.x && x < self.x + self.width &&\n        y >= self.y && y < self.y + self.height\n    }\n\n    pub fn intersection(&self, other: &Self) -> Self {\n        let x = self.x.max(other.x);\n        let y = self.y.max(other.y);\n        let right = (self.x + self.width).min(other.x + other.width);\n        let bottom = (self.y + self.height).min(other.y + other.height);\n\n        if right > x && bottom > y {\n            Self::new(x, y, right - x, bottom - y)\n        } else {\n            Self::default()  // Empty rect\n        }\n    }\n\n    pub fn inner(&self, margin: Sides) -> Self {\n        Self::new(\n            self.x + margin.left,\n            self.y + margin.top,\n            self.width.saturating_sub(margin.left + margin.right),\n            self.height.saturating_sub(margin.top + margin.bottom),\n        )\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.width == 0 || self.height == 0\n    }\n\n    pub fn area(&self) -> u32 {\n        self.width as u32 * self.height as u32\n    }\n}\n\n## Sides (Padding/Margin)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub struct Sides {\n    pub top: u16,\n    pub right: u16,\n    pub bottom: u16,\n    pub left: u16,\n}\n\nimpl Sides {\n    pub fn all(v: u16) -> Self {\n        Self { top: v, right: v, bottom: v, left: v }\n    }\n\n    pub fn horizontal(v: u16) -> Self {\n        Self { top: 0, right: v, bottom: 0, left: v }\n    }\n\n    pub fn vertical(v: u16) -> Self {\n        Self { top: v, right: 0, bottom: v, left: 0 }\n    }\n\n    pub fn horizontal_sum(&self) -> u16 {\n        self.left + self.right\n    }\n\n    pub fn vertical_sum(&self) -> u16 {\n        self.top + self.bottom\n    }\n}\n\n// CSS-like tuple conversions\nimpl From<u16> for Sides {\n    fn from(v: u16) -> Self { Self::all(v) }\n}\n\nimpl From<(u16, u16)> for Sides {\n    fn from((v, h): (u16, u16)) -> Self {\n        Self { top: v, right: h, bottom: v, left: h }\n    }\n}\n\nimpl From<(u16, u16, u16, u16)> for Sides {\n    fn from((t, r, b, l): (u16, u16, u16, u16)) -> Self {\n        Self { top: t, right: r, bottom: b, left: l }\n    }\n}\n\n## Measurement (for layout negotiation)\n#[derive(Debug, Clone, Copy, Default)]\npub struct Measurement {\n    pub min_width: u16,\n    pub min_height: u16,\n    pub max_width: Option<u16>,\n    pub max_height: Option<u16>,\n}\n\nimpl Measurement {\n    pub fn fixed(width: u16, height: u16) -> Self {\n        Self {\n            min_width: width,\n            min_height: height,\n            max_width: Some(width),\n            max_height: Some(height),\n        }\n    }\n\n    pub fn flexible(min_w: u16, min_h: u16) -> Self {\n        Self {\n            min_width: min_w,\n            min_height: min_h,\n            max_width: None,\n            max_height: None,\n        }\n    }\n}\n\n## Tests Required\n- [ ] Rect::contains for corners and edges\n- [ ] Rect::intersection produces correct result\n- [ ] Rect::intersection with no overlap returns empty\n- [ ] Rect::inner reduces correctly\n- [ ] Sides::all, horizontal, vertical\n- [ ] Sides tuple conversions\n- [ ] Measurement::fixed constraints\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Ergonomic tuple conversions work","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:13:17.121141650Z","created_by":"ubuntu","updated_at":"2026-01-31T22:13:17.121141650Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.3.7","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:13:17.121141650Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4","title":"Phase 2: Diff + Presenter (Near-minimal ANSI)","description":"# Phase 2: Diff + Presenter (Near-minimal ANSI)\n\n## Purpose\nImplement the diff engine and ANSI presenter that transform buffer changes into minimal terminal output. This is where the 'zero-flicker' promise is delivered.\n\n## Components\n\n### BufferDiff\n- Compute diff between old and new buffers\n- Row-major scan for cache efficiency\n- Output as list of changed positions\n- Convert to ChangeRuns for efficient emission\n\n### ChangeRun\n- Contiguous run of changed cells on a single row\n- Allows single cursor move per run instead of per-cell\n\n### Presenter (State-Tracked ANSI Writer)\n- Tracks current style, link, cursor position\n- Only emits changes from tracked state\n- Uses BufWriter with 64KB buffer\n- Supports synchronized output (DEC mode 2026)\n\n## Key Decisions (from ADRs)\n\n### Style Emission Strategy\n- v1 default: Reset+apply (SGR 0 then re-apply)\n- Simple and correct, though more bytes\n- Incremental/hybrid behind feature flag until benchmarks justify\n\n### Synchronized Output\n- Use CSI ? 2026 h/l when available\n- Reduces flicker by batching updates\n- Must work without it (graceful degradation)\n\n### Run Grouping\n- Emit changes in row-major runs\n- Single cursor move per run\n- Sequential character emission within runs (cursor advances naturally)\n\n## Exit Criteria\n- Single buffered write per frame achieved\n- Run grouping works correctly\n- Style state cannot leak across runs (terminal-model tests)\n- Links (OSC 8) cannot remain open after present/exit\n\n## Success Criteria\n- [ ] BufferDiff is correct and fast (row-major; scratch reuse; property tests where possible).\n- [ ] Presenter emits correct ANSI (terminal-model validated) and never leaves dangling state (SGR/link).\n- [ ] Bytes emitted for small changes are O(changes), not O(screen), and are tracked in benches.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:21.404504792Z","created_by":"ubuntu","updated_at":"2026-01-31T23:25:54.992729685Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:21.404504792Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T22:21:20.799655478Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.1","title":"Implement BufferDiff with row-major scan","description":"# Implement BufferDiff with row-major scan\n\n## Objective\nImplement the diff engine that computes changed cells between two buffers efficiently.\n\n## Why Diffing Matters\nThe fundamental theorem of terminal UI: produce the minimal byte stream to transform current grid to desired grid. Diffing identifies what actually changed so we don't re-emit unchanged cells.\n\n## Technical Design\n\n### Structure\npub struct BufferDiff {\n    changes: Vec<(u16, u16)>,  // (x, y) of changed cells\n}\n\n### Algorithm\nRow-major scan for cache efficiency:\n1. Iterate y from 0 to height\n2. Iterate x from 0 to width\n3. Compare old[x,y] with new[x,y] using bits_eq\n4. Record position if different\n\nRow-major ensures sequential memory access:\n- Cells are stored row-by-row\n- Prefetcher can anticipate next access\n- 4 cells per cache line means 4 comparisons per line load\n\n### Implementation\nimpl BufferDiff {\n    pub fn compute(old: &Buffer, new: &Buffer) -> Self {\n        debug_assert_eq!(old.width(), new.width());\n        debug_assert_eq!(old.height(), new.height());\n\n        let mut changes = Vec::new();\n        let width = old.width();\n        let height = old.height();\n\n        // Row-major scan for cache efficiency\n        for y in 0..height {\n            for x in 0..width {\n                let old_cell = old.get_unchecked(x, y);\n                let new_cell = new.get_unchecked(x, y);\n                if !old_cell.bits_eq(new_cell) {\n                    changes.push((x, y));\n                }\n            }\n        }\n\n        Self { changes }\n    }\n\n    pub fn len(&self) -> usize {\n        self.changes.len()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.changes.is_empty()\n    }\n\n    pub fn changes(&self) -> &[(u16, u16)] {\n        &self.changes\n    }\n}\n\n### ChangeRun (for efficient emission)\nConvert point changes into contiguous runs:\n\npub struct ChangeRun {\n    pub y: u16,    // Row\n    pub x0: u16,   // Start column\n    pub x1: u16,   // End column (inclusive)\n}\n\nimpl BufferDiff {\n    pub fn runs(&self, _width: u16) -> Vec<ChangeRun> {\n        // Sort by (y, x) - already sorted from scan\n        // Coalesce consecutive x positions on same row\n\n        let mut runs = Vec::new();\n        if self.changes.is_empty() { return runs; }\n\n        let mut sorted = self.changes.clone();\n        sorted.sort_by_key(|(x, y)| (*y, *x));\n\n        let mut i = 0;\n        while i < sorted.len() {\n            let (x0, y) = sorted[i];\n            let mut x1 = x0;\n            i += 1;\n\n            // Coalesce consecutive x\n            while i < sorted.len() {\n                let (x, yy) = sorted[i];\n                if yy != y || x != x1 + 1 { break; }\n                x1 = x;\n                i += 1;\n            }\n\n            runs.push(ChangeRun { y, x0, x1 });\n        }\n\n        runs\n    }\n}\n\n## Performance Target\n- 80x24, full diff: < 500us\n- Typical 5% change: proportionally faster\n\n## Tests Required\n- [ ] Empty diff when buffers identical\n- [ ] Single cell change detected\n- [ ] Multiple scattered changes detected\n- [ ] runs() coalesces adjacent cells\n- [ ] runs() handles gaps correctly\n- [ ] Performance meets target\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] No unsafe code in default build\n- [ ] Performance: < 500us for 80x24","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:13:35.587846708Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:59.480036868Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.1","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:21:59.480007032Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.1","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:13:35.587846708Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.2","title":"Implement LinkRegistry for OSC 8 hyperlinks","description":"# Implement LinkRegistry for OSC 8 hyperlinks\n\n## Objective\nImplement URL storage and ID management for OSC 8 hyperlinks.\n\n## Background: OSC 8 Hyperlinks\nModern terminals support clickable hyperlinks via OSC 8:\n- Start link: ESC ] 8 ; ; URL ESC \\\\\n- End link: ESC ] 8 ; ; ESC \\\\\n\nMultiple cells can share the same link by using the same link ID. The registry deduplicates URLs and manages IDs.\n\n## Technical Design\n\n### Structure\npub struct LinkRegistry {\n    links: Vec<Option<String>>,      // ID -> URL mapping\n    lookup: HashMap<String, u32>,    // URL -> ID for dedup\n    free_list: Vec<u32>,            // Reusable IDs\n}\n\n### Implementation\nimpl LinkRegistry {\n    pub fn new() -> Self {\n        Self {\n            links: Vec::new(),\n            lookup: HashMap::new(),\n            free_list: Vec::new(),\n        }\n    }\n\n    /// Register a URL, returning existing ID if present\n    pub fn register(&mut self, url: &str) -> u32 {\n        // Check for existing\n        if let Some(&id) = self.lookup.get(url) {\n            return id;\n        }\n\n        // Allocate new ID\n        let id = self.free_list.pop().unwrap_or_else(|| {\n            let idx = self.links.len() as u32;\n            self.links.push(None);\n            idx\n        });\n\n        self.links[id as usize] = Some(url.to_string());\n        self.lookup.insert(url.to_string(), id);\n        id\n    }\n\n    /// Get URL for ID\n    pub fn get(&self, id: u32) -> Option<&str> {\n        self.links.get(id as usize)\n            .and_then(|slot| slot.as_ref())\n            .map(|s| s.as_str())\n    }\n\n    /// Unregister a link (for cleanup)\n    pub fn unregister(&mut self, id: u32) {\n        if let Some(Some(url)) = self.links.get(id as usize).cloned() {\n            self.lookup.remove(&url);\n            self.links[id as usize] = None;\n            self.free_list.push(id);\n        }\n    }\n\n    /// Check if ID is valid\n    pub fn contains(&self, id: u32) -> bool {\n        self.links.get(id as usize)\n            .map(|slot| slot.is_some())\n            .unwrap_or(false)\n    }\n\n    pub fn len(&self) -> usize {\n        self.links.iter().filter(|l| l.is_some()).count()\n    }\n}\n\n## Link Lifecycle in Rendering\n1. When drawing a cell with a link:\n   - Register URL with registry\n   - Store link_id in CellAttrs\n\n2. When presenting:\n   - Check if link_id changed from tracked state\n   - If changed, emit OSC 8 open/close sequences\n\n3. After frame:\n   - Links not used can be unregistered (optional GC)\n\n## Tests Required\n- [ ] register() returns same ID for same URL\n- [ ] register() returns different IDs for different URLs\n- [ ] get() retrieves correct URL\n- [ ] unregister() frees slot\n- [ ] Free list reuses IDs\n- [ ] contains() correct for valid/invalid IDs\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] No unsafe code\n- [ ] Deduplication works correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:13:53.031307640Z","created_by":"ubuntu","updated_at":"2026-01-31T22:21:59.746043980Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.2","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T22:21:59.746016368Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.2","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:13:53.031307640Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.3","title":"Implement Presenter with state-tracked ANSI emission","description":"# Implement Presenter with state-tracked ANSI emission\n\n## Objective\nImplement the core ANSI emitter that transforms buffer diffs into terminal output with minimal bytes.\n\n## Technical Design\n\n### State Tracking\nTrack current terminal state to avoid redundant sequences:\n- current_style: Option<CellStyle> (fg, bg, attrs)\n- current_link: Option<u32> (link ID)\n- cursor_x, cursor_y: u16 (cursor position)\n\n### Structure\npub struct Presenter<W: Write> {\n    writer: BufWriter<W>,    // 64KB buffer\n    current_style: Option<CellStyle>,\n    current_link: Option<u32>,\n    cursor_x: u16,\n    cursor_y: u16,\n    capabilities: TerminalCapabilities,\n}\n\n#[derive(Clone, Copy, PartialEq, Eq)]\nstruct CellStyle {\n    fg: PackedRgba,\n    bg: PackedRgba,\n    attrs: StyleFlags,\n}\n\n### Implementation\n\nimpl<W: Write> Presenter<W> {\n    pub fn new(writer: W, capabilities: TerminalCapabilities) -> Self {\n        Self {\n            writer: BufWriter::with_capacity(64 * 1024, writer),\n            current_style: None,\n            current_link: None,\n            cursor_x: 0,\n            cursor_y: 0,\n            capabilities,\n        }\n    }\n\n    /// Present a frame using diff\n    pub fn present(\n        &mut self,\n        buffer: &Buffer,\n        diff: &BufferDiff,\n        pool: &GraphemePool,\n        links: &LinkRegistry,\n    ) -> io::Result<()> {\n        // Begin synchronized output\n        if self.capabilities.sync_output {\n            self.writer.write_all(b\"\\x1b[?2026h\")?;\n        }\n\n        // Emit diff using run grouping\n        self.emit_diff(buffer, diff, pool, links)?;\n\n        // Reset style at end (clean state)\n        self.writer.write_all(b\"\\x1b[0m\")?;\n        self.current_style = None;\n\n        // Close any open link\n        if self.current_link.is_some() {\n            self.writer.write_all(b\"\\x1b]8;;\\x1b\\\\\")?;\n            self.current_link = None;\n        }\n\n        // End synchronized output\n        if self.capabilities.sync_output {\n            self.writer.write_all(b\"\\x1b[?2026l\")?;\n        }\n\n        self.writer.flush()\n    }\n\n    fn emit_diff(...) -> io::Result<()> {\n        for run in diff.runs(buffer.width()) {\n            // Single cursor move per run\n            self.move_cursor_to(run.x0, run.y)?;\n\n            // Emit cells (cursor advances naturally)\n            for x in run.x0..=run.x1 {\n                let cell = buffer.get_unchecked(x, run.y);\n                self.emit_cell(cell, pool, links)?;\n            }\n        }\n        Ok(())\n    }\n\n    fn emit_cell(...) -> io::Result<()> {\n        if cell.is_continuation() { return Ok(()); }\n\n        self.emit_style_changes(cell)?;\n        self.emit_link_changes(cell, links)?;\n        self.emit_content(cell, pool)?;\n\n        self.cursor_x += cell.width() as u16;\n        Ok(())\n    }\n\n    fn emit_style_changes(&mut self, cell: &Cell) -> io::Result<()> {\n        // v1: Reset+apply strategy (per ADR-002)\n        // Emit SGR 0 then apply all attributes\n        // Optimization: skip if style unchanged\n    }\n\n    fn emit_link_changes(&mut self, cell: &Cell, registry: &LinkRegistry) -> io::Result<()> {\n        // Open/close OSC 8 links as needed\n    }\n\n    fn emit_content(&mut self, cell: &Cell, pool: &GraphemePool) -> io::Result<()> {\n        // Emit char or grapheme from pool\n    }\n\n    fn move_cursor_to(&mut self, x: u16, y: u16) -> io::Result<()> {\n        if self.cursor_x == x && self.cursor_y == y { return Ok(()); }\n        write!(self.writer, \"\\x1b[{};{}H\", y + 1, x + 1)?;\n        self.cursor_x = x;\n        self.cursor_y = y;\n        Ok(())\n    }\n}\n\n## ANSI Sequences Reference\n- Cursor position: CSI row ; col H (1-indexed)\n- SGR reset: CSI 0 m\n- SGR attributes: CSI n ; n ; ... m\n- True color fg: CSI 38 ; 2 ; r ; g ; b m\n- True color bg: CSI 48 ; 2 ; r ; g ; b m\n- OSC 8 open: OSC 8 ; ; url ST\n- OSC 8 close: OSC 8 ; ; ST\n- Sync begin: CSI ? 2026 h\n- Sync end: CSI ? 2026 l\n\n## Tests Required\n- [ ] present() produces valid ANSI\n- [ ] Style tracking avoids redundant SGR\n- [ ] Link tracking opens/closes correctly\n- [ ] Cursor moves are minimized via runs\n- [ ] Empty diff produces no cell output\n- [ ] Sync output wrapped when supported\n\n## Acceptance Criteria\n- [ ] Terminal-model tests pass\n- [ ] PTY tests show correct output\n- [ ] Single write per frame (buffered)\n- [ ] No style/link leaks after present","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:14:16.508100183Z","created_by":"ubuntu","updated_at":"2026-02-01T00:24:18.929987975Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.3","depends_on_id":"bd-10i.2.5","type":"blocks","created_at":"2026-01-31T22:22:00.259710385Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.3","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:14:16.508100183Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.3","depends_on_id":"bd-10i.4.1","type":"blocks","created_at":"2026-01-31T22:21:59.992602219Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.3","depends_on_id":"bd-3ky.1","type":"blocks","created_at":"2026-02-01T00:24:18.929949984Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.4.4","title":"Implement TerminalCapabilities detection","description":"# Implement TerminalCapabilities detection\n\n## Objective\nImplement environment-based capability detection for adapting to different terminals.\n\n## Detection Logic Summary\n\n### Color Support\ntrue_color = \\!NO_COLOR && (\n    COLORTERM in [truecolor, 24bit] ||\n    TERM contains [kitty, wezterm, alacritty, ghostty] ||\n    TERM_PROGRAM in [iTerm.app, WezTerm, Alacritty, Ghostty]\n)\n\ncolors_256 = true_color || TERM contains 256color\n\n### Synchronized Output (DEC 2026)\nsync_output = TERM_PROGRAM in [WezTerm, Alacritty, Ghostty] ||\n              TERM contains kitty ||\n              KITTY_WINDOW_ID set\n\n### OSC 8 Hyperlinks\nosc8_hyperlinks = \\!NO_COLOR && (\n    TERM_PROGRAM in [iTerm.app, WezTerm, Ghostty] ||\n    TERM contains kitty\n)\n\n### Multiplexer Detection\nin_tmux = TMUX env var set\nin_screen = STY env var set\nin_zellij = ZELLIJ env var set\n\n### Input Features\nkitty_keyboard = TERM contains kitty || KITTY_WINDOW_ID set\nfocus_events = true (widely supported)\nbracketed_paste = true (widely supported)\nmouse_sgr = true (widely supported)\n\n### Scroll Region (DECSTBM)\nscroll_region = TERM \\!= dumb\n\n### OSC 52 Clipboard\nosc52_clipboard = \\!in_any_mux && TERM \\!= dumb\n(Security restricted in mux environments)\n\n## Environment Variables Used\n- NO_COLOR: Disable color (de-facto standard)\n- COLORTERM: Color capability hint\n- TERM: Terminal type\n- TERM_PROGRAM: Terminal application name\n- TMUX: tmux socket path (indicates tmux)\n- STY: screen session name (indicates screen)\n- ZELLIJ: Zellij session\n- KITTY_WINDOW_ID: Kitty window identifier\n\n## Implementation\nimpl TerminalCapabilities {\n    pub fn detect() -> Self {\n        let no_color = std::env::var('NO_COLOR').is_ok();\n        let colorterm = std::env::var('COLORTERM').unwrap_or_default();\n        let term = std::env::var('TERM').unwrap_or_default();\n        let term_program = std::env::var('TERM_PROGRAM').unwrap_or_default();\n\n        let in_tmux = std::env::var('TMUX').is_ok();\n        let in_screen = std::env::var('STY').is_ok();\n        let in_zellij = std::env::var('ZELLIJ').is_ok();\n\n        // ... detection logic ...\n\n        Self { ... }\n    }\n\n    pub fn basic() -> Self {\n        // Minimal fallback: no advanced features\n    }\n\n    pub fn in_any_mux(&self) -> bool {\n        self.in_tmux || self.in_screen || self.in_zellij\n    }\n}\n\n## Tests Required\n- [ ] NO_COLOR disables color features\n- [ ] COLORTERM=truecolor enables true_color\n- [ ] Known terminals detected correctly\n- [ ] Multiplexer detection works\n- [ ] basic() returns conservative defaults\n\n## Acceptance Criteria\n- [ ] All common terminals detected correctly\n- [ ] Conservative fallbacks for unknown\n- [ ] Tests cover major scenarios","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:14:35.007795448Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:00.519638003Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.4.4","depends_on_id":"bd-10i.2.5","type":"blocks","created_at":"2026-01-31T22:22:00.519607715Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.4.4","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:14:35.007795448Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.5","title":"Phase 3: Input System","description":"# Phase 3: Input System\n\n## Purpose\nImplement robust input parsing that handles terminal input sequences while protecting against DoS attacks.\n\n## Event Types\n- Key(KeyEvent): code, modifiers, kind (Press/Repeat/Release)\n- Mouse(MouseEvent): kind, x, y, modifiers\n- Resize { width, height }\n- Paste(PasteEvent): text, bracketed flag\n- Focus(bool): gained/lost\n\n## Parser State Machine\nStates: Ground, Escape, Csi, CsiParam, Osc, Dcs, Ss3\n\n### DoS Protection (CRITICAL)\n- max_csi_len: 256 bytes (prevents CSI bomb)\n- max_osc_len: 4096 bytes\n- max_dcs_len: 4096 bytes\n- max_paste_len: 1MB (configurable)\n- Parser must remain linear time for worst-case inputs\n- No panics on malformed sequences\n\n## Protocols to Support\n1. Standard ASCII + UTF-8\n2. CSI sequences (arrows, function keys, modifiers)\n3. SS3 sequences (alternate function keys)\n4. SGR mouse protocol (1006) for precise coordinates\n5. Bracketed paste mode (200~/201~)\n6. Focus events (CSI I / CSI O)\n7. Optional: Kitty keyboard protocol (feature-gated)\n\n## Event Coalescing (Recommended)\n- Mouse move: keep latest position per frame\n- Resize: keep latest size per tick\n- Key repeat: optionally surface KeyEventKind::Repeat if kitty protocol enabled\n\n## Exit Criteria\n- Parser passes fuzzing with random byte streams\n- Deterministic tests for all key/mouse/paste/resize sequences\n- Hard bounds on sequence lengths enforced\n- No panics on any input\n\n## Success Criteria\n- [ ] All supported protocols decode into canonical Events (lossless for supported sequences).\n- [ ] Hard caps prevent unbounded memory/time (DoS resistance).\n- [ ] Fuzzing runs continuously in CI (or as a separate job) and remains green.\n- [ ] PTY tests prove bracketed paste/mouse/focus modes are enabled/disabled correctly via RAII.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:35.653437996Z","created_by":"ubuntu","updated_at":"2026-01-31T23:26:13.403429268Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.5","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:35.653437996Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.5","depends_on_id":"bd-10i.4","type":"blocks","created_at":"2026-01-31T22:21:21.059758726Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.5.1","title":"Implement InputParser state machine","description":"# Implement InputParser state machine\n\n## Objective\nImplement robust terminal input parsing with DoS protection.\n\n## Parser States\nenum ParserState {\n    Ground,    // Normal character input\n    Escape,    // After ESC\n    Csi,       // After ESC [\n    CsiParam,  // Collecting CSI parameters\n    Osc,       // After ESC ]\n    Dcs,       // After ESC P\n    Ss3,       // After ESC O\n}\n\n## Transitions\nGround:\n  ESC (0x1B) -> Escape\n  0x00 -> Key(Null, Ctrl)\n  0x01-0x1A -> Key(Ctrl+A..Z)\n  0x7F -> Key(Backspace)\n  0x80+ -> UTF-8 sequence\n  other -> Key(Char)\n\nEscape:\n  [ -> Csi\n  O -> Ss3\n  ] -> Osc\n  P -> Dcs\n  other -> Key(Alt+char) + Ground\n\nCsi:\n  0-9;:<=>? -> CsiParam\n  A-Za-z~ -> parse + Ground\n\nCsiParam:\n  0-9;: -> stay\n  A-Za-z~Mm -> parse + Ground\n\nSs3:\n  A-S -> function key + Ground\n\nOsc:\n  BEL (0x07) -> complete + Ground\n  ESC \\\\ -> complete + Ground\n\n## DoS Protection Limits\nconst MAX_CSI_LEN: usize = 256;   // Prevent CSI bomb\nconst MAX_OSC_LEN: usize = 4096;\nconst MAX_DCS_LEN: usize = 4096;\nconst MAX_PASTE_LEN: usize = 1024 * 1024;  // 1MB\n\nIf limit exceeded: abandon sequence, return to Ground.\n\n## Special Sequences\n\n### Bracketed Paste\nCSI 200 ~ -> start paste mode\nCSI 201 ~ -> end paste mode, emit Paste event\n\n### Focus Events\nCSI I -> Focus(true)\nCSI O -> Focus(false)\n\n### SGR Mouse (1006)\nCSI < params M -> mouse down\nCSI < params m -> mouse up\nparams: button ; x ; y\n\n### Arrow Keys\nCSI A -> Up\nCSI B -> Down\nCSI C -> Right\nCSI D -> Left\n\n### Function Keys\nSs3 P -> F1\nSs3 Q -> F2\netc.\n\nCSI 15 ~ -> F5\nCSI 17 ~ -> F6\netc.\n\n## Implementation\npub struct InputParser {\n    state: ParserState,\n    buffer: Vec<u8>,\n    paste_buffer: Vec<u8>,\n    in_paste: bool,\n    // Limits\n    max_csi_len: usize,\n    max_osc_len: usize,\n    max_paste_len: usize,\n}\n\nimpl InputParser {\n    pub fn new() -> Self { ... }\n\n    pub fn parse(&mut self, input: &[u8]) -> Vec<Event> {\n        let mut events = Vec::new();\n        for &byte in input {\n            if let Some(event) = self.process_byte(byte) {\n                events.push(event);\n            }\n        }\n        events\n    }\n}\n\n## Tests Required\n- [ ] ASCII characters parsed correctly\n- [ ] Arrow keys produce correct events\n- [ ] Function keys F1-F12\n- [ ] Modifiers (Ctrl, Alt, Shift)\n- [ ] Mouse events decoded correctly\n- [ ] Bracketed paste collected\n- [ ] Focus events detected\n- [ ] DoS limits enforced\n- [ ] Invalid sequences don't panic\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Fuzz testing passes\n- [ ] No panics on any input\n- [ ] Linear time complexity","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:14:55.632491690Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:05.373599141Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.5.1","depends_on_id":"bd-10i.2.4","type":"blocks","created_at":"2026-01-31T22:22:05.373564095Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.5.1","depends_on_id":"bd-10i.5","type":"parent-child","created_at":"2026-01-31T22:14:55.632491690Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.6","title":"Phase 4: Styling (Split Responsibilities)","description":"# Phase 4: Styling (Split Responsibilities)\n\n## Purpose\nImplement a style system that separates concerns: renderer-facing CellStyle is tiny and fast, while higher-level style (theme/semantic colors) resolves into CellStyle before drawing.\n\n## Architecture Decision\nStyle is split by responsibility:\n- CellStyle: tiny, renderer-facing (packed fg/bg/attrs/link-id)\n- FullStyle: higher-level with all properties + explicit tracking via bitflags\n- Theme: semantic color slots + presets\n\n## Components\n\n### StyleFlags (8 bits)\nBOLD, DIM, ITALIC, UNDERLINE, BLINK, REVERSE, STRIKETHROUGH, HIDDEN\n\n### Props Bitflags (explicit property tracking)\nTracks which properties are explicitly set for proper inheritance.\nUnset properties inherit from parent style.\n\n### Color System\n- AdaptiveColor: can resolve differently for light/dark themes\n- ColorProfile detection: Ascii, Ansi (16), Ansi256 (256), TrueColor (24-bit)\n- Color downgrade: TrueColor -> 256 -> 16 -> ASCII\n- NO_COLOR environment variable respected\n\n### Border System\n- Presets: Rounded, Square, Double, Heavy, Ascii, Hidden\n- Custom borders supported\n- All corner and edge characters defined\n\n### Markup Parser (Optional Layer)\n- Regex-based parser for Rich-style markup: [bold red]text[/]\n- Escape sequences: \\[ becomes literal [\n- Style stack for proper nesting\n- Feature-gated, not part of kernel\n\n## Exit Criteria\n- Deterministic style merge with explicit masks\n- Theme resolution documented and tested\n- Markup parsing correct under tests (feature-gated)\n- Color downgrade works for all profile levels\n\n## Success Criteria\n- [ ] Style merge semantics are deterministic and documented (no hidden precedence).\n- [ ] Color downgrade is correct and tested across profiles.\n- [ ] Border presets are defined and used consistently by widgets.\n- [ ] Markup parsing is optional and cannot destabilize the kernel.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T22:05:49.668320221Z","created_by":"ubuntu","updated_at":"2026-01-31T23:26:30.002720740Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.6","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:05:49.668320221Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.6","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T22:21:21.317323021Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.7","title":"Phase 5: Layout + Components (Widgets Ring)","description":"# Phase 5: Layout + Components (Widgets Ring)\n\n## Purpose\nImplement the widget layer that builds on kernel primitives. Widgets are ring-2 concepts - they depend on the kernel but the kernel does not depend on them.\n\n## Renderable Trait\nThe core abstraction for components:\n- measure(&self, ctx: &RenderContext) -> Measurement / TextMeasurement\n- render(&self, ctx: &RenderContext, rect: Rect, buffer: &mut Buffer)\n\n## Measurement Protocol\n- minimum: tightest compression width\n- maximum: ideal unconstrained width\n- union(): for side-by-side layout (max of both)\n- stack(): for vertical stacking (sum of both)\n\n## v1 Essential Widgets (Agent Harness Needs)\n\n### Viewport / Log Viewer\n- Scrollable text area for streaming logs\n- Essential for agent harness UIs\n\n### Panel\n- Bordered container with optional title\n- Border presets: Rounded, Square, Double, Heavy, Ascii, Hidden\n- Title alignment: Left, Center, Right\n\n### Spinner\n- Animated progress indicator\n- Styles: Dots, Line, Braille, Bounce, Custom\n- Frame advancement via tick()\n\n### Progress Bar\n- Value 0.0-1.0 with optional percentage display\n- Customizable filled/empty characters and colors\n\n### Text Input / Prompt\n- Single-line editable text field\n- Cursor management (selection/history can be future)\n\n### Status Line\n- Fixed-position information display\n- For tool indicators, status messages\n\n## Hit Testing (Optional)\nHitGrid for mouse affordances - maps screen positions to interactive elements.\n\n## Exit Criteria\n- Snapshot tests for all widgets across themes and sizes\n- Hit testing works where applicable\n- Widgets compose correctly via Renderable trait\n\n## Success Criteria\n- [ ] Harness-essential widgets exist and are tested (unit + snapshot + PTY where needed).\n- [ ] Widgets build only on kernel primitives (no hidden writes; no kernel deps on widgets).\n- [ ] Layout/measurement behavior is deterministic and documented.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T22:06:02.781831931Z","created_by":"ubuntu","updated_at":"2026-01-31T23:26:47.242701721Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.7","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:02.781831931Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.7","depends_on_id":"bd-10i.5","type":"blocks","created_at":"2026-01-31T22:21:21.822401345Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.7","depends_on_id":"bd-10i.6","type":"blocks","created_at":"2026-01-31T22:21:21.560738568Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8","title":"Phase 6: Runtime + Agent Harness Reference App","description":"# Phase 6: Runtime + Agent Harness Reference App\n\n## Purpose\nImplement the optional-but-recommended Bubbletea/Elm-style runtime and build a reference agent harness app that proves the architecture works for its primary use case.\n\n## Runtime Model (Bubbletea/Elm Lineage)\n\n### Model Trait\n- init() -> Cmd: initialization commands\n- update(msg) -> Cmd: state transitions\n- view(&self, frame: &mut Frame): render current state\n\n### Cmd Enum\n- None: no-op\n- Quit: exit application\n- Batch(Vec<Cmd>): parallel commands\n- Sequence(Vec<Cmd>): sequential commands\n- Msg(M): send message to self\n- Tick(Duration): schedule tick\n- Async integration (feature-gated): threadpool or tokio\n\n### Program Responsibilities\n- Own terminal lifecycle (raw mode, mouse, paste, focus, alt screen)\n- Poll input -> Event -> Message\n- Run update loop, schedule ticks/commands\n- Render frames only when dirty\n- Enforce screen mode policy (Inline/AltScreen)\n- FPS cap and frame coalescing\n\n## Deterministic Simulator (Stop regressions forever)\nProgramSimulator that:\n- Injects sequence of Events/Messages\n- Captures produced Frames\n- Enables snapshot tests for widgets and full apps\n- Runs without real terminal (no flakiness)\n\n## Agent Harness Reference App\nThe design forcing function - not 'just an example':\n- Inline scrollback log stream + UI region\n- Tool indicators, status line, input area\n- Streaming render updates\n- No flicker, no corruption\n- Survives resize\n- Exits cleanly on panic\n\n## What 'Agent-Ergonomic' Means in Practice\n- Hello world harness in <200 LOC\n- Tool output streaming is one function call\n- Pinned bottom UI is one config option\n- Temporary full-screen modal supported without rewriting app\n\n## Exit Criteria\n- Harness demo passes PTY tests\n- Inline mode stable under sustained output\n- Simulator enables deterministic testing\n\n## Success Criteria\n- [ ] Runtime enables the \"pit of success\" (easy inline harness with strong defaults).\n- [ ] One-writer routing is practical (LogSink + PTY capture paths exist).\n- [ ] Sanitization is enforced by default for untrusted output.\n- [ ] Simulator produces stable snapshots and prevents regressions.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T22:06:20.392811659Z","created_by":"ubuntu","updated_at":"2026-01-31T23:27:04.824958170Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:20.392811659Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8","depends_on_id":"bd-10i.7","type":"blocks","created_at":"2026-01-31T22:21:22.065119348Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.1","title":"Implement TerminalWriter with inline mode support","description":"# Implement TerminalWriter with inline mode support\n\n## Objective\nImplement the unified terminal output coordinator that enforces the one-writer rule and implements inline mode correctly.\n\n## Why TerminalWriter?\nThe TerminalWriter is the component that makes inline mode work. It:\n- Serializes log writes and UI presents\n- Implements the cursor save/restore contract\n- Manages scroll regions (when optimization enabled)\n- Ensures single buffered write per operation\n\n## Architecture\npub struct TerminalWriter<W: Write> {\n    session: TerminalSession<W>,\n    presenter: Presenter<W>,\n    screen_mode: ScreenMode,\n    ui_anchor: UiAnchor,\n    prev_buffer: Buffer,\n    pool: GraphemePool,\n    links: LinkRegistry,\n}\n\npub enum ScreenMode {\n    Inline { ui_height: u16 },\n    AltScreen,\n}\n\npub enum UiAnchor {\n    Bottom,  // Default for agent harness\n    Top,\n}\n\n## Inline Mode Present Sequence (Overlay Redraw)\n\npub fn present_ui(&mut self, buffer: &Buffer) -> io::Result<()> {\n    if let ScreenMode::Inline { ui_height } = self.screen_mode {\n        // 1. Begin sync output if available\n        if self.session.capabilities().sync_output {\n            write!(self.writer, '\\x1b[?2026h')?;\n        }\n\n        // 2. Save cursor (DEC or ANSI)\n        write!(self.writer, '\\x1b7')?;  // DEC save\n\n        // 3. Move to UI anchor\n        let (_, term_height) = self.terminal_size();\n        let ui_y = term_height - ui_height;\n        write!(self.writer, '\\x1b[{};1H', ui_y + 1)?;\n\n        // 4. Clear UI region only (not full screen!)\n        for _ in 0..ui_height {\n            write!(self.writer, '\\x1b[2K\\n')?;  // Clear line\n        }\n        write!(self.writer, '\\x1b[{};1H', ui_y + 1)?;  // Back to anchor\n\n        // 5. Present diffed UI\n        let diff = BufferDiff::compute(&self.prev_buffer, buffer);\n        self.presenter.present(buffer, &diff, &self.pool, &self.links)?;\n\n        // 6. Restore cursor\n        write!(self.writer, '\\x1b8')?;  // DEC restore\n\n        // 7. End sync output\n        if self.session.capabilities().sync_output {\n            write!(self.writer, '\\x1b[?2026l')?;\n        }\n\n        self.writer.flush()?;\n        std::mem::swap(&mut self.prev_buffer, buffer);\n    }\n    Ok(())\n}\n\n## Log Writing (Inline Mode)\npub fn write_log(&mut self, text: &str) -> io::Result<()> {\n    if let ScreenMode::Inline { .. } = self.screen_mode {\n        // Log writes go to scrollback region (above UI)\n        // Just write normally - terminal scrolls\n        // The next present_ui will redraw UI in correct position\n        self.writer.write_all(text.as_bytes())?;\n        self.writer.flush()\n    } else {\n        // AltScreen: no scrollback, might need different handling\n        Ok(())\n    }\n}\n\n## Scroll Region Optimization (Optional)\nWhen capabilities.scroll_region and policy allows:\n- Set DECSTBM to constrain scrolling\n- Log writes stay in scroll region\n- UI stays pinned outside scroll region\n- Must restore on exit\n\n## Tests Required\n- [ ] present_ui doesn't corrupt scrollback\n- [ ] Cursor restored to correct position\n- [ ] Multiple present/log cycles stable\n- [ ] Resize handled correctly\n- [ ] PTY tests verify behavior\n\n## Acceptance Criteria\n- [ ] Inline mode works without flicker\n- [ ] PTY tests pass\n- [ ] Cursor contract enforced\n- [ ] No scrollback corruption","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:16:09.208130189Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:26.927218289Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.1","depends_on_id":"bd-10i.10.1","type":"blocks","created_at":"2026-01-31T22:22:26.927181830Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.1","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T22:22:26.665689264Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.1","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T22:16:09.208130189Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.2","title":"Implement Program/Model/Cmd runtime","description":"# Implement Program/Model/Cmd runtime\n\n## Objective\nImplement the Bubbletea/Elm-style runtime that manages the update/view loop.\n\n## Why This Runtime?\n- Separates state (Model) from rendering (View)\n- Makes apps testable via deterministic simulator\n- Handles event loop complexity\n- Provides command pattern for side effects\n\n## Core Trait\npub trait Model: Sized {\n    type Message: From<Event> + Send + 'static;\n\n    /// Initialize model, return startup commands\n    fn init(&mut self) -> Cmd<Self::Message> {\n        Cmd::none()\n    }\n\n    /// Handle message, return commands\n    fn update(&mut self, msg: Self::Message) -> Cmd<Self::Message>;\n\n    /// Render current state to frame\n    fn view(&self, frame: &mut Frame);\n}\n\n## Command Type\npub enum Cmd<M> {\n    None,\n    Quit,\n    Batch(Vec<Cmd<M>>),      // Parallel execution\n    Sequence(Vec<Cmd<M>>),   // Sequential execution\n    Msg(M),                  // Send message to self\n    Tick(Duration),          // Schedule tick\n    // Feature-gated async\n    #[cfg(feature = 'async')]\n    Async(BoxFuture<'static, M>),\n}\n\nimpl<M> Cmd<M> {\n    pub fn none() -> Self { Self::None }\n    pub fn quit() -> Self { Self::Quit }\n    pub fn msg(m: M) -> Self { Self::Msg(m) }\n    pub fn batch(cmds: Vec<Self>) -> Self { Self::Batch(cmds) }\n    pub fn tick(d: Duration) -> Self { Self::Tick(d) }\n}\n\n## Program (Runtime)\npub struct Program<M: Model> {\n    model: M,\n    writer: TerminalWriter<Stdout>,\n    input_parser: InputParser,\n    running: bool,\n    tick_rate: Option<Duration>,\n    last_tick: Instant,\n    dirty: bool,\n}\n\nimpl<M: Model> Program<M> {\n    pub fn new(model: M, screen_mode: ScreenMode) -> io::Result<Self> {\n        // Set up terminal\n        // Initialize writer\n        // Start input thread/poll\n    }\n\n    pub fn run(&mut self) -> io::Result<()> {\n        // Initialize\n        let cmd = self.model.init();\n        self.execute_cmd(cmd)?;\n\n        // Main loop\n        while self.running {\n            // Poll for input (with tick timeout)\n            if let Some(event) = self.poll_event()? {\n                let msg = M::Message::from(event);\n                let cmd = self.model.update(msg);\n                self.execute_cmd(cmd)?;\n                self.dirty = true;\n            }\n\n            // Tick handling\n            if self.should_tick() {\n                // Send tick message or just re-render\n                self.dirty = true;\n            }\n\n            // Render if dirty\n            if self.dirty {\n                let mut frame = self.new_frame();\n                self.model.view(&mut frame);\n                self.writer.present_ui(&frame.buffer)?;\n                self.dirty = false;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute_cmd(&mut self, cmd: Cmd<M::Message>) -> io::Result<()> {\n        match cmd {\n            Cmd::None => {}\n            Cmd::Quit => self.running = false,\n            Cmd::Msg(m) => {\n                let cmd = self.model.update(m);\n                self.execute_cmd(cmd)?;\n            }\n            Cmd::Batch(cmds) => {\n                for c in cmds {\n                    self.execute_cmd(c)?;\n                }\n            }\n            Cmd::Tick(d) => {\n                self.tick_rate = Some(d);\n            }\n            // ...\n        }\n        Ok(())\n    }\n}\n\n## App Builder (Ergonomic Entry Point)\npub struct App;\n\nimpl App {\n    pub fn new<M: Model>(model: M) -> AppBuilder<M> {\n        AppBuilder { model, screen_mode: ScreenMode::Inline { ui_height: 4 } }\n    }\n}\n\npub struct AppBuilder<M: Model> {\n    model: M,\n    screen_mode: ScreenMode,\n}\n\nimpl<M: Model> AppBuilder<M> {\n    pub fn screen_mode(mut self, mode: ScreenMode) -> Self {\n        self.screen_mode = mode;\n        self\n    }\n\n    pub fn run(self) -> Result<()> {\n        let mut program = Program::new(self.model, self.screen_mode)?;\n        program.run()?;\n        Ok(())\n    }\n}\n\n## Tests Required\n- [ ] Model::update called on events\n- [ ] Model::view called on dirty\n- [ ] Cmd::Quit stops loop\n- [ ] Cmd::Batch executes all\n- [ ] Tick scheduling works\n\n## Acceptance Criteria\n- [ ] Hello world app works\n- [ ] Deterministic when using simulator\n- [ ] Clean shutdown","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:16:30.741993686Z","created_by":"ubuntu","updated_at":"2026-01-31T23:13:17.213277522Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.2","depends_on_id":"bd-10i.2.6","type":"blocks","created_at":"2026-01-31T22:22:27.425356768Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.2","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T23:13:16.618229494Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.2","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T22:16:30.741993686Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.2","depends_on_id":"bd-10i.8.1","type":"blocks","created_at":"2026-01-31T23:13:16.002859148Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.2","depends_on_id":"bd-3cc","type":"blocks","created_at":"2026-01-31T23:13:17.213239651Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.3","title":"Implement ProgramSimulator for deterministic testing","description":"# Implement ProgramSimulator for deterministic testing\n\n## Objective\nCreate a simulator that runs Model logic deterministically without a real terminal.\n\n## Why Simulator?\n- Tests must be deterministic (no real terminal)\n- Snapshot tests for widgets and apps\n- Can inject arbitrary event sequences\n- No flakiness from timing/IO\n\n## Structure\npub struct ProgramSimulator<M: Model> {\n    model: M,\n    frames: Vec<Buffer>,\n    messages: Vec<M::Message>,\n    time: Instant,  // Simulated time\n}\n\nimpl<M: Model> ProgramSimulator<M> {\n    pub fn new(model: M) -> Self {\n        Self {\n            model,\n            frames: Vec::new(),\n            messages: Vec::new(),\n            time: Instant::now(),\n        }\n    }\n\n    /// Inject events and process\n    pub fn inject_events(&mut self, events: &[Event]) {\n        for event in events {\n            let msg = M::Message::from(event.clone());\n            self.messages.push(msg.clone());\n            let _cmd = self.model.update(msg);\n            // Note: Commands are captured but not executed\n            // (async/IO commands meaningless in simulation)\n        }\n    }\n\n    /// Send specific message\n    pub fn send(&mut self, msg: M::Message) {\n        self.messages.push(msg.clone());\n        let _cmd = self.model.update(msg);\n    }\n\n    /// Capture current frame\n    pub fn capture_frame(&mut self, width: u16, height: u16) -> &Buffer {\n        let mut frame = Frame {\n            buffer: Buffer::new(width, height),\n            hit_grid: None,\n            cursor_position: None,\n            cursor_visible: true,\n        };\n        self.model.view(&mut frame);\n        self.frames.push(frame.buffer);\n        self.frames.last().unwrap()\n    }\n\n    /// Get all captured frames\n    pub fn frames(&self) -> &[Buffer] {\n        &self.frames\n    }\n\n    /// Get message history\n    pub fn messages(&self) -> &[M::Message] {\n        &self.messages\n    }\n\n    /// Advance simulated time\n    pub fn advance_time(&mut self, duration: Duration) {\n        self.time += duration;\n    }\n\n    /// Get current model reference\n    pub fn model(&self) -> &M {\n        &self.model\n    }\n}\n\n## Snapshot Testing Pattern\n#[test]\nfn counter_snapshot() {\n    let mut sim = ProgramSimulator::new(Counter { value: 0 });\n\n    // Inject key press\n    sim.inject_events(&[Event::Key(KeyEvent {\n        code: KeyCode::Char('+'),\n        modifiers: Modifiers::empty(),\n    })]);\n\n    // Capture frame\n    let frame = sim.capture_frame(80, 24);\n\n    // Compare with golden snapshot\n    insta::assert_snapshot!(frame_to_string(frame));\n}\n\n## Widget Testing Pattern\n#[test]\nfn spinner_frames() {\n    let mut spinner = Spinner::new('Loading');\n    let ctx = RenderContext::test();\n    let mut frames = Vec::new();\n\n    for _ in 0..10 {\n        spinner.tick();\n        let mut buf = Buffer::new(20, 1);\n        spinner.render(&ctx, Rect::new(0, 0, 20, 1), &mut buf);\n        frames.push(buf);\n    }\n\n    // Verify animation frames differ\n    assert_ne!(frames[0], frames[1]);\n}\n\n## Tests Required\n- [ ] inject_events processes all\n- [ ] capture_frame renders correctly\n- [ ] Messages recorded in order\n- [ ] Works without terminal\n\n## Acceptance Criteria\n- [ ] Snapshot tests work\n- [ ] No IO dependencies\n- [ ] Deterministic results","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:16:48.395010451Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:27.666172346Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.3","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T22:16:48.395010451Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.3","depends_on_id":"bd-10i.8.2","type":"blocks","created_at":"2026-01-31T22:22:27.666141989Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.4","title":"Implement sanitize-by-default for untrusted output (ADR-006)","description":"# Implement sanitize-by-default for untrusted output (ADR-006)\n\n## Background\nNon-negotiable contract (Plan Section 0.1.1 + ADR-006): any untrusted bytes displayed as logs/tool output/LLM streams must be treated as **data**, not executed as terminal control sequences.\n\nThis is both a security requirement (prevent terminal escape attacks) and a correctness requirement (preserve cursor invariants).\n\n## Threat Model\nMalicious content in logs could:\n1. Manipulate cursor position (break inline mode)\n2. Change terminal colors/modes persistently\n3. Hide text or show fake prompts (social engineering)\n4. Trigger terminal queries that exfiltrate data\n5. Set window title to misleading values\n\n## Design: Fast-Path / Slow-Path\n\n**Fast Path (95%+ of cases)**\n- Scan for ESC byte (0x1B) using memchr\n- If no ESC found, content is safe - return borrowed slice\n- Zero allocation in common case\n\n**Slow Path (contains escape sequences)**\n- Allocate output buffer\n- Filter/strip control sequences\n- Return owned String\n\n```rust\nuse memchr::memchr;\n\n/// Sanitize untrusted text for safe terminal display\n/// \n/// # Fast Path\n/// If no ESC (0x1B) found, returns borrowed input (no allocation).\n/// \n/// # Slow Path\n/// Strips all escape sequences and returns owned String.\n/// \n/// # What Gets Stripped\n/// - ESC (0x1B) and all following CSI/OSC/DCS/APC sequences\n/// - C0 controls except: TAB (0x09), LF (0x0A), CR (0x0D)\npub fn sanitize<'a>(input: &'a str) -> Cow<'a, str> {\n    // Fast path: check for any ESC byte\n    if memchr(0x1B, input.as_bytes()).is_none() &&\n       !has_forbidden_c0(input.as_bytes()) {\n        return Cow::Borrowed(input);\n    }\n    \n    // Slow path: strip escape sequences\n    Cow::Owned(sanitize_slow(input))\n}\n\n#[inline]\nfn has_forbidden_c0(bytes: &[u8]) -> bool {\n    bytes.iter().any(|&b| match b {\n        0x00..=0x08 | 0x0B..=0x0C | 0x0E..=0x1A | 0x1C..=0x1F => true,\n        _ => false,\n    })\n}\n\nfn sanitize_slow(input: &str) -> String {\n    let mut output = String::with_capacity(input.len());\n    let bytes = input.as_bytes();\n    let mut i = 0;\n    \n    while i < bytes.len() {\n        let b = bytes[i];\n        match b {\n            // ESC - start of escape sequence\n            0x1B => {\n                i = skip_escape_sequence(bytes, i);\n            }\n            // Allowed C0 controls\n            0x09 | 0x0A | 0x0D => {\n                output.push(b as char);\n                i += 1;\n            }\n            // Forbidden C0 controls - skip\n            0x00..=0x08 | 0x0B..=0x0C | 0x0E..=0x1A | 0x1C..=0x1F => {\n                i += 1;\n            }\n            // Printable ASCII\n            0x20..=0x7E => {\n                output.push(b as char);\n                i += 1;\n            }\n            // Start of UTF-8 sequence\n            0x80.. => {\n                if let Some((c, len)) = decode_utf8(&bytes[i..]) {\n                    output.push(c);\n                    i += len;\n                } else {\n                    // Invalid UTF-8, skip byte\n                    i += 1;\n                }\n            }\n            _ => {\n                i += 1;\n            }\n        }\n    }\n    \n    output\n}\n\n/// Skip over escape sequence, returning index after it\nfn skip_escape_sequence(bytes: &[u8], start: usize) -> usize {\n    let mut i = start + 1; // Skip ESC\n    if i >= bytes.len() { return i; }\n    \n    match bytes[i] {\n        // CSI sequence: ESC [ ... final_byte\n        b'[' => {\n            i += 1;\n            while i < bytes.len() {\n                match bytes[i] {\n                    0x40..=0x7E => { return i + 1; } // Final byte\n                    _ => { i += 1; }\n                }\n            }\n        }\n        // OSC sequence: ESC ] ... (BEL or ST)\n        b']' => {\n            i += 1;\n            while i < bytes.len() {\n                if bytes[i] == 0x07 { return i + 1; } // BEL\n                if bytes[i] == 0x1B && i + 1 < bytes.len() && bytes[i + 1] == b'\\\\' {\n                    return i + 2; // ST\n                }\n                i += 1;\n            }\n        }\n        // DCS/PM/APC: ESC P/^/_... ST\n        b'P' | b'^' | b'_' => {\n            i += 1;\n            while i < bytes.len() {\n                if bytes[i] == 0x1B && i + 1 < bytes.len() && bytes[i + 1] == b'\\\\' {\n                    return i + 2;\n                }\n                i += 1;\n            }\n        }\n        // Single-char escape (e.g., ESC 7, ESC 8)\n        0x20..=0x7E => {\n            return i + 1;\n        }\n        _ => {}\n    }\n    \n    i\n}\n```\n\n## API Design\n\n```rust\n/// Safe logging API (default)\nimpl TerminalWriter {\n    /// Write sanitized log line to scrollback\n    /// \n    /// # Sanitization\n    /// All escape sequences are stripped. Use write_raw() for trusted ANSI.\n    pub fn write_log(&mut self, text: &str) -> io::Result<()> {\n        let sanitized = sanitize(text);\n        self.writer.write_all(sanitized.as_bytes())?;\n        self.writer.flush()\n    }\n    \n    /// Write raw bytes (DANGER: bypasses sanitization)\n    /// \n    /// # Safety\n    /// Only call with trusted content. Untrusted content can corrupt\n    /// terminal state, break UI invariants, or deceive users.\n    pub fn write_raw(&mut self, bytes: &[u8]) -> io::Result<()> {\n        self.writer.write_all(bytes)?;\n        self.writer.flush()\n    }\n}\n\n/// Text type with trust level\npub enum Text<'a> {\n    /// Sanitized text (escape sequences stripped)\n    Sanitized(Cow<'a, str>),\n    \n    /// Trusted text (may contain ANSI sequences)\n    Trusted(Cow<'a, str>),\n}\n\nimpl Text<'_> {\n    /// Create sanitized text from untrusted source\n    pub fn sanitized(s: &str) -> Text<'_> {\n        Text::Sanitized(sanitize(s))\n    }\n    \n    /// Create from trusted source (ANSI allowed)\n    /// \n    /// # Safety\n    /// Only use with content from trusted sources.\n    pub fn trusted(s: &str) -> Text<'_> {\n        Text::Trusted(Cow::Borrowed(s))\n    }\n}\n```\n\n## Performance Requirements\n\n- Fast path (no ESC): < 100ns for typical log line\n- Slow path: Linear in input size\n- No allocation in fast path\n- Must not block on malformed sequences (bounded loops)\n\n## Tests Required\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_fast_path_no_escape() {\n        let input = \"Normal log message without escapes\";\n        let result = sanitize(input);\n        assert!(matches!(result, Cow::Borrowed(_)));\n        assert_eq!(result.as_ref(), input);\n    }\n    \n    #[test]\n    fn test_slow_path_strips_csi() {\n        let input = \"Hello \\\\x1b[31mred\\\\x1b[0m world\";\n        let result = sanitize(input);\n        assert!(matches!(result, Cow::Owned(_)));\n        assert_eq!(result.as_ref(), \"Hello red world\");\n    }\n    \n    #[test]\n    fn test_preserves_allowed_controls() {\n        let input = \"Line1\\\\nLine2\\\\tTabbed\\\\rCarriage\";\n        let result = sanitize(input);\n        assert_eq!(result.as_ref(), input); // \\\\n, \\\\t, \\\\r preserved\n    }\n    \n    #[test]\n    fn test_strips_forbidden_c0() {\n        let input = \"Hello\\\\x00World\\\\x07Bell\";\n        let result = sanitize(input);\n        assert_eq!(result.as_ref(), \"HelloWorldBell\");\n    }\n    \n    #[test]\n    fn test_strips_osc_sequences() {\n        // OSC 0: set title\n        let input = \"Text\\\\x1b]0;Evil Title\\\\x07More\";\n        let result = sanitize(input);\n        assert_eq!(result.as_ref(), \"TextMore\");\n    }\n    \n    #[test]\n    fn test_handles_truncated_sequences() {\n        // Truncated CSI\n        let input = \"Hello\\\\x1b[\";\n        let result = sanitize(input);\n        assert!(!result.contains(\"\\\\x1b\"));\n    }\n    \n    #[test]\n    fn test_unicode_preserved() {\n        let input = \"Hello 世界 👨‍👩‍👧\";\n        let result = sanitize(input);\n        assert_eq!(result.as_ref(), input);\n    }\n}\n```\n\n## Adversarial Tests (Integration)\nSee bd-397 for escape injection tests.\n\n## Acceptance Criteria\n- [ ] Fast path: no allocation when no ESC\n- [ ] CSI sequences stripped (SGR, cursor, etc.)\n- [ ] OSC sequences stripped (title, hyperlinks, etc.)\n- [ ] DCS/APC sequences stripped\n- [ ] TAB/LF/CR preserved\n- [ ] NUL and other C0 stripped\n- [ ] Unicode preserved\n- [ ] Truncated sequences handled safely\n- [ ] Performance: < 100ns fast path\n- [ ] write_log() uses sanitization by default\n- [ ] write_raw() exists for trusted content\n\n## Dependencies\n- Requires: bd-10i.8.1 (TerminalWriter structure)\n- Blocks: bd-397 (Adversarial tests use this)\n- Blocks: bd-2gx (Quality Gates)","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T23:12:01.192774597Z","created_by":"ubuntu","updated_at":"2026-02-01T00:25:55.319033238Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.4","depends_on_id":"bd-10i.10.6","type":"blocks","created_at":"2026-01-31T23:12:01.192774597Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.4","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T23:12:01.192774597Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.5","title":"Implement LogSink for in-process output routing","description":"# Implement LogSink for in-process output routing\n\n## Background\nPlan 0.9.4 and ADR-005 call out the need for in-process log routing so application code and libraries can write output without violating the one-writer rule.\n\nIn real harnesses, we want:\n- a `Write` implementation (or similar) that forwards to `TerminalWriter::write_log`\n- sanitization by default (ADR-006)\n- newline-aware behavior (avoid breaking prompt/UI)\n\n## Deliverable\nProvide a type like:\n- `LogSink` implementing `std::io::Write`\n- plus an ergonomic constructor from `TerminalWriter` / `TerminalSession`\n\n## Behavior\n- Buffers partial lines until newline (or flush)\n- On newline:\n  - forward the complete line through `TerminalWriter::write_log`\n  - trigger any required UI redraw coordination\n- Applies sanitizer by default\n\n## Tests\n- Unit tests:\n  - partial writes are buffered\n  - newline flushes\n  - explicit flush flushes\n  - sanitizer applied\n- Integration tests:\n  - interleave log writes and UI presents and assert UI remains stable (terminal-model + PTY)\n\n## Acceptance Criteria\n- [ ] LogSink exists and is documented as the preferred pattern for in-process output.\n- [ ] Line buffering + flush semantics are correct.\n- [ ] Sanitization is enforced by default.\n- [ ] No deadlocks / re-entrancy issues when used from multiple producers (single-writer enforcement preserved).","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:12:21.164216630Z","created_by":"ubuntu","updated_at":"2026-01-31T23:12:21.164216630Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.5","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T23:12:21.164216630Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.5","depends_on_id":"bd-10i.8.1","type":"blocks","created_at":"2026-01-31T23:12:21.164216630Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.5","depends_on_id":"bd-10i.8.4","type":"blocks","created_at":"2026-01-31T23:12:21.164216630Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.6","title":"Implement PTY capture for subprocess output (one-writer routing)","description":"# Implement PTY capture for subprocess output (one-writer routing)\n\n## Background\nPlan 0.9.4 and ADR-005: For agent harness realism, the most robust way to capture tool subprocess output is to spawn under a PTY and route output through ftui's writer.\n\nPTY capture helps enforce the one-writer rule because:\n- subprocess output cannot directly write to the user's terminal\n- ftui controls how output is displayed (sanitize, chunking, redraw)\n\n## Scope\nFeature-gated PTY capture utilities usable by `ftui-harness`:\n- spawn child process attached to PTY\n- read PTY output asynchronously\n- forward output through `TerminalWriter::write_log` (sanitized by default)\n\n## Design notes\n- This is *not* the same as `ftui-pty` test harness crate.\n  - `ftui-pty` is test-only.\n  - This task is runtime capture functionality (likely in `ftui-extras` or `ftui-harness`).\n- Handle:\n  - stdout/stderr merge semantics (PTY typically merges)\n  - exit status propagation\n  - backpressure / chunking to avoid UI starvation\n\n## Tests\n- Integration tests (PTY):\n  - run a small child process that prints mixed output + escape sequences\n  - assert sanitizer prevents terminal mutation\n  - assert UI redraw remains stable during capture\n\n## Acceptance Criteria\n- [ ] Feature-gated PTY capture API exists.\n- [ ] Output is routed through TerminalWriter/LogSink (no direct terminal writes).\n- [ ] Sanitization is applied by default.\n- [ ] Harness demo uses this path for tool execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:12:34.522793321Z","created_by":"ubuntu","updated_at":"2026-01-31T23:12:34.522793321Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.6","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T23:12:34.522793321Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.6","depends_on_id":"bd-10i.8.1","type":"blocks","created_at":"2026-01-31T23:12:34.522793321Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.6","depends_on_id":"bd-10i.8.4","type":"blocks","created_at":"2026-01-31T23:12:34.522793321Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.8.7","title":"Optional: stdio capture/forwarding for accidental println! (best-effort)","description":"# Optional: stdio capture/forwarding for accidental println! (best-effort)\n\n## Background\nADR-005 mentions an optional pattern: capturing stdout/stderr in-process to reduce the chance that third-party libs corrupt inline mode by writing directly.\n\nThis is inherently best-effort and platform-sensitive, so it must be feature-gated and clearly documented.\n\n## Scope\n- Feature-gated utility to capture and forward selected streams through `TerminalWriter::write_log`.\n- Explicitly not a hard guarantee (some output may still escape capture).\n\n## Design constraints\n- Must not deadlock.\n- Must not break normal non-ftui stdout usage.\n- Must be easy to disable.\n\n## Tests\n- Integration tests where feasible (may be limited in CI environments).\n- At minimum, unit tests around forwarding/buffering behavior.\n\n## Acceptance Criteria\n- [ ] Feature-gated capture utility exists.\n- [ ] Documentation clearly explains limitations and when to use PTY capture instead.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:12:44.248079720Z","created_by":"ubuntu","updated_at":"2026-01-31T23:12:44.248079720Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.8.7","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T23:12:44.248079720Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.8.7","depends_on_id":"bd-10i.8.5","type":"blocks","created_at":"2026-01-31T23:12:44.248079720Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10i.9","title":"Phase 7: Extras + Polish","description":"# Phase 7: Extras + Polish\n\n## Purpose\nAdd feature-gated extras, complete documentation, run performance audits, and validate terminal compatibility. This is the final polish before v1.\n\n## Documentation Deliverables\n- Rustdoc for all public APIs\n- Agent harness tutorial (inline + modal alt-screen patterns)\n- Inline vs alt-screen explanation (scrollback tradeoffs)\n- One-writer rule guidance + supported routing patterns\n- Windows v1 limitations + compatibility notes\n\n## Examples Gallery\nReference implementations demonstrating:\n- Minimal hello world\n- Streaming log viewer\n- Interactive dashboard\n- Full agent harness\n\n## Performance Audit\n- Verify all budgets met\n- Profile hot paths\n- Benchmark regression tests in CI\n- Track bytes emitted per frame\n\n## Terminal Compatibility Testing\n| Feature | Kitty | WezTerm | Alacritty | Ghostty | iTerm2 | GNOME Term | Win Term |\n|---------|-------|---------|-----------|---------|--------|------------|----------|\n| True Color | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |\n| Sync Output | ✓ | ✓ | ✓ | ✓ | ✗ | ✗ | ✗ |\n| OSC 8 Links | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✗ |\n| Kitty Kbd | ✓ | ✓ | ✗ | ✓ | ✗ | ✗ | ✗ |\n\n## Feature-Gated Extras\n- Markdown renderer\n- Syntax highlighting\n- Forms / pickers\n- Export adapters (HTML/SVG/text)\n- Optional clipboard integration (OSC 52 output)\n\n## CI/CD Setup\n- clippy + fmt enforcement\n- unit/property/snapshot/PTY tests\n- Performance benchmarks as baselines\n- Feature matrix build: default, +extras\n\n## Exit Criteria\n- Stable kernel API\n- Docs + examples complete\n- Performance baselines recorded\n- Compatibility matrix validated\n- All quality gates pass\n\n## Success Criteria\n- [ ] Docs and examples make the library easy to adopt (pit of success).\n- [ ] Extras remain feature-gated and do not destabilize the kernel.\n- [ ] Performance budgets are continuously enforced (bench + CI).","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-31T22:06:35.450846082Z","created_by":"ubuntu","updated_at":"2026-01-31T23:27:35.524128023Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10i.9","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T22:06:35.450846082Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10i.9","depends_on_id":"bd-10i.8","type":"blocks","created_at":"2026-01-31T22:21:29.267814226Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-10x","title":"Implement Style struct with cascading/merging","description":"PHASE 4 - STYLING CORE\n\n## Background\nStyle struct is the unified styling type that combines colors, attributes, and modifiers into a single composable unit. Must support cascading/merging like CSS inheritance.\n\n## Technical Requirements\n- Style struct containing:\n  - foreground: Option<PackedRgba>\n  - background: Option<PackedRgba>\n  - attrs: Option<CellAttrs>\n  - underline_color: Option<PackedRgba>\n- Cascading merge: child.merge(parent) fills in None fields from parent\n- Override merge: parent.patch(child) replaces with child's Some values\n- Builder pattern for ergonomic construction\n- impl Default with all None (transparent/inheriting)\n\n## Design Rationale\nOption-wrapped fields enable CSS-like inheritance where unset properties inherit from parent context. This matches user mental model from web development.\n\n## Acceptance Criteria\n- [ ] Style struct with Option-wrapped components\n- [ ] merge() for cascading (child wins on conflict)\n- [ ] patch() for override (explicit values win)\n- [ ] Builder pattern: Style::new().fg(color).bold()\n- [ ] #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n- [ ] Zero-cost when all fields are None\n- [ ] Property tests for merge associativity\n\n## Performance Budget\n- Style merge: < 5ns (branchless bitfield ops)\n- sizeof(Style) ≤ 24 bytes\n\n## Location: ftui-style crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:18:29.746530502Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:11.580195940Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-10x","depends_on_id":"bd-10i.3.2","type":"blocks","created_at":"2026-01-31T22:22:11.317919006Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-10x","depends_on_id":"bd-10i.3.3","type":"blocks","created_at":"2026-01-31T22:22:11.580166805Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-16k","title":"Unicode width corpus testing with WTF-8","description":"TESTING - UNICODE WIDTH CORPUS\n\n## Background\nUnicode width calculation is notoriously complex with edge cases around emoji, CJK, combining characters, and ZWJ sequences. A comprehensive test corpus is essential for correctness.\n\n## Technical Requirements\n- Test corpus categories:\n  - Basic ASCII (width 1)\n  - CJK Unified Ideographs (width 2)\n  - Fullwidth ASCII variants (width 2)\n  - Halfwidth Katakana (width 1)\n  - Emoji with modifiers (width varies)\n  - ZWJ sequences (flag emoji, family emoji)\n  - Combining characters (width 0)\n  - Control characters (width 0)\n  - Ambiguous width characters (context-dependent)\n- WTF-8 handling for unpaired surrogates\n- Terminal-specific width (vs Unicode Standard)\n- Test against unicode-width crate results\n\n## Known Edge Cases\n- 👨‍👩‍👧‍👦 (family emoji ZWJ) - varies by terminal\n- 🏳️‍🌈 (flag ZWJ) - often renders as 2 cells\n- Regional indicators (flag pairs)\n- Variation selectors (VS15/VS16)\n\n## Design Rationale\nCorrectness in width calculation directly impacts rendering quality. The corpus captures real-world edge cases that simple tests miss.\n\n## Acceptance Criteria\n- [ ] Corpus with 1000+ test cases\n- [ ] Categorized by width type\n- [ ] Known terminal-specific behaviors documented\n- [ ] Property tests for grapheme iteration\n- [ ] Fuzz testing for malformed input\n- [ ] Benchmark for width calculation performance\n\n## Location: ftui-text crate tests/","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:20:38.382705649Z","created_by":"ubuntu","updated_at":"2026-01-31T23:20:33.615935766Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-16k","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:22:45.728172253Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-16k","depends_on_id":"bd-e211","type":"blocks","created_at":"2026-01-31T23:20:33.615891893Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-19x","title":"Create performance benchmark suite","description":"TESTING - PERFORMANCE BENCHMARKS\n\n## Background\nFrankenTUI has strict performance budgets from the plan. Benchmarks must verify these budgets are met and prevent regressions.\n\n## Performance Budgets (from plan)\n\n### Core Operations\n| Operation | Target | Panic Threshold |\n|-----------|--------|-----------------|\n| Cell comparison | < 1ns | < 5ns |\n| Cell bits_eq SIMD | < 0.5ns | < 2ns |\n| Row comparison (80 cols) | < 100ns | < 500ns |\n| Buffer diff (80×24) | < 10µs | < 50µs |\n\n### Present Operations\n| Scenario | p50 Target | p99 Target |\n|----------|------------|------------|\n| 80×24, 5% changed | < 1.0ms | < 3.0ms |\n| 80×24, 50% changed | < 2.0ms | < 5.0ms |\n| 200×50, 5% changed | < 2.0ms | < 5.0ms |\n| 200×50, full redraw | < 10ms | < 25ms |\n\n### Layout Operations\n| Operation | Target | Notes |\n|-----------|--------|-------|\n| Flex solve (10 items) | < 50µs | |\n| Flex solve (50 items) | < 200µs | |\n| Grid solve (10×10) | < 500µs | |\n\n### Widget Rendering\n| Widget | Target (per instance) |\n|--------|----------------------|\n| Block | < 50µs |\n| Paragraph (100 chars) | < 100µs |\n| Table (100 rows visible) | < 500µs |\n\n## Technical Requirements\n\n### Benchmark Infrastructure\n- Use criterion crate\n- benches/ directory structure\n- Statistical analysis with confidence intervals\n- Comparison against baseline\n\n### Benchmark Organization\nbenches/\n├── cell_bench.rs      # Cell operations\n├── buffer_bench.rs    # Buffer operations  \n├── diff_bench.rs      # Diff algorithms\n├── present_bench.rs   # Presenter operations\n├── layout_bench.rs    # Layout solving\n├── widget_bench.rs    # Widget rendering\n└── e2e_bench.rs       # Full pipeline\n\n### Each Benchmark Must\n1. Warm up properly\n2. Use black_box to prevent optimization\n3. Test multiple input sizes\n4. Report memory allocation counts\n5. Compare against budget threshold\n\n### Benchmark Example\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn cell_comparison(c: &mut Criterion) {\n    let cell1 = Cell::default();\n    let cell2 = Cell::char('a');\n    \n    c.bench_function(\"cell_bits_eq_same\", |b| {\n        b.iter(|| black_box(&cell1).bits_eq(black_box(&cell1)))\n    });\n    \n    c.bench_function(\"cell_bits_eq_diff\", |b| {\n        b.iter(|| black_box(&cell1).bits_eq(black_box(&cell2)))\n    });\n}\n\n## Acceptance Criteria\n- [ ] Cell comparison benchmarks\n- [ ] Buffer operation benchmarks\n- [ ] Diff algorithm benchmarks\n- [ ] Present pipeline benchmarks\n- [ ] Layout solver benchmarks\n- [ ] Widget render benchmarks\n- [ ] Budget verification in CI\n- [ ] Baseline comparison reports\n- [ ] Memory allocation tracking\n\n## Location: benches/","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:28:46.596540823Z","created_by":"ubuntu","updated_at":"2026-02-01T00:25:08.947097129Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-19x","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:29:25.634665985Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-19x","depends_on_id":"bd-10i.4.1","type":"blocks","created_at":"2026-01-31T22:29:25.907101822Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-19x","depends_on_id":"bd-2m5","type":"blocks","created_at":"2026-02-01T00:25:08.947060380Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-19x","depends_on_id":"bd-3aqs","type":"blocks","created_at":"2026-01-31T23:22:13.185613398Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1f8","title":"Implement color downgrade (TrueColor → 256 → 16 → mono)","description":"PHASE 4 - COLOR DOWNGRADE SYSTEM\n\n## Background\nNot all terminals support TrueColor. The color system must gracefully downgrade colors to match terminal capabilities while maintaining visual coherence.\n\n## Technical Requirements\n\n### Color Profiles (from capabilities)\npub enum ColorProfile {\n    Mono,      // No color (dumb terminal)\n    Ansi16,    // 16 colors (basic)\n    Ansi256,   // 256 colors (xterm)\n    TrueColor, // 24-bit RGB\n}\n\n### Downgrade Chain\nTrueColor → 256 → 16 → Mono\n\n### Algorithms\n\n#### RGB to 256-color\nfn rgb_to_256(r: u8, g: u8, b: u8) -> u8 {\n    // Grayscale check first\n    if r == g && g == b {\n        if r < 8 { return 16; }\n        if r > 248 { return 231; }\n        return 232 + ((r - 8) / 10).min(23);\n    }\n    // 6×6×6 color cube\n    let r6 = (r as u16 * 6 / 256) as u8;\n    let g6 = (g as u16 * 6 / 256) as u8;\n    let b6 = (b as u16 * 6 / 256) as u8;\n    16 + 36 * r6 + 6 * g6 + b6\n}\n\n#### 256-color to 16-color\n- Map cube colors to nearest ANSI color\n- Preserve bright/normal distinction\n- Use perceptual color distance (not Euclidean RGB)\n\n#### 16-color to Mono\n- Convert to brightness value\n- Above threshold = white, below = black\n- Optionally use bold for emphasis\n\n### Caching\n- Cache downgraded colors (LRU or hash)\n- Profile is detected once at startup\n- Colors resolved at render time\n\n### Theme Integration\nThemes should define colors at highest fidelity.\nPresenter applies downgrade based on detected profile.\n\n## Tests Required\n- [ ] TrueColor passthrough works\n- [ ] 256-color conversion accurate\n- [ ] 16-color conversion visually reasonable\n- [ ] Mono fallback works\n- [ ] Grayscale optimization\n- [ ] Cache hit rate acceptable\n- [ ] Profile detection accurate\n\n## Acceptance Criteria\n- [ ] All profiles supported\n- [ ] Downgrade preserves intent\n- [ ] No performance regression\n- [ ] Theme colors degrade gracefully\n- [ ] Works in tmux/screen\n\n## Location: ftui-style crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:31:11.659117391Z","created_by":"ubuntu","updated_at":"2026-01-31T22:32:19.672075013Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1f8","depends_on_id":"bd-10i.3.2","type":"blocks","created_at":"2026-01-31T22:32:19.672042682Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ho","title":"Rich Core Infrastructure (rich_rust port)","description":"# Rich Core Infrastructure (reference extraction, feature-gated)\n\n## Purpose\nThis epic tracks optional infrastructure ideas inspired by `rich_rust`.\n\nThe plan keeps rich_rust’s best abstractions (Segments / measurement protocol / markup parser), but de-scopes “port everything” into feature-gated extras.\n\n## Reference Source\n- `legacy_reference_library_code/rich_rust/`\n\n## Plan Alignment\nFrom the plan (Chapter 1.4 / 1.5 / Phase 7):\n- Segments + measurement protocol are valuable\n- export-friendly representations are valuable\n- “widget zoo / markdown / syntax / forms” are extras\n\nWe treat this epic as Phase 7 **extras infrastructure** unless/until a specific piece is required by the agent harness.\n\n## Tracked Issues (this epic’s children)\n- `bd-1ho.2` Console abstraction (optional ergonomic output helpers)\n- `bd-1ho.5` Live display system (optional “live updating” view patterns)\n- `bd-1ho.6` Filesize formatter (small utility; optional)\n- `bd-1ho.7` Logging integration (optional formatting/bridge on top of `tracing`)\n- `bd-1ho.8` Extra test suite coverage for the above\n\nRelated (rich-derived but implemented elsewhere in the plan tree):\n- `bd-1ho.1` Segment system (Cow<str>)\n- `bd-1ho.3` TextMeasurement protocol\n\n## Non-Goals\n- Locking the kernel behind a large “rich port”\n- Introducing new, parallel APIs that duplicate ftui core\n\n## Success Criteria\n- [ ] Each child issue clearly states how it integrates with ftui (crate/module + feature flag).\n- [ ] Optional infrastructure cannot violate one-writer rule or inline-mode invariants.\n- [ ] Tests cover behavior and failure modes; logs are actionable.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T23:02:34.577032474Z","created_by":"ubuntu","updated_at":"2026-02-01T00:23:42.778697422Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:07.678702154Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":13,"issue_id":"bd-1ho","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-1ho.1","title":"Implement Segment system (Cow<str> styled text units)","description":"# Implement Segment system (Cow<str> styled text units)\n\n## Background\nPlan Appendix D.1 describes a Segment system inspired by rich_rust.\n\nA Segment is the atomic unit of styled text that can be:\n- cheaply borrowed (`Cow<str>`) for string literals / static content\n- split at **cell positions** (not byte positions) for correct wrapping\n\nSegments are a bridge:\n- higher-level text/layout systems produce Segments\n- widgets ultimately paint to `Frame`/`Buffer` using measured/split segments\n\n## Core types\n### Segment\n```rust\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Segment<'a> {\n    pub text: Cow<'a, str>,\n    pub style: Option<Style>,\n    pub control: Option<SmallVec<[ControlCode; 2]>>, // optional; stack-alloc common case\n}\n```\n\n### Control codes (optional)\nSegments may carry control codes for non-textual actions (rare; typically not needed in the kernel).\nIf we keep them, they must be constrained and documented.\n\n## Key APIs\n- `cell_length()` (display width)\n- `split_at_cell(cell_pos)` (critical for wrapping with wide chars/ZWJ)\n- helpers to split/join lines of segments\n\n## Design constraints\n- Splitting MUST respect Unicode scalar boundaries; ideally grapheme boundaries.\n- Control segments must not consume width.\n- ASCII width fast-path is a later optimization (see bd-v6y) and must not change correctness.\n\n## Tests\n- split_at_cell correctness for:\n  - ASCII\n  - CJK wide chars\n  - emoji/ZWJ sequences\n- cell_length matches `unicode_width` for the same input\n- line splitting preserves styles and does not drop content\n\n## Acceptance Criteria\n- [ ] Segment type exists with `Cow<str>` storage.\n- [ ] `cell_length` and `split_at_cell` APIs exist and are tested.\n- [ ] Segment line-splitting/joining helpers exist.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Create segment with owned String\n- [ ] Create segment with borrowed &str (Cow optimization)\n- [ ] Create control segments (newline, home, bell)\n- [ ] Calculate cell length accounting for:\n  - ASCII characters (1 cell each)\n  - Wide characters (2 cells each)\n  - Zero-width characters (0 cells)\n  - Control segments (0 cells)\n- [ ] Split segment at grapheme boundary\n- [ ] Strip styles preserving text\n- [ ] Join multiple segments\n- [ ] Split segments on newlines into Lines\n- [ ] Join Lines back into segments\n\n### Zero-Copy Requirements\n- [ ] String literals never allocate\n- [ ] Short strings use Cow::Borrowed when possible\n- [ ] Split returns borrowed segments when feasible\n- [ ] Concatenation minimizes copies\n\n### Performance Requirements\n- [ ] Cell length calculation: < 50ns for typical segment\n- [ ] Split operation: O(1) for ASCII content\n- [ ] Join operation: O(n) where n = total chars\n\n### Logging Requirements\n- [ ] tracing::trace! for segment creation (debug builds)\n- [ ] tracing::warn! for unexpectedly long segments (> 10KB)\n\n### Test Coverage\n- [ ] Unit tests for all segment operations\n- [ ] Property test: split-join is identity\n- [ ] Property test: cell length >= 0\n- [ ] Corpus test: Unicode edge cases (ZWJ, RTL, combining)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:02:46.925829242Z","created_by":"ubuntu","updated_at":"2026-01-31T23:19:41.976798774Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.1","depends_on_id":"bd-10i.6","type":"parent-child","created_at":"2026-01-31T23:14:50.969799531Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.1","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:04:18.847212946Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ho.2","title":"Implement Console abstraction","description":"# Implement Console abstraction (Segment-first, one-writer safe)\n\n## Objective\nProvide an optional, ergonomic “console output” helper inspired by rich-style APIs, but adapted to ftui’s constraints:\n- **Segment-first** (structured text + style)\n- **one-writer safe** (no ad-hoc terminal writes)\n\nThis is primarily useful for:\n- formatting tool output / logs into wrapped lines\n- producing captured output for tests\n- generating exportable text streams\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/console.rs`\n\n## Scope\n- A `Console` type that:\n  - accepts `Segment` streams (and/or `Renderable` → `Segment`)\n  - performs width-aware wrapping\n  - maintains an internal style stack for nested styling\n  - can operate in “record/capture” mode for tests\n\n## Output Policy (Critical)\n- The Console must not bypass ftui’s output routing.\n- Any “print” API must target:\n  - an in-memory buffer, OR\n  - a `LogSink`/writer abstraction that is already sanitized and one-writer compliant.\n\n## Dependencies / Integration\n- Depends on Segment system and markup parsing.\n- Should integrate with ftui-style and ftui-text measurement.\n\n## Tests Required\n- Unit tests for wrapping behavior (including wide/combining chars via existing width utilities).\n- Tests for style stack push/pop correctness.\n- Capture-mode tests that assert deterministic output.\n\n## Acceptance Criteria\n- [ ] `Console` exists with width-aware wrapping and a style stack.\n- [ ] Capture/record mode exists and is used in tests.\n- [ ] No API writes directly to stdout/stderr; output routing is explicit.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Width detection from terminal or fallback to 80\n- [ ] Explicit width override\n- [ ] Print plain strings with automatic wrapping\n- [ ] Print styled text with style application\n- [ ] Print any Renderable with measurement and rendering\n- [ ] Style stack: push/pop for nested styling\n- [ ] Markup string parsing and rendering\n- [ ] Recording mode for test capture\n\n### Color System Requirements\n- [ ] Auto-detect color capability from environment\n- [ ] NO_COLOR environment variable respected\n- [ ] Force color override option\n- [ ] Color downgrade for limited terminals\n\n### Output Requirements\n- [ ] All output respects current width\n- [ ] Long lines wrapped at word boundaries\n- [ ] Style reset at end of output\n- [ ] No raw escape codes in output (sanitized)\n\n### Logging Requirements\n- [ ] tracing::debug! for width detection\n- [ ] tracing::debug! for color system detection\n- [ ] tracing::trace! for style stack operations\n- [ ] tracing::info! for recording start/stop\n\n### Test Coverage\n- [ ] Unit tests for width handling\n- [ ] Unit tests for style stack\n- [ ] Unit tests for color system detection\n- [ ] Integration tests with renderables\n- [ ] Capture/assertion tests for output verification","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:02:54.445310573Z","created_by":"ubuntu","updated_at":"2026-02-01T00:26:24.834611488Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.2","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T23:04:20.442951992Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.2","depends_on_id":"bd-1ho","type":"parent-child","created_at":"2026-01-31T23:02:54.445310573Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.2","depends_on_id":"bd-1ho.1","type":"blocks","created_at":"2026-01-31T23:04:19.913985950Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.2","depends_on_id":"bd-1ho.3","type":"blocks","created_at":"2026-02-01T00:26:14.137790103Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.2","depends_on_id":"bd-3mo","type":"blocks","created_at":"2026-01-31T23:04:20.973683948Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":12,"issue_id":"bd-1ho.2","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-1ho.3","title":"Implement TextMeasurement protocol (Appendix D.3)","description":"# Implement TextMeasurement protocol (Appendix D.3)\n\n## Background\nPlan Appendix D.3 defines a simple measurement protocol used for layout negotiation.\n\nKey insight:\n- measurement is *bounds* (minimum + maximum), not a single width\n- bounds compose with simple algebra (union vs stack)\n\nThis supports deterministic layout without ad-hoc heuristics.\n\n## Core type (from plan)\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub struct TextMeasurement {\n    pub minimum: usize,\n    pub maximum: usize,\n}\n\nimpl TextMeasurement {\n    pub const ZERO: Self = Self { minimum: 0, maximum: 0 };\n\n    /// Union: take max of both bounds (for side-by-side layout)\n    pub fn union(self, other: Self) -> Self {\n        Self { minimum: self.minimum.max(other.minimum), maximum: self.maximum.max(other.maximum) }\n    }\n\n    /// Stack: add both bounds (for vertical stacking)\n    pub fn stack(self, other: Self) -> Self {\n        Self { minimum: self.minimum + other.minimum, maximum: self.maximum + other.maximum }\n    }\n\n    pub fn clamp(self, min_width: Option<usize>, max_width: Option<usize>) -> Self {\n        let mut result = self;\n        if let Some(min_w) = min_width {\n            result.minimum = result.minimum.max(min_w);\n            result.maximum = result.maximum.max(min_w);\n        }\n        if let Some(max_w) = max_width {\n            result.minimum = result.minimum.min(max_w);\n            result.maximum = result.maximum.min(max_w);\n        }\n        result\n    }\n}\n```\n\n## Integration points\n- `ftui-text`: compute measurements for Text/Segments\n- `ftui-layout`: use measurements when allocating space for widgets\n\n## Tests\n- union/stack/clamp behave exactly as defined\n- clamp invariants:\n  - minimum <= maximum\n  - clamps preserve ordering\n\n## Acceptance Criteria\n- [ ] `TextMeasurement` exists with union/stack/clamp.\n- [ ] Unit tests cover composition laws.\n- [ ] Adopted by layout/text measurement code paths (call sites tracked in follow-up issues).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:03:01.763981159Z","created_by":"ubuntu","updated_at":"2026-01-31T23:20:43.312723026Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.3","depends_on_id":"bd-10i.7","type":"parent-child","created_at":"2026-01-31T23:20:15.236621599Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ho.4","title":"Implement border/box drawing character sets (Appendix D.5)","description":"# Implement border/box drawing character sets (Appendix D.5)\n\n## Background\nPlan Phase 4 includes: \"Border presets and custom\".\n\nAppendix D.5 references a border system inspired by charmed_rust and rich_rust:\n- reusable border presets (rounded, square, double, heavy, ascii)\n- used by Panel/Block widgets\n- should degrade gracefully when Unicode box drawing is undesirable\n\n## Scope\n- Define a border/box character set type (name it `BorderChars` / `BorderSet` etc; avoid `Box` name collisions).\n- Provide presets:\n  - Rounded\n  - Square\n  - Double\n  - Heavy\n  - ASCII fallback\n- Include T-intersections and cross characters for tables where needed.\n\n## Design notes\n- Border characters are from Unicode Box Drawing (U+2500..U+257F).\n- ASCII fallback uses `+`, `-`, `|`.\n- This is a *data* module; actual drawing happens in widgets (`Block`, `Panel`, `Table`).\n\n## Tests\n- Presets contain expected characters (sanity checks)\n- ASCII fallback is complete and consistent\n\n## Acceptance Criteria\n- [ ] Border character set type exists.\n- [ ] Presets exist and are documented.\n- [ ] Used by Block/Panel widgets (follow-up dependencies tracked).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:03:07.697787474Z","created_by":"ubuntu","updated_at":"2026-01-31T23:21:06.638255059Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.4","depends_on_id":"bd-10i.6","type":"parent-child","created_at":"2026-01-31T23:20:49.805784770Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1ho.5","title":"Implement Live display system","description":"# Implement Live display system (optional)\n\n## Objective\nProvide an optional “live updating” display helper (progress/status refresh) for cases where we want transient output in a normal terminal stream.\n\nThis is **not** the core ftui rendering model (full-buffer diff + presenter). It’s an optional utility inspired by rich-style “live” output.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/live.rs`\n\n## Design Constraints (ftui-specific)\n- Must respect the **one-writer rule**: any redirection of output must be explicit.\n- Must not compromise inline-mode invariants when used alongside the harness.\n- Must have bounded refresh behavior (no busy looping).\n\n## Scope\n- A `Live` controller that:\n  - renders a `Renderable`/`Segment`-like view repeatedly\n  - supports a configurable refresh cadence\n  - cleans up cursor/modes on stop/drop\n  - provides vertical overflow strategies (crop/ellipsis/visible)\n\n## Integration\n- Reuse Presenter encoding for cursor save/restore, clears, etc.\n- Reuse Console abstraction for rendering content into segments/lines.\n\n## Tests Required\n- Unit tests for overflow strategies and refresh cadence logic.\n- PTY integration tests for cleanup on stop/drop and on panic.\n\n## Acceptance Criteria\n- [ ] Live rendering can start/stop cleanly and is idempotent.\n- [ ] Refresh cadence is bounded and testable.\n- [ ] PTY tests verify cursor/modes are restored after Live stops.\n- [ ] Output routing is explicit (no hidden writes that violate one-writer rule).","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:03:18.946085437Z","created_by":"ubuntu","updated_at":"2026-02-01T00:26:40.308488926Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.5","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T23:04:23.110285746Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.5","depends_on_id":"bd-1ho","type":"parent-child","created_at":"2026-01-31T23:03:18.946085437Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.5","depends_on_id":"bd-1ho.2","type":"blocks","created_at":"2026-01-31T23:04:22.582300790Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.5","depends_on_id":"bd-3ky.10","type":"blocks","created_at":"2026-01-31T23:04:23.633608498Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":11,"issue_id":"bd-1ho.5","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-1ho.6","title":"Implement filesize formatter","description":"# Implement filesize formatter (utility)\n\n## Objective\nProvide a small utility to format byte counts in human-friendly form (binary and decimal units), useful for status lines, file pickers, and logs.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/filesize.rs`\n\n## Scope\n- Support both:\n  - binary units (KiB, MiB, GiB, TiB)\n  - decimal units (KB, MB, GB, TB)\n- Configurable precision and short/long unit formatting\n- Well-defined rounding behavior\n\n## Tests Required\n- Table-driven unit tests for edge cases:\n  - 0 bytes\n  - thresholds at 999/1000 and 1023/1024 boundaries\n  - very large values (u64 max-ish)\n  - precision/rounding correctness\n\n## Acceptance Criteria\n- [ ] Public API exists for binary + decimal formatting and options.\n- [ ] Unit tests cover boundary and rounding cases.\n- [ ] Output is deterministic and documented (units + rounding rules).","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:03:24.277137420Z","created_by":"ubuntu","updated_at":"2026-02-01T00:26:53.089685569Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.6","depends_on_id":"bd-1ho","type":"parent-child","created_at":"2026-01-31T23:03:24.277137420Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":35,"issue_id":"bd-1ho.6","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-1ho.7","title":"Implement logging integration","description":"# Implement logging integration (rich-style formatting on top of tracing)\n\n## Objective\nProvide an optional logging layer that formats `tracing` events into styled output (Segments) in a way that is:\n- readable for humans\n- deterministic for tests\n- compatible with ftui’s one-writer routing\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/logging.rs`\n\n## Scope\n- A formatter/subscriber (or layer) that:\n  - applies per-level styling (error/warn/info/debug/trace)\n  - supports timestamps (configurable)\n  - optionally shows source location (file:line)\n  - formats structured fields consistently\n\n## One-Writer Rule (Critical)\n- This integration must not write directly to stdout/stderr in a way that can interleave with ftui rendering.\n- Output should be routed into a sink that can be:\n  - captured for tests, or\n  - forwarded via ftui’s `LogSink`/TerminalWriter policy.\n\n## Tests Required\n- Unit tests for formatting choices (stable snapshots of formatted lines/segments).\n- Concurrency test: multiple threads logging cannot interleave within a single formatted record.\n- Integration test (optional) that shows logs routed into the harness log region.\n\n## Acceptance Criteria\n- [ ] A tracing integration exists (subscriber/layer) with configurable formatting.\n- [ ] Output is Segment-based and can be captured deterministically in tests.\n- [ ] One-writer routing is respected (no hidden direct terminal writes).\n- [ ] Unit tests cover formatting and level styling.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:03:29.952985639Z","created_by":"ubuntu","updated_at":"2026-02-01T00:27:16.216241387Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.7","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:04:24.748807179Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.7","depends_on_id":"bd-1ho","type":"parent-child","created_at":"2026-01-31T23:03:29.952985639Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.7","depends_on_id":"bd-1ho.2","type":"blocks","created_at":"2026-01-31T23:04:24.140277628Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.7","depends_on_id":"bd-3e8","type":"blocks","created_at":"2026-02-01T00:27:04.039296756Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":10,"issue_id":"bd-1ho.7","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-1ho.8","title":"Rich Core Infrastructure Test Suite","description":"Comprehensive test suite for rich_rust core infrastructure. These foundational components support all renderables and require thorough verification.\n\n## Test Requirements by Module\n\n### Segment System (bd-1ho.1)\nUnit tests:\n- `test_segment_new_owned` - Owned string segment\n- `test_segment_new_borrowed` - Borrowed string segment (Cow)\n- `test_segment_control` - Control segment creation\n- `test_segment_cell_length_ascii` - ASCII width = byte length\n- `test_segment_cell_length_unicode` - Wide chars counted correctly\n- `test_segment_cell_length_control` - Control segments = 0 width\n- `test_segment_split_at_ascii` - Split ASCII segment\n- `test_segment_split_at_unicode` - Split at grapheme boundary\n- `test_segment_strip_styles` - Remove styles preserve text\n- `test_segments_join` - Concatenate segments\n- `test_segments_split_lines` - Split on newlines\n- `test_segments_join_lines` - Rejoin lines\n\nProperty tests:\n- `prop_split_join_inverse` - Split then join = original\n- `prop_cell_length_non_negative` - Cell length >= 0\n- `prop_split_preserves_total_length` - Sum of parts = whole\n\n### Console (bd-1ho.2)\nUnit tests:\n- `test_console_default_width` - Width detection or fallback\n- `test_console_explicit_width` - Override width\n- `test_console_print_string` - Simple string output\n- `test_console_print_styled` - Styled text output\n- `test_console_print_renderable` - Renderable output\n- `test_console_style_stack_push` - Push style\n- `test_console_style_stack_pop` - Pop style\n- `test_console_style_stack_nested` - Nested styles cascade\n- `test_console_color_system_detect` - Auto-detect color capability\n- `test_console_no_color_env` - NO_COLOR respected\n- `test_console_force_color` - Force color override\n- `test_console_capture_begin` - Start recording\n- `test_console_capture_end` - Retrieve captured segments\n\nIntegration tests:\n- `test_console_with_renderables` - Full rendering pipeline\n- `test_console_line_wrapping` - Long lines wrapped\n\n### Measurement (bd-1ho.3)\nUnit tests:\n- `test_measurement_new_valid` - min <= max\n- `test_measurement_from_width` - min = max = width\n- `test_measurement_span` - max - min\n- `test_measurement_with_maximum` - Clamp maximum\n- `test_measurement_with_minimum` - Clamp minimum\n- `test_measure_text_single_line` - Single line width\n- `test_measure_text_multiline` - Max of all lines\n- `test_measure_text_with_wrap` - Account for wrap points\n\nProperty tests:\n- `prop_measurement_min_le_max` - min always <= max\n- `prop_measurement_clamp_valid` - Clamping preserves invariant\n\n### Box Drawing (bd-1ho.4)\nUnit tests:\n- `test_box_rounded_chars` - Rounded box characters\n- `test_box_square_chars` - Square box characters  \n- `test_box_double_chars` - Double-line characters\n- `test_box_heavy_chars` - Heavy box characters\n- `test_box_ascii_chars` - ASCII fallback\n- `test_box_substitute_true` - Returns ASCII variant\n- `test_box_substitute_false` - Returns original\n- `test_box_get_top` - Top border string\n- `test_box_get_bottom` - Bottom border string\n- `test_box_get_row_single` - Single cell row\n- `test_box_get_row_multiple` - Multi-cell row with separators\n\n### Live Display (bd-1ho.5)\nUnit tests:\n- `test_live_start` - Begin live display\n- `test_live_stop` - End live display\n- `test_live_update` - Replace content\n- `test_live_refresh` - Redraw current content\n- `test_live_vertical_overflow_ellipsis` - Truncate with ...\n- `test_live_vertical_overflow_crop` - Hard crop\n- `test_live_transient` - Cursor save/restore\n\nIntegration tests:\n- `test_live_with_progress` - Progress bar in live context\n- `test_live_nested` - Nested live displays\n\n### Filesize Formatter (bd-1ho.6)\nUnit tests:\n- `test_filesize_bytes` - < 1KB shows bytes\n- `test_filesize_kb_binary` - KiB formatting\n- `test_filesize_mb_binary` - MiB formatting\n- `test_filesize_gb_binary` - GiB formatting\n- `test_filesize_tb_binary` - TiB formatting\n- `test_filesize_decimal` - 1000-based units\n- `test_filesize_precision` - Decimal places\n- `test_filesize_short` - Short unit names\n- `test_filesize_edge_zero` - Zero bytes\n- `test_filesize_edge_max` - u64::MAX\n\nProperty tests:\n- `prop_filesize_parses_back` - Formatted string can be parsed\n\n### Logging Integration (bd-1ho.7)\nUnit tests:\n- `test_log_level_styling` - Error=red, warn=yellow, info=blue\n- `test_log_timestamp_format` - Timestamp in expected format\n- `test_log_source_location` - file:line shown\n- `test_log_structured_fields` - Key=value pairs\n- `test_log_quiet_mode` - Reduced output\n- `test_log_with_live` - Logs don't corrupt live display\n\nIntegration tests:\n- `test_log_tracing_subscriber` - Works with tracing\n\n## E2E Test Scenarios\n\n### Console Pipeline E2E\n```rust\n#[test]\nfn e2e_console_full_render() {\n    // Setup\n    let mut console = Console::with_width(80);\n    console.begin_capture();\n    \n    // Render complex content\n    console.rule(Some(\"Header\"));\n    console.print(Panel::new(Text::from(\"Content\")).with_title(\"Box\"));\n    console.print(Columns::new(vec![col1, col2]));\n    console.rule(None);\n    \n    // Verify\n    let segments = console.end_capture();\n    assert!(!segments.is_empty());\n    assert!(segments.iter().any(|s| s.text.contains(\"Header\")));\n    // ... more assertions\n}\n```\n\n### Measurement Chain E2E\n```rust\n#[test]\nfn e2e_measurement_chain() {\n    let content = Group::new(vec![\n        Box::new(Padding::new(\n            Panel::new(Text::from(\"Inner\")),\n            Sides::all(2)\n        )),\n        Box::new(Rule::new()),\n    ]);\n    \n    let measurement = content.measure(&console, 80);\n    assert!(measurement.minimum <= measurement.maximum);\n    assert!(measurement.maximum <= 80);\n    \n    let rendered = content.render(&console, 80);\n    for line in &rendered.lines {\n        let width: usize = line.iter().map(|s| s.cell_length()).sum();\n        assert!(width <= 80);\n    }\n}\n```\n\n## Logging Requirements\n- `tracing::info!` for console output operations\n- `tracing::debug!` for measurement calculations\n- `tracing::trace!` for segment construction\n- Live display refreshes logged at trace level\n\n## Coverage Targets\n- Line coverage: >= 90%\n- Branch coverage: >= 85%\n\nDependencies: All Rich Core modules, Testing infrastructure (bd-10i.11)\n\n\n## Acceptance Criteria\n- [ ] Covers unit/snapshot/property tests for each rich-derived extra we keep.\n- [ ] Includes at least one integration test demonstrating one-writer safe routing.\n- [ ] Failure output is actionable (expected vs actual segments/lines).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:17:50.143443525Z","created_by":"ubuntu","updated_at":"2026-02-01T00:27:25.821756354Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1ho.8","depends_on_id":"bd-10i.11","type":"blocks","created_at":"2026-01-31T23:18:03.450762458Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.8","depends_on_id":"bd-1ho.1","type":"blocks","created_at":"2026-01-31T23:18:43.516655476Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.8","depends_on_id":"bd-1ho.2","type":"blocks","created_at":"2026-01-31T23:18:44.145892430Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.8","depends_on_id":"bd-1ho.3","type":"blocks","created_at":"2026-01-31T23:18:44.752956235Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.8","depends_on_id":"bd-1ho.4","type":"blocks","created_at":"2026-01-31T23:18:45.361798387Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.8","depends_on_id":"bd-1ho.5","type":"blocks","created_at":"2026-01-31T23:18:45.968271329Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.8","depends_on_id":"bd-1ho.6","type":"blocks","created_at":"2026-01-31T23:18:46.590353912Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1ho.8","depends_on_id":"bd-1ho.7","type":"blocks","created_at":"2026-01-31T23:18:47.201728213Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":5,"issue_id":"bd-1ho.8","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-1mh","title":"Implement HitGrid for mouse hit testing","description":"PHASE 5 - HIT TESTING INFRASTRUCTURE\n\n## Background\nMouse interaction requires knowing what widget is at a given coordinate. HitGrid provides a parallel grid that maps screen positions to interactive elements.\n\n## Technical Requirements\n\n### HitGrid Structure\npub struct HitGrid {\n    width: u16,\n    height: u16,\n    cells: Vec<HitCell>,\n}\n\npub struct HitCell {\n    /// Widget ID at this position\n    widget_id: Option<WidgetId>,\n    /// Interactive region type\n    region: HitRegion,\n    /// User data for callbacks\n    data: HitData,\n}\n\npub enum HitRegion {\n    None,\n    Content,        // Main widget content\n    Border,         // Widget border\n    Scrollbar,      // Scrollbar area\n    Handle,         // Resize handle\n    Button,         // Clickable button\n    Link,           // Hyperlink\n    Custom(u8),     // User-defined\n}\n\npub type WidgetId = u32;\npub type HitData = u64;  // Opaque user data\n\n### Registration API\nimpl HitGrid {\n    /// Clear all hit regions\n    pub fn clear(&mut self);\n    \n    /// Register a hit region\n    pub fn register(&mut self, area: Rect, widget_id: WidgetId, region: HitRegion, data: HitData);\n    \n    /// Query hit at position\n    pub fn hit_test(&self, x: u16, y: u16) -> Option<(WidgetId, HitRegion, HitData)>;\n    \n    /// Query all hits in area\n    pub fn hits_in(&self, area: Rect) -> Vec<(WidgetId, HitRegion, HitData)>;\n}\n\n### Frame Integration\npub struct Frame {\n    buffer: Buffer,\n    hit_grid: Option<HitGrid>,  // Optional for performance\n}\n\nimpl Frame {\n    pub fn enable_hit_testing(&mut self);\n    \n    pub fn register_hit(&mut self, area: Rect, widget_id: WidgetId, region: HitRegion, data: HitData) {\n        if let Some(ref mut grid) = self.hit_grid {\n            grid.register(area, widget_id, region, data);\n        }\n    }\n}\n\n### Widget Integration Pattern\nimpl Widget for Button {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        // Render button...\n        \n        // Register hit area\n        buf.frame().register_hit(\n            area,\n            self.widget_id,\n            HitRegion::Button,\n            self.on_click_data,\n        );\n    }\n}\n\n### Event Dispatch\nimpl Program {\n    fn handle_mouse(&mut self, event: MouseEvent) {\n        if let Some((widget_id, region, data)) = self.frame.hit_test(event.x, event.y) {\n            // Dispatch to appropriate handler\n        }\n    }\n}\n\n## Tests Required\n- [ ] Registration works\n- [ ] Hit test returns correct widget\n- [ ] Overlapping regions: last wins\n- [ ] Clear removes all hits\n- [ ] hits_in returns all in area\n- [ ] Performance: 80x24 grid operations < 1µs\n\n## Acceptance Criteria\n- [ ] HitGrid implementation\n- [ ] Frame integration\n- [ ] Widget registration pattern\n- [ ] Mouse event dispatch\n- [ ] Optional (feature gated) for performance\n\n## Location: ftui-render crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:36:43.854972379Z","created_by":"ubuntu","updated_at":"2026-01-31T22:37:55.696089324Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1mh","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:37:55.696058295Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1oz","title":"Implement LRU width cache for text measurement","description":"# Implement LRU Width Cache for Text Measurement\n\n## Background\nPlan Section 1.4 and Appendix D.3 explicitly mention the \"LRU width cache\" from rich_rust as a key optimization. Text width measurement is a hot path (called for every render) and must be cached.\n\n## Why LRU Cache?\n- Unicode width calculation is expensive (grapheme segmentation + width lookup)\n- Same text strings appear repeatedly (labels, status text, etc.)\n- Cache hit rate expected to be high for typical UIs\n- Prevents O(n) per-frame width recalculation\n\n## Design\n```rust\n/// Width cache with LRU eviction\npub struct WidthCache {\n    cache: LinkedHashMap<u64, usize>,  // hash -> width\n    capacity: usize,\n}\n\nimpl WidthCache {\n    pub fn new(capacity: usize) -> Self {\n        Self {\n            cache: LinkedHashMap::with_capacity(capacity),\n            capacity,\n        }\n    }\n\n    /// Get cached width or compute and cache\n    pub fn get_or_compute(&mut self, text: &str, compute: impl FnOnce() -> usize) -> usize {\n        let hash = hash_text(text);\n        \n        if let Some(&width) = self.cache.get(&hash) {\n            // Move to front (LRU refresh)\n            self.cache.get_refresh(&hash);\n            return width;\n        }\n        \n        let width = compute();\n        \n        // Evict if over capacity\n        while self.cache.len() >= self.capacity {\n            self.cache.pop_front();\n        }\n        \n        self.cache.insert(hash, width);\n        width\n    }\n    \n    pub fn clear(&mut self) {\n        self.cache.clear();\n    }\n}\n\n// Use FNV or xxhash for fast hashing\nfn hash_text(text: &str) -> u64 {\n    use std::hash::{Hash, Hasher};\n    let mut hasher = FnvHasher::default();\n    text.hash(&mut hasher);\n    hasher.finish()\n}\n```\n\n## Integration Points\n- `RenderContext` holds a `RefCell<WidthCache>`\n- `Text::cell_length()` uses the cache\n- `Segment::cell_length()` uses the cache\n- Cache is cleared on theme change (fonts can affect width)\n\n## Cache Sizing\n- Default: 1024 entries (covers typical UI with headroom)\n- Configurable via `WidthCache::new(capacity)`\n- Memory footprint: ~32 bytes per entry (hash + width + list pointers)\n\n## Performance Requirements\n- Cache hit: < 50ns (hash + lookup)\n- Cache miss: < 5µs (grapheme segmentation + width calculation)\n- Hash collision handling: rare, just recompute\n\n## Tests Required\n- [ ] Cache hits return correct cached value\n- [ ] Cache misses compute and cache\n- [ ] LRU eviction works correctly\n- [ ] Clear() empties cache\n- [ ] Thread safety if needed (RefCell for single-threaded)\n- [ ] Performance benchmarks\n\n## Acceptance Criteria\n- [ ] LRU cache implemented with configurable capacity\n- [ ] Integrated into text measurement hot path\n- [ ] Performance benchmarks show significant speedup\n- [ ] No correctness regressions in width measurement\n\n## Location\n`ftui-text/src/cache.rs`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:17:08.580451576Z","created_by":"ubuntu","updated_at":"2026-01-31T23:17:19.845573559Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1oz","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:17:19.845536820Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1qb","title":"Implement Image widget with protocol detection","description":"PHASE 7 - EXTRAS: IMAGE WIDGET\n\n## Background\nImage widget displays images in terminal using Kitty Graphics Protocol, iTerm2 inline images, or Sixel fallback. Requires protocol detection and graceful degradation.\n\n## Technical Requirements\n- Protocol detection:\n  - Kitty Graphics Protocol (XTGETTCAP query)\n  - iTerm2 inline images (TERM_PROGRAM check)\n  - Sixel (DA2 response parsing)\n  - Fallback: ASCII/Braille representation\n- Image loading via image crate\n- Resize/fit modes: Contain, Cover, Stretch, None\n- Aspect ratio preservation\n- Partial update for animated GIFs\n- Memory management for large images\n\n## Design Rationale\nImage support is a premium feature gated behind 'image' flag. Protocol detection happens once at startup and caches result. Fallback ensures graceful degradation.\n\n## Acceptance Criteria\n- [ ] Protocol detection and caching\n- [ ] Kitty Graphics Protocol implementation\n- [ ] iTerm2 inline image implementation\n- [ ] Sixel fallback (optional sub-feature)\n- [ ] ASCII fallback when no protocol available\n- [ ] Resize mode configuration\n- [ ] Aspect ratio handling\n- [ ] Feature gate: image\n\n## Performance Budget\n- Protocol detection: < 50ms (one-time)\n- Image encode/transmit: proportional to size\n\n## Location: ftui-extras crate (feature = \"image\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:20:04.942919291Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:35.619831992Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1qb","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T22:22:35.619803037Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1tt","title":"Implement focus and resize event handling in InputParser","description":"# Implement Focus and Resize Event Handling\n\n## Background\nThe plan specifies that the input system must handle focus events and resize events. These are essential for agent harness UIs to respond to window changes and terminal focus state.\n\n## Technical Requirements\n\n### Focus Events\nDetection: Terminals that support focus events send:\n- Focus gained: `\\x1b[I` (CSI I)\n- Focus lost: `\\x1b[O` (CSI O)\n\nActivation:\n```rust\nimpl TerminalSession {\n    pub fn enable_focus_events(&mut self) -> io::Result<()> {\n        self.writer.write_all(b\"\\x1b[?1004h\")?;\n        Ok(())\n    }\n    \n    pub fn disable_focus_events(&mut self) -> io::Result<()> {\n        self.writer.write_all(b\"\\x1b[?1004l\")?;\n        Ok(())\n    }\n}\n```\n\n### Resize Events\nPlatform-specific handling:\n\n#### Unix (SIGWINCH)\n```rust\nuse signal_hook::consts::SIGWINCH;\nuse signal_hook::iterator::Signals;\n\nfn setup_resize_handler() -> Receiver<(u16, u16)> {\n    let (tx, rx) = channel();\n    let mut signals = Signals::new(&[SIGWINCH]).unwrap();\n    \n    thread::spawn(move || {\n        for _ in signals.forever() {\n            if let Some((w, h)) = terminal_size::terminal_size() {\n                let _ = tx.send((w.0, h.0));\n            }\n        }\n    });\n    \n    rx\n}\n```\n\n#### Crossterm Approach\n```rust\n// Crossterm provides resize events in its event stream\nif let Event::Resize(w, h) = event {\n    return Some(ftui::Event::Resize { width: w, height: h });\n}\n```\n\n### Event Types\n```rust\npub enum Event {\n    Key(KeyEvent),\n    Mouse(MouseEvent),\n    Resize { width: u16, height: u16 },\n    Focus(bool),  // true = gained, false = lost\n    Paste(String),\n}\n```\n\n### Parser Handling\n```rust\nimpl InputParser {\n    fn parse_csi_sequence(&mut self) -> Option<Event> {\n        let seq = &self.buffer;\n        \n        // Focus events\n        if seq == b\"I\" {\n            return Some(Event::Focus(true));\n        }\n        if seq == b\"O\" {\n            // Note: Distinguish from application cursor mode O\n            return Some(Event::Focus(false));\n        }\n        \n        // ... other CSI handling\n    }\n}\n```\n\n## Runtime Integration\n```rust\nimpl Program {\n    fn poll_events(&mut self) -> Vec<Event> {\n        let mut events = Vec::new();\n        \n        // Check resize channel\n        while let Ok((w, h)) = self.resize_rx.try_recv() {\n            events.push(Event::Resize { width: w, height: h });\n        }\n        \n        // Check focus events (from input parser)\n        // Check key/mouse events\n        \n        events\n    }\n}\n```\n\n## Resize Handling in Model\n```rust\nimpl Model for MyApp {\n    fn update(&mut self, msg: Event) -> Cmd<Event> {\n        match msg {\n            Event::Resize { width, height } => {\n                // Recalculate layouts\n                // Re-render at new size\n                self.size = (width, height);\n                Cmd::none()\n            }\n            Event::Focus(gained) => {\n                // Update focus state\n                // Maybe pause/resume animations\n                self.focused = gained;\n                Cmd::none()\n            }\n            _ => // ...\n        }\n    }\n}\n```\n\n## Tests Required\n- [ ] Focus gained event parsed correctly\n- [ ] Focus lost event parsed correctly\n- [ ] Focus event vs cursor mode O distinguished\n- [ ] Resize event from SIGWINCH\n- [ ] Resize event propagation to model\n- [ ] Cleanup disables focus events on exit\n\n## Acceptance Criteria\n- [ ] Event::Resize type defined\n- [ ] Event::Focus type defined\n- [ ] InputParser handles focus events\n- [ ] Resize handling (Unix + Windows)\n- [ ] RAII cleanup on exit\n- [ ] Integration with runtime\n\n## Location: ftui-core (input.rs, session.rs)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:54:27.699656379Z","created_by":"ubuntu","updated_at":"2026-01-31T22:54:34.947125219Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1tt","depends_on_id":"bd-10i.5","type":"parent-child","created_at":"2026-01-31T22:54:34.947091165Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1tt","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:54:33.559970198Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1u5","title":"Document Inline vs Alt-Screen mode trade-offs","description":"# Document Inline vs Alt-Screen Mode Trade-offs\n\n## Background & Strategic Importance\nThe plan requires documentation that explains \"inline vs alt-screen explanation (scrollback tradeoffs)\". This is critical for users to understand which mode to use for their application. The wrong choice leads to frustrated users who either:\n- Lose their log history (alt-screen for an agent harness)\n- Get cursor corruption (inline without understanding constraints)\n\n## Why This Documentation Is Critical\n- ADR-001 (Inline Mode Strategy) is a cornerstone decision\n- Users coming from other TUI frameworks assume alt-screen\n- Agent harness users NEED inline mode but don't know it exists\n- Common source of \"why doesn't my app work\" questions\n\n---\n\n## Content Structure\n\n### What Is Inline Mode?\n\n**Definition:** The UI renders in the normal terminal buffer, interleaved with the terminal's scrollback history.\n\n**How it works:**\n```\n[Previous terminal output]\n[Previous terminal output]\n[Previous terminal output]\n[Log line 1]                 <- These scroll up into scrollback\n[Log line 2]\n[Log line 3]\n├──────────────────────────┤\n│ Status: Running tool... │ <- This is the pinned UI region\n│ > Enter command: _      │    (fixed height, redrawn in place)\n├──────────────────────────┤\n```\n\n**Key behaviors:**\n- Scrollback is preserved (native terminal feature)\n- Logs become part of terminal history\n- Can scroll back after program exits to see full history\n- UI occupies a fixed region at the bottom\n- Default mode for ftui\n\n**Technical implementation:**\n- Never issue full-screen clear (`\\x1b[2J`)\n- Only redraw the bounded UI region\n- Use EL (erase line) for local clearing\n- Cursor must be restored after every present()\n\n---\n\n### What Is Alt-Screen Mode?\n\n**Definition:** The UI renders in the alternate screen buffer, a separate buffer from the primary terminal.\n\n**How it works:**\n```\n┌──────────────────────────────────────┐\n│                                      │\n│         Full-screen TUI              │\n│                                      │\n│    No scrollback in this buffer      │\n│                                      │\n│                                      │\n│   Status bar at bottom               │\n└──────────────────────────────────────┘\n```\n\n**Key behaviors:**\n- Scrollback is NOT preserved (alt buffer is blank)\n- When program exits, previous content is restored\n- Classic TUI experience (vim, htop, less)\n- Full-screen clears are safe\n- Opt-in via `ScreenMode::AltScreen`\n\n**Technical implementation:**\n- Enter: `\\x1b[?1049h` (smcup)\n- Exit: `\\x1b[?1049l` (rmcup)\n- Previous screen automatically restored on exit\n\n---\n\n### Trade-off Matrix\n\n| Feature | Inline Mode | Alt-Screen Mode |\n|---------|-------------|-----------------|\n| Scrollback preserved | ✓ | ✗ |\n| Full-screen clear safe | ✗ | ✓ |\n| Log history after exit | ✓ | ✗ |\n| Cursor management | Complex | Simple |\n| Classic TUI feel | ✗ | ✓ |\n| Agent harness ideal | ✓ | ✗ |\n| Resize handling | Requires anchor | Straightforward |\n| Panic cleanup | Critical | Important |\n\n---\n\n### When to Use Inline Mode\n\n**Use inline mode when:**\n- Building agent harness UIs (Claude Code, Codex style)\n- Log viewers where history matters after exit\n- REPLs and interactive shells\n- Any app where scrollback is valuable\n- Applications that stream output the user may want to review\n\n**Examples:**\n- Claude Code's tool execution output\n- `npm install` progress that you want to scroll back through\n- Interactive database REPL with query history\n- Build tool output (cargo, make)\n\n**Configuration:**\n```rust\nApp::new(model)\n    .screen_mode(ScreenMode::Inline { ui_height: 4 })\n    .run()\n```\n\n---\n\n### When to Use Alt-Screen Mode\n\n**Use alt-screen mode when:**\n- Building full-screen dashboards (htop, btop)\n- Traditional TUI applications (vim, nano)\n- Modal dialogs and pickers that need full screen\n- When you WANT content gone on exit (games, temporary views)\n- Visual applications where scrollback is meaningless\n\n**Examples:**\n- System monitor dashboard\n- Text editor\n- File manager\n- Interactive game\n- Configuration wizard\n\n**Configuration:**\n```rust\nApp::new(model)\n    .screen_mode(ScreenMode::AltScreen)\n    .run()\n```\n\n---\n\n### Mixed Strategy (Best of Both Worlds)\n\nThe plan supports a hybrid approach: Start in inline mode, temporarily switch to alt-screen for complex modals, then return to inline mode.\n\n**When to use mixed mode:**\n- Agent harness with occasional file picker\n- REPL that needs an interactive editor\n- Log viewer that spawns a detail modal\n\n**Implementation:**\n```rust\n// Start in inline mode\nApp::new(model)\n    .screen_mode(ScreenMode::Inline {\n        ui_height: 6,\n    })\n    .run()\n\n// In update(), when needing full-screen modal:\nfn update(&mut self, msg: Msg) -> Cmd<Msg> {\n    match msg {\n        Msg::OpenFilePicker => {\n            self.mode = Mode::FilePicker;\n            Cmd::enter_alt_screen()\n        }\n        Msg::FilePickerClosed(path) => {\n            self.mode = Mode::Normal;\n            Cmd::batch(vec![\n                Cmd::exit_alt_screen(),\n                Cmd::msg(Msg::FileSelected(path)),\n            ])\n        }\n        // ...\n    }\n}\n```\n\n**What happens:**\n1. App runs in inline mode (scrollback preserved)\n2. User triggers file picker\n3. Switch to alt-screen (full-screen picker UI)\n4. User makes selection\n5. Switch back to inline mode\n6. Scrollback still intact!\n\n---\n\n### Implementation Details\n\n#### Inline Mode Contract\n\n1. **Never clear full screen**\n   - `\\x1b[2J` destroys scrollback\n   - Only clear the UI region\n\n2. **Only clear bounded UI region**\n   - Calculate UI region from bottom\n   - Use EL (erase line) for clearing\n\n3. **Cursor restored after every present()**\n   - Frame::cursor_position specifies target\n   - Presenter handles restoration\n\n4. **Logs enter scrollback naturally**\n   - Print log lines above UI region\n   - Terminal scrolls them into history\n\n#### Alt-Screen Contract\n\n1. **Full-screen clears allowed**\n   - Safe because alt buffer is isolated\n\n2. **Simpler cursor policy**\n   - No anchor calculation needed\n\n3. **Exit restores previous content**\n   - rmcup sequence handles this\n\n4. **Cleanup on panic still required**\n   - Must restore primary screen\n   - RAII guard handles this\n\n---\n\n### Common Mistakes\n\n#### Mistake 1: Full-screen clear in inline mode\n\n```rust\n// WRONG: Destroys scrollback!\nwrite!(stdout, \"\\x1b[2J\")?;\n\n// WRONG: Also destroys scrollback!\nframe.buffer.clear();  // If this issues ED 2\n\n// RIGHT: Clear only the UI region\nfor y in ui_start..ui_end {\n    frame.buffer.set_string(0, y, &\" \".repeat(width), Style::default());\n}\n```\n\n**Why it's wrong:** ESC[2J erases the entire screen, which in inline mode means destroying the scrollback history that makes inline mode valuable.\n\n#### Mistake 2: Assuming scrollback in alt-screen\n\n```rust\n// WRONG assumption: \"The user can scroll back to see logs\"\n// In alt-screen, there IS NO scrollback!\napp.screen_mode(ScreenMode::AltScreen)\n    .run()\n// Logs are gone when app exits\n\n// RIGHT: Use inline mode for log-heavy apps\napp.screen_mode(ScreenMode::Inline { ui_height: 4 })\n    .run()\n// Logs preserved in scrollback\n```\n\n**Why it's wrong:** Alt-screen uses a separate buffer that has no scrollback. When the app exits, everything is gone.\n\n#### Mistake 3: Not handling resize in inline mode\n\n```rust\n// WRONG: Fixed anchor that doesn't update\nlet anchor = 5;  // Assume UI starts at line 5\n\n// RIGHT: Recalculate anchor on resize\nfn on_resize(&mut self, size: Size) {\n    self.anchor = size.height - self.ui_height;\n}\n```\n\n**Why it's wrong:** In inline mode, the UI region anchor is relative to the bottom. When the terminal resizes, the anchor must be recalculated.\n\n#### Mistake 4: Not testing with PTY tests\n\n```rust\n// Easy to miss cursor corruption in manual testing\n// PTY tests catch it automatically\n\n#[test]\nfn test_inline_mode_cursor_contract() {\n    let mut term = TerminalModel::new(80, 24);\n    let app = TestApp::new();\n\n    app.render(&mut term);\n\n    // Cursor should be at input line, not corrupted\n    assert_eq!(term.cursor_position(), (2, 23));\n}\n```\n\n---\n\n### Debugging Screen Mode Issues\n\n#### Symptom: Scrollback lost on exit\n\n**Cause:** Using alt-screen when inline mode was intended.\n**Fix:** Change to `ScreenMode::Inline { ui_height: N }`.\n\n#### Symptom: Cursor jumps around\n\n**Cause:** Writing to terminal outside present() cycle.\n**Fix:** Ensure all output goes through ftui runtime.\n\n#### Symptom: UI region flickers\n\n**Cause:** Clearing too much on each frame.\n**Fix:** Only redraw changed cells (presenter handles this).\n\n#### Symptom: Logs overwrite UI\n\n**Cause:** UI height not properly configured.\n**Fix:** Set `ui_height` to match your actual UI region height.\n\n---\n\n## Acceptance Criteria\n\n- [ ] Both modes clearly explained with diagrams\n- [ ] Trade-off matrix complete and accurate\n- [ ] Use cases documented with examples\n- [ ] Mixed strategy explained with code\n- [ ] Common mistakes listed with WRONG/RIGHT examples\n- [ ] Debugging section for troubleshooting\n- [ ] Links to related ADR (ADR-001)\n- [ ] Code examples compile\n\n---\n\n## Location\n`docs/concepts/screen-modes.md`","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T22:51:24.590650257Z","created_by":"ubuntu","updated_at":"2026-02-01T00:37:57.159514968Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1u5","depends_on_id":"bd-10i.10.1","type":"blocks","created_at":"2026-01-31T22:53:59.302413752Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1u5","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:08:56.181870468Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1u5","depends_on_id":"bd-fbp","type":"blocks","created_at":"2026-02-01T00:37:57.159479622Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1un","title":"Document Terminal Compatibility Matrix","description":"# Terminal Compatibility Matrix Documentation\n\n## Background\nPlan Chapter 16 provides a detailed compatibility matrix. This needs to be documented for users to understand what features work where.\n\n## Compatibility Matrix (from Plan)\n\n| Feature | Kitty | WezTerm | Alacritty | Ghostty | iTerm2 | GNOME Term | Win Term |\n|---------|-------|---------|-----------|---------|--------|------------|----------|\n| True Color | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |\n| Sync Output | ✓ | ✓ | ✓ | ✓ | ✗ | ✗ | ✗ |\n| OSC 8 Links | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✗ |\n| Kitty Keyboard | ✓ | ✓ | ✗ | ✓ | ✗ | ✗ | ✗ |\n| Kitty Graphics | ✓ | ✓ | ✗ | ✓ | ✗ | ✗ | ✗ |\n| Sixel | ✗ | ✓ | ✗ | ✗ | ✓ | ✗ | ✗ |\n| Focus Events | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |\n| Bracketed Paste | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |\n\n## Feature Details\n\n### True Color (24-bit RGB)\n- Detection: COLORTERM=truecolor or COLORTERM=24bit\n- Fallback: 256-color or 16-color palette\n- Most modern terminals support this\n\n### Synchronized Output (DEC 2026)\n- Purpose: Atomic frame updates, flicker prevention\n- Detection: Known terminal identification\n- Fallback: Buffered writes still help\n- ftui activates when detected\n\n### OSC 8 Hyperlinks\n- Purpose: Clickable links in terminal\n- Format: `\\x1b]8;;URL\\x1b\\\\text\\x1b]8;;\\x1b\\\\`\n- Windows Terminal: Not supported\n- Most Linux/macOS terminals support\n\n### Kitty Keyboard Protocol\n- Purpose: Enhanced key event information\n- Provides: press/repeat/release, modifiers\n- Limited adoption outside Kitty ecosystem\n- Feature-gated in ftui\n\n### Scroll Region (DECSTBM)\n- Purpose: Inline mode optimization\n- Support: Nearly universal\n- Quirks: tmux/screen passthrough issues\n- ftui uses as optimization, not requirement\n\n## Multiplexer Notes\n\n### tmux\n- Passthrough: Requires `\\x1bPtmux;...\\x1b\\\\`\n- Sync output: Blocked by default\n- OSC 8: Needs recent version + config\n- Detection: TMUX env var\n\n### screen\n- Limited modern feature support\n- No sync output passthrough\n- Basic ANSI works fine\n- Detection: STY env var\n\n### Zellij\n- Better passthrough than tmux/screen\n- Native terminal support varies\n- Detection: ZELLIJ env var\n\n## Windows Considerations\n\n### Windows Terminal\n- True color: ✓\n- Mouse: ✓\n- OSC 8: ✗\n- Sync output: ✗\n- Raw mode: Via Crossterm\n\n### ConEmu/Cmder\n- Limited feature set\n- True color: ✓ (newer versions)\n- ANSI support varies by version\n\n### cmd.exe / PowerShell (legacy)\n- Very limited ANSI support\n- Windows 10+ improved support\n- Use Windows Terminal for best experience\n\n## Inline Mode Notes\n- Works everywhere (no special requirements)\n- Cursor save/restore: Universal\n- Scroll region: Nearly universal (optimization only)\n- Sync output: Nice-to-have (not required)\n\n## Recommended Test Matrix\nFor CI, test against:\n1. Kitty (most features)\n2. WezTerm (cross-platform)\n3. Alacritty (popular, minimal)\n4. Plain Linux VT (baseline)\n\n## Acceptance Criteria\n- [ ] Matrix table documented\n- [ ] Feature descriptions complete\n- [ ] Multiplexer notes included\n- [ ] Windows section clear\n- [ ] Inline mode notes present\n- [ ] Test matrix recommended\n\n## Location: docs/reference/terminal-compatibility.md","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T22:53:27.385131349Z","created_by":"ubuntu","updated_at":"2026-01-31T23:18:24.100429484Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1un","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:08:47.553758638Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1un","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T22:53:59.665227292Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1un","depends_on_id":"bd-2ss","type":"blocks","created_at":"2026-01-31T23:18:24.100392965Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1xo","title":"Windows Terminal compatibility layer","description":"PHASE 7 - POLISH: WINDOWS SUPPORT\n\n## Background\nWindows Terminal v1 support is deferred but must have clear integration path. Modern Windows Terminal supports ANSI, older conhost needs different handling.\n\n## Technical Requirements (v1 Scope - Windows Terminal Only)\n- Detect Windows Terminal vs legacy conhost\n- Enable VT processing mode via SetConsoleMode\n- Handle Windows-specific escape sequences\n- PTY spawning via ConPTY API\n- Signal handling differences (Ctrl+C, Ctrl+Break)\n- Path handling for Windows conventions\n\n## Out of Scope for v1\n- Legacy conhost support (Windows 7/8)\n- PowerShell-specific handling\n- Windows-specific widgets\n\n## Design Rationale\nPer ADR-004, Windows v1 targets modern Windows Terminal only. This dramatically simplifies implementation while covering majority of Windows developer use.\n\n## Acceptance Criteria\n- [ ] Windows Terminal detection\n- [ ] VT mode enabling\n- [ ] ConPTY integration for PTY tests\n- [ ] Signal handling shim\n- [ ] CI testing on Windows\n- [ ] Feature gate: windows\n\n## Testing\n- GitHub Actions Windows runner\n- Manual testing on Windows Terminal\n- Document known limitations\n\n## Location: ftui-render crate + ftui-pty crate (platform-specific code)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:20:16.533908639Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:36.112222Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1xo","depends_on_id":"bd-10i.10.4","type":"blocks","created_at":"2026-01-31T22:22:36.112191833Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1xo","depends_on_id":"bd-10i.8.1","type":"blocks","created_at":"2026-01-31T22:22:35.870315746Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-1zv","title":"Implement event coalescing and RAII terminal guard","description":"PHASE 3 - EVENT COALESCING + TERMINAL GUARD\n\n## Background\nEvent storms (mouse moves, resize spam) can overwhelm the runtime. RAII guards ensure terminal cleanup even on panic.\n\n## Technical Requirements\n\n### Event Coalescing\npub struct EventCoalescer {\n    pending_mouse_move: Option<MouseEvent>,\n    pending_resize: Option<(u16, u16)>,\n    coalesce_window_ms: u64,\n}\n\nimpl EventCoalescer {\n    /// Add event, returns coalesced event if ready\n    pub fn push(&mut self, event: Event) -> Option<Event> {\n        match event {\n            Event::Mouse(MouseEvent::Move { .. }) => {\n                // Replace pending, return only on next non-move\n                self.pending_mouse_move = Some(event);\n                None\n            }\n            Event::Resize(w, h) => {\n                // Keep latest resize\n                self.pending_resize = Some((w, h));\n                None\n            }\n            _ => {\n                // Flush pending events, then return this one\n                self.flush_pending();\n                Some(event)\n            }\n        }\n    }\n    \n    pub fn flush_pending(&mut self) -> Vec<Event> { ... }\n}\n\n### RAII Terminal Guard\n\npub struct TerminalGuard {\n    raw_mode: bool,\n    alt_screen: bool,\n    mouse_capture: bool,\n    bracketed_paste: bool,\n    cursor_hidden: bool,\n}\n\nimpl TerminalGuard {\n    pub fn new() -> io::Result<Self> {\n        // Install panic hook\n        let prev_hook = std::panic::take_hook();\n        std::panic::set_hook(Box::new(move |info| {\n            // Restore terminal state\n            let _ = disable_raw_mode();\n            let _ = execute\\!(stdout(), LeaveAlternateScreen, Show);\n            prev_hook(info);\n        }));\n        \n        Ok(Self { ... })\n    }\n    \n    pub fn enable_raw_mode(&mut self) -> io::Result<()> { ... }\n    pub fn enter_alt_screen(&mut self) -> io::Result<()> { ... }\n    pub fn enable_mouse_capture(&mut self) -> io::Result<()> { ... }\n    pub fn enable_bracketed_paste(&mut self) -> io::Result<()> { ... }\n    pub fn hide_cursor(&mut self) -> io::Result<()> { ... }\n}\n\nimpl Drop for TerminalGuard {\n    fn drop(&mut self) {\n        // Restore all state in reverse order\n        if self.cursor_hidden {\n            let _ = execute\\!(stdout(), Show);\n        }\n        if self.bracketed_paste {\n            let _ = execute\\!(stdout(), DisableBracketedPaste);\n        }\n        if self.mouse_capture {\n            let _ = execute\\!(stdout(), DisableMouseCapture);\n        }\n        if self.alt_screen {\n            let _ = execute\\!(stdout(), LeaveAlternateScreen);\n        }\n        if self.raw_mode {\n            let _ = disable_raw_mode();\n        }\n    }\n}\n\n## Tests Required\n- [ ] Mouse move coalescing works\n- [ ] Resize coalescing works\n- [ ] Key events pass through\n- [ ] Guard enables/disables correctly\n- [ ] Drop restores all state\n- [ ] Panic hook restores terminal\n- [ ] PTY test: panic cleanup\n\n## Acceptance Criteria\n- [ ] No event storms reach runtime\n- [ ] Terminal always restored on exit\n- [ ] Panic leaves terminal usable\n- [ ] Nested guards work correctly\n- [ ] Mouse flood doesn't cause lag\n\n## Location: ftui-core crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:31:28.569809686Z","created_by":"ubuntu","updated_at":"2026-02-01T00:25:16.254273149Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1zv","depends_on_id":"bd-10i.2.4","type":"blocks","created_at":"2026-01-31T22:32:19.954339136Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-1zv","depends_on_id":"bd-3ky.10","type":"blocks","created_at":"2026-02-01T00:25:16.254237572Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-22q","title":"Implement Theme system with semantic color slots","description":"PHASE 4 - THEME SYSTEM\n\n## Background\nA Theme provides semantic color slots that map to actual colors. This enables consistent styling and easy theme switching (light/dark mode, custom themes).\n\n## Technical Requirements\n\n### Semantic Color Slots\npub struct Theme {\n    // Primary UI\n    pub primary: AdaptiveColor,\n    pub secondary: AdaptiveColor,\n    pub accent: AdaptiveColor,\n    \n    // Backgrounds\n    pub background: AdaptiveColor,\n    pub surface: AdaptiveColor,\n    pub overlay: AdaptiveColor,\n    \n    // Text\n    pub text: AdaptiveColor,\n    pub text_muted: AdaptiveColor,\n    pub text_subtle: AdaptiveColor,\n    \n    // Semantic\n    pub success: AdaptiveColor,\n    pub warning: AdaptiveColor,\n    pub error: AdaptiveColor,\n    pub info: AdaptiveColor,\n    \n    // Borders\n    pub border: AdaptiveColor,\n    pub border_focused: AdaptiveColor,\n    \n    // Selection\n    pub selection_bg: AdaptiveColor,\n    pub selection_fg: AdaptiveColor,\n    \n    // Scrollbar\n    pub scrollbar_track: AdaptiveColor,\n    pub scrollbar_thumb: AdaptiveColor,\n}\n\n### Adaptive Colors\npub enum AdaptiveColor {\n    Fixed(Color),\n    Adaptive { light: Color, dark: Color },\n}\n\nimpl AdaptiveColor {\n    pub fn resolve(&self, is_dark: bool) -> Color {\n        match self {\n            Self::Fixed(c) => *c,\n            Self::Adaptive { light, dark } => {\n                if is_dark { *dark } else { *light }\n            }\n        }\n    }\n}\n\n### Built-in Theme Presets\npub mod themes {\n    pub fn default() -> Theme;      // Sensible defaults\n    pub fn dark() -> Theme;         // Dark mode\n    pub fn light() -> Theme;        // Light mode\n    pub fn nord() -> Theme;         // Nord color scheme\n    pub fn dracula() -> Theme;      // Dracula colors\n    pub fn solarized_dark() -> Theme;\n    pub fn solarized_light() -> Theme;\n}\n\n### Theme Detection\nimpl Theme {\n    /// Detect dark mode from environment/terminal\n    pub fn detect_dark_mode() -> bool {\n        // Check COLORFGBG for light/dark background\n        // Check OSC 11 background query (if supported)\n        // Default: assume dark\n    }\n}\n\n### Theme Resolution\nWidgets reference theme colors:\n  let style = Style::new().fg(theme.text).bg(theme.surface);\n\n### Runtime Theme Switching\n- Theme stored in Context or Model\n- All widgets receive theme reference\n- Switching triggers full redraw\n\n## Tests Required\n- [ ] All semantic slots have sensible defaults\n- [ ] Adaptive color resolution correct\n- [ ] Built-in presets complete\n- [ ] Dark mode detection works\n- [ ] Theme switching triggers redraw\n\n## Acceptance Criteria\n- [ ] 15+ semantic color slots\n- [ ] Light/dark adaptive colors\n- [ ] 5+ built-in presets\n- [ ] Detection heuristics\n- [ ] Theme switching API\n\n## Location: ftui-style crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:36:27.593131757Z","created_by":"ubuntu","updated_at":"2026-01-31T22:37:55.391526944Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-22q","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T22:37:54.786191489Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-22q","depends_on_id":"bd-1f8","type":"blocks","created_at":"2026-01-31T22:37:55.391498921Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-22q","depends_on_id":"bd-2yd","type":"blocks","created_at":"2026-01-31T22:37:55.103509558Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-27v","title":"Implement Subscriptions and async command integration","description":"PHASE 6 - SUBSCRIPTIONS + ASYNC\n\n## Background\nSubscriptions provide continuous event sources (timers, file watchers, network). Async integration allows non-blocking operations without blocking the UI.\n\n## Technical Requirements\n\n### Subscription System\n\npub trait Subscription<M> {\n    /// Unique ID for deduplication\n    fn id(&self) -> SubId;\n    \n    /// Start producing messages\n    fn start(&self, sender: mpsc::Sender<M>);\n    \n    /// Stop producing messages\n    fn stop(&self);\n}\n\npub type SubId = u64;\n\n// Built-in subscriptions\npub mod subscriptions {\n    /// Tick at fixed interval\n    pub fn every<M: From<Tick>>(duration: Duration) -> impl Subscription<M>;\n    \n    /// File system watcher\n    pub fn watch_file<M: From<FileEvent>>(path: PathBuf) -> impl Subscription<M>;\n    \n    /// Window resize events\n    pub fn window_resize<M: From<Resize>>() -> impl Subscription<M>;\n    \n    /// Focus change events\n    pub fn focus<M: From<Focus>>() -> impl Subscription<M>;\n}\n\n### Model Integration\npub trait Model: Sized {\n    type Message;\n    \n    // Existing\n    fn update(&mut self, msg: Self::Message) -> Cmd<Self::Message>;\n    fn view(&self, frame: &mut Frame);\n    \n    // New: declare active subscriptions\n    fn subscriptions(&self) -> Vec<Box<dyn Subscription<Self::Message>>> {\n        vec![]  // Default: no subscriptions\n    }\n}\n\n### Subscription Lifecycle\nThe runtime:\n1. Calls model.subscriptions() after each update\n2. Compares with previous subscriptions by id()\n3. Starts new subscriptions\n4. Stops removed subscriptions\n5. Routes subscription messages to update()\n\n### Async Commands (Feature: async)\n\n#[cfg(feature = \"async\")]\npub enum Cmd<M> {\n    // Existing...\n    \n    /// Execute async operation\n    Async(BoxFuture<'static, M>),\n    \n    /// Execute blocking operation on threadpool\n    Blocking(Box<dyn FnOnce() -> M + Send + 'static>),\n}\n\n#[cfg(feature = \"async\")]\nimpl<M: Send + 'static> Cmd<M> {\n    pub fn async_fn<F, Fut>(f: F) -> Self\n    where\n        F: FnOnce() -> Fut + Send + 'static,\n        Fut: Future<Output = M> + Send + 'static,\n    {\n        Cmd::Async(Box::pin(async move { f().await }))\n    }\n    \n    pub fn blocking<F>(f: F) -> Self\n    where\n        F: FnOnce() -> M + Send + 'static,\n    {\n        Cmd::Blocking(Box::new(f))\n    }\n}\n\n### Async Runtime Integration\n\n#[cfg(feature = \"tokio\")]\npub struct TokioRuntime { ... }\n\n#[cfg(feature = \"async-std\")]\npub struct AsyncStdRuntime { ... }\n\n// Default: simple threadpool\npub struct ThreadPoolRuntime { ... }\n\n### Deterministic Simulator Compatibility\nSubscriptions must be mockable for testing:\n\npub struct MockSubscription<M> {\n    id: SubId,\n    events: Vec<M>,\n}\n\nimpl<M> Subscription<M> for MockSubscription<M> {\n    fn start(&self, sender: mpsc::Sender<M>) {\n        for msg in &self.events {\n            sender.send(msg.clone()).ok();\n        }\n    }\n}\n\n## Tests Required\n- [ ] Subscription start/stop lifecycle\n- [ ] Subscription deduplication by id\n- [ ] Tick subscription fires correctly\n- [ ] Async command executes\n- [ ] Blocking command on threadpool\n- [ ] Simulator with mock subscriptions\n- [ ] Tokio integration (if feature enabled)\n\n## Acceptance Criteria\n- [ ] Subscription trait defined\n- [ ] Built-in tick subscription\n- [ ] Model.subscriptions() integration\n- [ ] Async Cmd variant (feature-gated)\n- [ ] Threadpool runtime (default)\n- [ ] Tokio runtime (optional)\n- [ ] Simulator compatibility\n\n## Location: ftui-runtime crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:37:23.370393170Z","created_by":"ubuntu","updated_at":"2026-01-31T22:37:56.300717577Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-27v","depends_on_id":"bd-10i.8.2","type":"blocks","created_at":"2026-01-31T22:37:56.300686949Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-29v","title":"Implement Viewport/LogViewer widget (agent harness essential)","description":"# Implement Viewport/LogViewer Widget (Agent Harness Essential)\n\n## Background & Strategic Importance\nThe Viewport/LogViewer is THE ESSENTIAL widget for agent harness UIs (Plan 12.4). It displays streaming logs with scrollback while maintaining UI chrome. This is the primary use case for FrankenTUI - Claude Code / Codex-style agent harness displays require a log viewer that:\n1. Accepts high-frequency log line additions without flicker\n2. Maintains auto-scroll behavior for \"follow\" mode\n3. Allows manual scrolling to inspect history\n4. Respects memory bounds via circular buffer\n5. Integrates with inline mode's scrollback preservation\n\n## Why This Is P1, Not P2\nThe plan (Section 12.4) explicitly states: \"Viewport/Log Viewer Widget\" is an \"agent harness essential\". Without this widget, the entire agent harness use case is blocked.\n\n---\n\n## Technical Design\n\n### Core Data Structure\n\n```rust\nuse std::collections::VecDeque;\nuse tracing::{debug, trace, instrument};\n\n/// A scrolling log viewer optimized for streaming append-only content.\n///\n/// # Design Rationale\n/// - VecDeque for O(1) push/pop at both ends (circular buffer eviction)\n/// - Separate scroll_offset from auto_scroll flag for manual override\n/// - wrap_mode configurable per-instance for different use cases\n/// - Stateful widget pattern for scroll state preservation across renders\npub struct LogViewer {\n    /// Log lines stored as styled Text (supports colors, hyperlinks)\n    lines: VecDeque<Text>,\n    /// Maximum lines to retain (memory bound)\n    max_lines: usize,\n    /// Current scroll offset from bottom (0 = bottom)\n    scroll_offset: usize,\n    /// Auto-scroll enabled (re-engages when scrolled to bottom)\n    auto_scroll: bool,\n    /// Line wrapping mode\n    wrap_mode: WrapMode,\n    /// Default style for lines\n    style: Style,\n    /// Highlight style for selected/focused line\n    highlight_style: Option<Style>,\n}\n\n#[derive(Clone, Copy, Debug, Default)]\npub enum WrapMode {\n    /// No wrapping, truncate long lines\n    #[default]\n    NoWrap,\n    /// Wrap at any character boundary\n    CharWrap,\n    /// Wrap at word boundaries (Unicode-aware)\n    WordWrap,\n}\n\n/// Separate state for StatefulWidget pattern\npub struct LogViewerState {\n    /// Viewport height from last render (for page up/down)\n    last_viewport_height: u16,\n    /// Total visible line count from last render\n    last_visible_lines: usize,\n    /// Selected line index (for copy/selection features)\n    selected_line: Option<usize>,\n}\n```\n\n### Public API\n\n```rust\nimpl LogViewer {\n    /// Create a new LogViewer with specified max line capacity.\n    ///\n    /// # Arguments\n    /// * `max_lines` - Maximum lines to retain. When exceeded, oldest lines\n    ///   are evicted. Recommend 10,000-100,000 for typical agent use cases.\n    pub fn new(max_lines: usize) -> Self {\n        debug!(max_lines, \"Creating LogViewer\");\n        Self {\n            lines: VecDeque::with_capacity(max_lines.min(1024)),\n            max_lines,\n            scroll_offset: 0,\n            auto_scroll: true,\n            wrap_mode: WrapMode::NoWrap,\n            style: Style::default(),\n            highlight_style: None,\n        }\n    }\n\n    /// Append a single log line.\n    ///\n    /// # Performance\n    /// - O(1) amortized for append\n    /// - O(1) for eviction when at capacity\n    ///\n    /// # Auto-scroll Behavior\n    /// If auto_scroll is enabled, view stays at bottom after push.\n    #[instrument(skip(self, line), fields(line_count = self.lines.len()))]\n    pub fn push(&mut self, line: impl Into<Text>) {\n        let line = line.into();\n        trace!(\"Pushing log line\");\n\n        // Evict oldest if at capacity\n        if self.lines.len() >= self.max_lines {\n            self.lines.pop_front();\n            trace!(\"Evicted oldest line (at max_lines capacity)\");\n        }\n\n        self.lines.push_back(line);\n\n        // Auto-scroll: keep view at bottom\n        if self.auto_scroll {\n            self.scroll_offset = 0;\n        }\n    }\n\n    /// Append multiple lines efficiently.\n    pub fn push_many(&mut self, lines: impl IntoIterator<Item = impl Into<Text>>);\n\n    /// Scroll up by N lines. Disables auto-scroll.\n    pub fn scroll_up(&mut self, lines: usize);\n\n    /// Scroll down by N lines. Re-enables auto-scroll if at bottom.\n    pub fn scroll_down(&mut self, lines: usize);\n\n    /// Jump to top of log history.\n    pub fn scroll_to_top(&mut self);\n\n    /// Jump to bottom and re-enable auto-scroll.\n    pub fn scroll_to_bottom(&mut self);\n\n    /// Page up (scroll by viewport height).\n    pub fn page_up(&mut self, state: &LogViewerState);\n\n    /// Page down (scroll by viewport height).\n    pub fn page_down(&mut self, state: &LogViewerState);\n\n    /// Check if currently scrolled to the bottom.\n    pub fn is_at_bottom(&self) -> bool;\n\n    /// Total line count in buffer.\n    pub fn line_count(&self) -> usize;\n}\n```\n\n### Rendering Implementation\n\n```rust\nimpl StatefulWidget for LogViewer {\n    type State = LogViewerState;\n\n    #[instrument(skip(self, area, buf, state), fields(\n        area.width = area.width,\n        area.height = area.height,\n        line_count = self.lines.len(),\n        scroll_offset = self.scroll_offset\n    ))]\n    fn render(&self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        // Update state with current viewport info\n        state.last_viewport_height = area.height;\n\n        // Calculate visible range (scroll_offset=0 means newest at bottom)\n        let visible_count = area.height as usize;\n        let total_lines = self.lines.len();\n        let end_idx = total_lines.saturating_sub(self.scroll_offset);\n        let start_idx = end_idx.saturating_sub(visible_count);\n\n        trace!(start_idx, end_idx, visible_count, \"Calculated visible range\");\n\n        // Render visible lines with wrap mode\n        for (row_offset, line_idx) in (start_idx..end_idx).enumerate() {\n            let y = area.y + row_offset as u16;\n            let line = &self.lines[line_idx];\n            self.render_line(line, area.x, y, area.width, buf);\n        }\n\n        // Render scroll indicator if not at bottom\n        if self.scroll_offset > 0 && area.width >= 4 {\n            let indicator = format!(\" ↓{} \", self.scroll_offset);\n            buf.set_string(area.x + area.width - indicator.len() as u16,\n                area.y + area.height - 1, &indicator, Style::default().bg(Color::DarkGray));\n        }\n    }\n}\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests (ftui-widgets/src/log_viewer/tests.rs)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tracing_test::traced_test;\n\n    #[traced_test]\n    #[test]\n    fn test_push_appends_to_end() {\n        let mut log = LogViewer::new(100);\n        log.push(\"line 1\");\n        log.push(\"line 2\");\n        assert_eq!(log.line_count(), 2);\n        assert!(logs_contain(\"Pushing log line\"));\n    }\n\n    #[traced_test]\n    #[test]\n    fn test_circular_buffer_eviction() {\n        let mut log = LogViewer::new(3);\n        log.push(\"line 1\");\n        log.push(\"line 2\");\n        log.push(\"line 3\");\n        log.push(\"line 4\");  // Should evict \"line 1\"\n        assert_eq!(log.line_count(), 3);\n        assert!(logs_contain(\"Evicted oldest line\"));\n    }\n\n    #[test]\n    fn test_auto_scroll_stays_at_bottom() {\n        let mut log = LogViewer::new(100);\n        log.push(\"line 1\");\n        assert!(log.is_at_bottom());\n        log.push(\"line 2\");\n        assert!(log.is_at_bottom());\n    }\n\n    #[test]\n    fn test_manual_scroll_disables_auto_scroll() {\n        let mut log = LogViewer::new(100);\n        for i in 0..50 { log.push(format!(\"line {}\", i)); }\n        log.scroll_up(10);\n        assert!(!log.is_at_bottom());\n        log.push(\"new line\");\n        assert!(!log.is_at_bottom()); // Still scrolled up\n    }\n\n    #[test]\n    fn test_scroll_to_bottom_reengages_auto_scroll() {\n        let mut log = LogViewer::new(100);\n        for i in 0..50 { log.push(format!(\"line {}\", i)); }\n        log.scroll_up(10);\n        log.scroll_to_bottom();\n        assert!(log.is_at_bottom());\n    }\n\n    #[test]\n    fn test_wide_character_handling() {\n        let mut log = LogViewer::new(100);\n        log.push(\"Hello 世界！\");  // Contains wide characters\n        // Should not panic or misalign\n    }\n}\n```\n\n### Performance Tests\n\n```rust\n#[test]\nfn test_10k_lines_performance() {\n    let mut log = LogViewer::new(10_000);\n    let start = Instant::now();\n    for i in 0..10_000 {\n        log.push(format!(\"Log line {} with some content\", i));\n    }\n    assert!(start.elapsed().as_millis() < 100, \"Push should be < 100ms for 10k lines\");\n\n    // Render should be O(visible_lines)\n    let area = Rect::new(0, 0, 120, 40);\n    let mut buf = Buffer::empty(area);\n    let mut state = LogViewerState::default();\n    let start = Instant::now();\n    for _ in 0..60 { log.render(area, &mut buf, &mut state); }\n    assert!(start.elapsed().as_secs() < 1, \"60 renders should be < 1 second\");\n}\n```\n\n---\n\n## Acceptance Criteria\n\n### Functional\n- [ ] Lines can be appended via push() and push_many()\n- [ ] Circular buffer evicts oldest lines when at max_lines\n- [ ] Auto-scroll keeps view at bottom when enabled\n- [ ] Manual scroll (up/down/page) works correctly\n- [ ] Scroll indicator shows when not at bottom\n- [ ] Wide characters (emoji, CJK) render correctly\n- [ ] Line wrapping modes work (NoWrap, CharWrap, WordWrap)\n\n### Performance\n- [ ] Push is O(1) amortized\n- [ ] Render is O(visible_lines), not O(total_lines)\n- [ ] Can handle 10k+ lines without lag\n- [ ] 60 FPS scroll at 100k lines\n\n### Integration\n- [ ] Works with inline mode\n- [ ] Works with alt-screen mode\n- [ ] No flicker during rapid append\n- [ ] Scrollback preserved in inline mode\n\n### Logging\n- [ ] debug! for creation, scroll operations\n- [ ] trace! for per-line operations (push, render)\n- [ ] instrument on render() with area/line_count/scroll_offset fields\n\n---\n\n## Location\n`ftui-widgets/src/widgets/log_viewer.rs`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:30:56.602503037Z","created_by":"ubuntu","updated_at":"2026-02-01T00:33:18.727615193Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-29v","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:32:18.860423343Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-29v","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:32:19.142899265Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-29v","depends_on_id":"bd-3ky.14","type":"blocks","created_at":"2026-02-01T00:33:18.727577221Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-29v","depends_on_id":"bd-wr2","type":"blocks","created_at":"2026-01-31T22:32:19.404932654Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2a5","title":"API documentation and examples suite","description":"PHASE 7 - POLISH: DOCUMENTATION\n\n## Background\nComprehensive documentation is essential for library adoption. Must include API docs, guides, and runnable examples covering all major use cases.\n\n## Technical Requirements\n\n### API Documentation\n- All public types documented with /// comments\n- Module-level documentation with usage examples\n- Cross-linking between related types\n- Platform-specific behavior documented\n- Feature flag documentation\n- Safety documentation for any unsafe code\n\n### Examples Suite\n- examples/hello.rs - Minimal 'Hello World'\n- examples/counter.rs - Basic state management\n- examples/input.rs - Text input handling\n- examples/layout.rs - Flex/Grid layouts\n- examples/styling.rs - Themes and styles\n- examples/table.rs - Data tables\n- examples/async.rs - Async runtime integration\n- examples/inline.rs - Inline mode demo\n\n### Guide Documentation\n- Getting Started guide\n- Architecture overview\n- Migration guide from Ratatui\n- Performance tuning guide\n- Testing guide\n\n## Design Rationale\nDocumentation is a feature. Examples serve as both learning resources and regression tests. Keeping docs close to code via rustdoc ensures accuracy.\n\n## Acceptance Criteria\n- [ ] 100% public API documented\n- [ ] All examples compile and run\n- [ ] Examples cover each major widget\n- [ ] Guide for each major topic\n- [ ] docs.rs badge in README\n- [ ] Changelog maintained\n\n## Location: Workspace-wide + docs/ directory","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:20:27.193051613Z","created_by":"ubuntu","updated_at":"2026-01-31T23:09:01.118650824Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2a5","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:09:01.118613093Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2a5","depends_on_id":"bd-10i.8.3","type":"blocks","created_at":"2026-01-31T22:22:36.366148400Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2a5","depends_on_id":"bd-3k4","type":"blocks","created_at":"2026-01-31T22:22:36.625930213Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ao","title":"Implement Kitty keyboard protocol support (optional)","description":"# Implement Kitty Keyboard Protocol Support (Optional)\n\n## Background\nThe plan mentions Kitty keyboard protocol in TerminalCapabilities detection and ADR-004. This is an optional enhancement that provides richer key event information.\n\n## What Kitty Keyboard Protocol Provides\n- Distinguish key press vs repeat vs release\n- Modifier key events (Shift pressed, Shift released)\n- Proper handling of key combinations\n- Unicode codepoint of key\n- Alternate key representations\n\n## Why It's Optional (P3)\n- Only supported by Kitty, WezTerm, Ghostty, foot\n- Traditional CSI sequences cover most use cases\n- Additional complexity for marginal benefit\n- Feature-gated to avoid bloating core\n\n## Technical Design\n\n### Detection\n```rust\nimpl TerminalCapabilities {\n    pub fn detect() -> Self {\n        // ...\n        let kitty_keyboard = term.contains(\"kitty\") ||\n            std::env::var(\"KITTY_WINDOW_ID\").is_ok() ||\n            // Could also detect WezTerm, Ghostty\n            false;\n    }\n}\n```\n\n### Protocol Activation\n```rust\nimpl TerminalSession {\n    pub fn enable_kitty_keyboard(&mut self) -> io::Result<()> {\n        // CSI > flags u\n        // flags: 0b1111 = disambiguate + report event types + report alternate keys + report all keys\n        self.writer.write_all(b\"\\x1b[>15u\")?;\n        self.kitty_keyboard_active = true;\n        Ok(())\n    }\n    \n    pub fn disable_kitty_keyboard(&mut self) -> io::Result<()> {\n        // CSI < u - pop keyboard mode\n        self.writer.write_all(b\"\\x1b[<u\")?;\n        self.kitty_keyboard_active = false;\n        Ok(())\n    }\n}\n```\n\n### Enhanced Event Type\n```rust\npub struct KeyEvent {\n    pub code: KeyCode,\n    pub modifiers: Modifiers,\n    pub kind: KeyEventKind,  // Press, Repeat, Release\n    // Kitty-only extensions:\n    pub base_codepoint: Option<char>,\n    pub shifted_key: Option<char>,\n}\n\npub enum KeyEventKind {\n    Press,   // Key pressed\n    Repeat,  // Key held down (auto-repeat)\n    Release, // Key released\n}\n```\n\n### Parser Extension\n```rust\nimpl InputParser {\n    fn parse_kitty_key(&mut self, seq: &[u8]) -> Option<Event> {\n        // CSI unicode-codepoint ; modifiers ; event-type u\n        // Parse the enhanced sequence\n        // ...\n    }\n}\n```\n\n## Graceful Degradation\n- If Kitty protocol not available, fall back to standard CSI\n- KeyEventKind defaults to Press\n- Optional fields are None for legacy input\n\n## Tests Required\n- [ ] Detection works for Kitty terminal\n- [ ] Protocol activation/deactivation\n- [ ] Parse enhanced key sequences\n- [ ] Modifier key press/release events\n- [ ] Graceful fallback when not supported\n- [ ] RAII cleanup on exit\n\n## Acceptance Criteria\n- [ ] Feature-gated behind `kitty-keyboard` feature\n- [ ] Detection in TerminalCapabilities\n- [ ] Activation/deactivation in TerminalSession\n- [ ] Enhanced KeyEvent fields\n- [ ] Parser handles Kitty sequences\n- [ ] Falls back gracefully\n- [ ] Documented in compatibility matrix\n\n## Location: ftui-core crate (feature-gated)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:51:45.755970711Z","created_by":"ubuntu","updated_at":"2026-01-31T22:54:04.314450237Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ao","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:54:04.314419139Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2dc","title":"Implement Status Line and Panel widgets","description":"PHASE 5 - STATUS LINE + PANEL WIDGETS\n\n## Background\nStatus lines and panels are essential for agent harness UIs. Status line shows current mode/status. Panel provides structured chrome around content areas.\n\n## Technical Requirements\n\n### Status Line Widget\n\npub struct StatusLine<'a> {\n    left: Vec<StatusItem<'a>>,\n    center: Vec<StatusItem<'a>>,\n    right: Vec<StatusItem<'a>>,\n    style: Style,\n    separator: &'a str,\n}\n\npub enum StatusItem<'a> {\n    Text(Text<'a>),\n    Spinner(SpinnerState),\n    Progress { current: u64, total: u64 },\n    KeyHint { key: &'a str, action: &'a str },\n    Spacer,\n}\n\nimpl StatusLine<'_> {\n    pub fn left(mut self, item: StatusItem) -> Self;\n    pub fn center(mut self, item: StatusItem) -> Self;\n    pub fn right(mut self, item: StatusItem) -> Self;\n}\n\n// Typical usage\nStatusLine::new()\n    .left(StatusItem::Text(\"[INSERT]\".into()))\n    .center(StatusItem::Text(\"file.rs\".into()))\n    .right(StatusItem::KeyHint { key: \"^C\", action: \"Quit\" })\n    .right(StatusItem::Text(\"Ln 42, Col 10\".into()))\n\n### Panel Widget\n\npub struct Panel<'a> {\n    title: Option<Title<'a>>,\n    content: Box<dyn Widget + 'a>,\n    footer: Option<Text<'a>>,\n    border_style: BorderStyle,\n    focus_style: Option<Style>,\n    focused: bool,\n}\n\nimpl Panel<'_> {\n    pub fn new(content: impl Widget) -> Self;\n    pub fn title(mut self, title: impl Into<Title>) -> Self;\n    pub fn footer(mut self, footer: impl Into<Text>) -> Self;\n    pub fn focused(mut self, focused: bool) -> Self;\n}\n\n### Layout Integration\nPanels work with Flex/Grid:\n\nFlex::vertical()\n    .add(Panel::new(log_viewer).title(\"Logs\").flex(1.0))\n    .add(Panel::new(input).title(\"Command\").height(3))\n    .add(StatusLine::new()...)\n\n### Focus Management\n- focused property changes border style\n- Tab navigation between panels (runtime handles)\n- Focus indicator (optional marker)\n\n## Tests Required\n- [ ] StatusLine left/center/right positioning\n- [ ] StatusLine separator rendering\n- [ ] StatusLine truncation behavior\n- [ ] Panel border rendering\n- [ ] Panel title positioning\n- [ ] Panel focus style change\n- [ ] Panel with various content types\n- [ ] Empty status line\n\n## Acceptance Criteria\n- [ ] StatusLine with 3 regions\n- [ ] StatusItem variants\n- [ ] Panel wrapper widget\n- [ ] Focus styling\n- [ ] Integration with layouts\n\n## Location: ftui-widgets crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:38:23.477486358Z","created_by":"ubuntu","updated_at":"2026-02-01T00:27:53.660830199Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2dc","depends_on_id":"bd-35p","type":"blocks","created_at":"2026-01-31T22:39:21.399768507Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2dc","depends_on_id":"bd-3bp.8","type":"blocks","created_at":"2026-02-01T00:27:53.660794742Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2dc","depends_on_id":"bd-wr2","type":"blocks","created_at":"2026-01-31T22:39:21.091554241Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2fx","title":"Implement export adapters (HTML/SVG/Text)","description":"PHASE 7 EXTRAS - EXPORT ADAPTERS\n\n## Background\nExport adapters allow saving terminal UI output to various formats for sharing, documentation, and testing.\n\n## Technical Requirements\n\n### Export Formats\n\n#### HTML Export\npub struct HtmlExporter {\n    include_css: bool,\n    class_prefix: String,\n    font_family: String,\n}\n\nimpl HtmlExporter {\n    pub fn export(&self, buffer: &Buffer, pool: &GraphemePool) -> String {\n        // Generate HTML with inline styles or CSS classes\n        // Map colors to CSS colors\n        // Handle wide characters with spans\n    }\n}\n\nOutput:\n<pre class=\"ftui\">\n<span style=\"color:#ff0000;font-weight:bold\">Bold red</span>\n</pre>\n\n#### SVG Export\npub struct SvgExporter {\n    font_size: f32,\n    cell_width: f32,\n    cell_height: f32,\n    background: Color,\n}\n\nimpl SvgExporter {\n    pub fn export(&self, buffer: &Buffer, pool: &GraphemePool) -> String {\n        // Generate SVG with text elements\n        // Position text precisely\n        // Handle colors as fill attributes\n    }\n}\n\n#### Plain Text Export\npub struct TextExporter {\n    strip_styles: bool,\n    include_ansi: bool,\n}\n\nimpl TextExporter {\n    pub fn export(&self, buffer: &Buffer, pool: &GraphemePool) -> String {\n        // strip_styles: just content\n        // include_ansi: full ANSI sequences\n    }\n}\n\n### Frame Capture\npub struct FrameCapture {\n    buffer: Buffer,\n    pool: GraphemePool,\n    timestamp: Instant,\n}\n\nimpl Frame {\n    pub fn capture(&self) -> FrameCapture {\n        // Clone current state for export\n    }\n}\n\n### Session Recording (Optional)\npub struct SessionRecorder {\n    frames: Vec<FrameCapture>,\n    max_frames: usize,\n}\n\nimpl SessionRecorder {\n    pub fn record(&mut self, frame: &Frame);\n    pub fn export_gif(&self) -> Vec<u8>;  // Feature: gif\n    pub fn export_asciinema(&self) -> String;  // Feature: asciinema\n}\n\n## Tests Required\n- [ ] HTML export preserves colors\n- [ ] HTML escape special chars\n- [ ] SVG dimensions correct\n- [ ] SVG text positioning\n- [ ] Plain text strips ANSI\n- [ ] Wide characters handled\n- [ ] Empty buffer exports cleanly\n\n## Acceptance Criteria\n- [ ] HTML exporter with CSS\n- [ ] SVG exporter with fonts\n- [ ] Plain text exporter\n- [ ] Frame capture API\n- [ ] Optional session recording\n- [ ] Feature gate: export\n\n## Location: ftui-extras crate (feature = \"export\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:38:54.774907037Z","created_by":"ubuntu","updated_at":"2026-01-31T22:39:22.296082464Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2fx","depends_on_id":"bd-10i.3.5","type":"blocks","created_at":"2026-01-31T22:39:22.296051996Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2fx","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:39:21.996457852Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2gx","title":"Track Quality Gates (v1 Stop-Ship Criteria)","description":"# Quality Gates: v1 Stop-Ship Criteria\n\n## Background\nPlan Section 0.7 defines four quality gates that are STOP-SHIP if failing. These must be tracked and verified before v1 release.\n\n## Quality Gates\n\n### Gate 1: Inline Mode Stability (CRITICAL)\n**Requirement:** Re-rendering UI region while streaming logs cannot corrupt scrollback or cursor placement.\n\n**Verification:**\n- [ ] PTY test: continuous log stream + periodic UI refresh does not corrupt scrollback\n- [ ] PTY test: cursor returns to correct position after every present()\n- [ ] PTY test: resize during active logging re-anchors correctly\n- [ ] Manual test: 10-minute stress test with rapid log output\n- [ ] Tested on: Linux terminal, tmux, macOS Terminal, WezTerm, Kitty\n\n**Blocking beads:** bd-fbp (overlay redraw), bd-10i.11.2 (PTY tests)\n\n### Gate 2: Diff/Presenter Correctness\n**Requirement:** Property tests validate that applying presenter output to a terminal-model yields the expected grid for supported ops.\n\n**Verification:**\n- [ ] proptest: BufferDiff.compute() identifies all changes\n- [ ] proptest: applying Presenter output to TerminalModel matches source Buffer\n- [ ] proptest: style state never \"leaks\" across runs\n- [ ] proptest: OSC 8 links properly opened and closed\n- [ ] 1000+ random buffer property test passes\n\n**Blocking beads:** bd-10i.11.1 (terminal-model), bd-10i.4.3 (Presenter)\n\n### Gate 3: Unicode Width Correctness\n**Requirement:** Test suite includes emoji/ZWJ/combining marks; no off-by-one wrapping errors.\n\n**Verification:**\n- [ ] Width corpus test: ASCII (all printable)\n- [ ] Width corpus test: CJK wide characters\n- [ ] Width corpus test: Common emoji (🎉, ❤️, 🔥, etc.)\n- [ ] Width corpus test: ZWJ sequences (👨‍👩‍👧‍👦, 👩‍💻, etc.)\n- [ ] Width corpus test: Combining marks (é = e + ́)\n- [ ] Width corpus test: Regional indicators (🇺🇸 = U+1F1FA + U+1F1F8)\n- [ ] Text wrapping test: no mid-grapheme breaks\n- [ ] Truncation test: ellipsis at correct position\n\n**Blocking beads:** bd-16k (Unicode width corpus), bd-2uk (Text type)\n\n### Gate 4: Terminal Cleanup\n**Requirement:** PTY tests verify raw mode + cursor visibility + alt screen restoration after normal exit and panic.\n\n**Verification:**\n- [ ] PTY test: normal exit restores cursor visibility\n- [ ] PTY test: normal exit disables raw mode\n- [ ] PTY test: normal exit disables mouse mode\n- [ ] PTY test: normal exit disables bracketed paste\n- [ ] PTY test: alt screen exited on cleanup\n- [ ] PTY test: PANIC during render triggers cleanup\n- [ ] PTY test: IO error mid-write triggers cleanup\n- [ ] Verified panic hook installed correctly\n\n**Blocking beads:** bd-10i.2.6 (TerminalSession), bd-10i.11.2 (PTY tests)\n\n## CI Integration\n- All gates must pass on every PR to main\n- Gates are blocking (not advisory)\n- Gate status visible in CI summary\n\n## Documentation\nWhen all gates pass, update CHANGELOG.md with:\n- \"v1 Quality Gates: PASSED\"\n- Date and commit hash of verification\n\n## Acceptance Criteria\n- [ ] All Gate 1 tests implemented and passing\n- [ ] All Gate 2 tests implemented and passing\n- [ ] All Gate 3 tests implemented and passing\n- [ ] All Gate 4 tests implemented and passing\n- [ ] Gates integrated into CI\n- [ ] All gates green before v1 tag","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T23:17:48.962577656Z","created_by":"ubuntu","updated_at":"2026-01-31T23:27:58.523772275Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2gx","depends_on_id":"bd-10i.11","type":"blocks","created_at":"2026-01-31T23:27:58.523719445Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2gx","depends_on_id":"bd-10i.11.1","type":"blocks","created_at":"2026-01-31T23:17:56.456035177Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2gx","depends_on_id":"bd-10i.11.2","type":"blocks","created_at":"2026-01-31T23:17:55.873182651Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2gx","depends_on_id":"bd-10i.2.6","type":"blocks","created_at":"2026-01-31T23:17:57.621044159Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2gx","depends_on_id":"bd-16k","type":"blocks","created_at":"2026-01-31T23:17:57.036564148Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2gx","depends_on_id":"bd-2x0j","type":"blocks","created_at":"2026-01-31T23:21:24.522160540Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2gx","depends_on_id":"bd-fbp","type":"blocks","created_at":"2026-01-31T23:17:55.332559049Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2kj","title":"Build Agent Harness reference application (ftui-harness)","description":"# Build Agent Harness Reference Application (ftui-harness)\n\n## Background\nPlan Section 12.4 and Chapter 17 define the Agent Harness as the PRIMARY design forcing function. This is not \"just an example\" - it is the proof that ftui works for its primary use case: Claude Code / Codex-style agent UIs.\n\n## Purpose\nThe agent harness reference application demonstrates:\n1. Inline mode with streaming logs and stable UI chrome\n2. No flicker, no cursor corruption, reliable cleanup\n3. Real-world patterns for agent harness builders\n\n## Minimum Harness Primitives (from Plan 0.8.3)\n- `write_log(text)` - scrollback-native (inline mode)\n- `present_ui(frame)` - atomic and flicker-resistant\n- Optional \"modal alt-screen\" for complex UI interactions\n- Child-process capture via PTY (feature gated)\n\n## Application Structure\n\n```\nftui-harness/\n  src/\n    main.rs           # Entry point\n    app.rs            # Application model\n    components/\n      log_viewer.rs   # Scrolling log display\n      status_bar.rs   # Top status line\n      tool_status.rs  # Tool execution indicator\n      input_line.rs   # User input/prompt\n    commands.rs       # Command handling\n    pty_capture.rs    # Feature-gated PTY support\n  examples/\n    minimal.rs        # Bare minimum harness\n    streaming.rs      # High-volume log streaming\n    modal.rs          # Modal alt-screen demo\n```\n\n## UI Layout\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│ [Status] Model: claude-3  │  Tool: Running grep...  │  Memory: 2.1GB │ 23:45│\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│  Searching for patterns in codebase...                                     │\n│  Found 42 matches in src/                                                  │\n│  Analyzing results...                                                      │\n│  [more log output continues...]                                            │\n│                                                                             │\n│                                                                             │\n│                                                                             │\n├─────────────────────────────────────────────────────────────────────────────┤\n│ > Enter command:                                                        [⠋]│\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Regions\n- **Status Bar (1 line)**: Model info, tool status, memory, time\n- **Log Region (variable)**: Scrolling log viewer, grows with terminal\n- **Input Region (1-2 lines)**: User prompt + spinner\n\n## Application Model\n\n```rust\nuse ftui::{App, Cmd, Event, Frame, Model, ScreenMode, Result};\n\npub struct AgentHarness {\n    // UI Components\n    log_viewer: LogViewer,\n    status_bar: StatusBar,\n    input_line: InputLine,\n    spinner: Spinner,\n    \n    // State\n    model_name: String,\n    current_tool: Option<String>,\n    memory_usage: u64,\n    \n    // Mode\n    screen_mode: ScreenMode,\n    ui_height: u16,\n}\n\nimpl Model for AgentHarness {\n    type Message = HarnessMessage;\n    \n    fn init(&mut self) -> Cmd<Self::Message> {\n        Cmd::batch(vec![\n            Cmd::tick(Duration::from_millis(100)),  // Spinner animation\n            Cmd::tick(Duration::from_secs(1)),      // Status refresh\n        ])\n    }\n    \n    fn update(&mut self, msg: HarnessMessage) -> Cmd<Self::Message> {\n        match msg {\n            HarnessMessage::LogLine(line) => {\n                self.log_viewer.push(line);\n                Cmd::none()\n            }\n            HarnessMessage::ToolStart(name) => {\n                self.current_tool = Some(name);\n                Cmd::none()\n            }\n            HarnessMessage::ToolEnd => {\n                self.current_tool = None;\n                Cmd::none()\n            }\n            HarnessMessage::Key(key) => {\n                self.handle_key(key)\n            }\n            HarnessMessage::Tick => {\n                self.spinner.tick();\n                Cmd::none()\n            }\n            HarnessMessage::Quit => Cmd::quit(),\n        }\n    }\n    \n    fn view(&self, frame: &mut Frame) {\n        let area = frame.buffer.area();\n        \n        // Status bar at top\n        let status_area = Rect::new(0, 0, area.width, 1);\n        self.status_bar.render(status_area, &mut frame.buffer);\n        \n        // Log viewer in middle\n        let log_area = Rect::new(0, 1, area.width, area.height - self.ui_height);\n        self.log_viewer.render(log_area, &mut frame.buffer);\n        \n        // Input line at bottom\n        let input_area = Rect::new(0, area.height - 2, area.width, 2);\n        self.input_line.render(input_area, &mut frame.buffer);\n        \n        // Spinner in corner\n        let spinner_area = Rect::new(area.width - 2, area.height - 1, 2, 1);\n        if self.current_tool.is_some() {\n            self.spinner.render(spinner_area, &mut frame.buffer);\n        }\n    }\n}\n```\n\n## Key Features to Demonstrate\n\n### 1. Streaming Log Output\n```rust\n// Simulate tool output arriving in chunks\nasync fn stream_tool_output(tx: Sender<HarnessMessage>) {\n    let output = run_tool().await;\n    for line in output.lines() {\n        tx.send(HarnessMessage::LogLine(line.to_string())).await?;\n        // Log lines appear smoothly without flicker\n    }\n}\n```\n\n### 2. Inline Mode Stability\n```rust\nfn main() -> Result<()> {\n    App::new(AgentHarness::new())\n        .screen_mode(ScreenMode::Inline { ui_height: 4 })\n        .run()\n    // Native scrollback preserved\n    // UI never corrupts scrollback\n    // Cursor returns to correct position\n}\n```\n\n### 3. Modal Alt-Screen (Optional)\n```rust\nimpl AgentHarness {\n    fn enter_file_picker(&mut self) -> Cmd<HarnessMessage> {\n        // Temporarily switch to alt-screen for full-screen picker\n        Cmd::batch(vec![\n            Cmd::enter_alt_screen(),\n            Cmd::msg(HarnessMessage::ShowPicker),\n        ])\n    }\n    \n    fn exit_file_picker(&mut self) -> Cmd<HarnessMessage> {\n        Cmd::batch(vec![\n            Cmd::exit_alt_screen(),\n            Cmd::msg(HarnessMessage::PickerClosed),\n        ])\n    }\n}\n```\n\n### 4. Panic Recovery\n```rust\n// Panic anywhere should restore terminal\nstd::panic::set_hook(Box::new(|info| {\n    // Terminal cleanup happens via RAII guards\n    eprintln!(\"Panic: {}\", info);\n}));\n```\n\n### 5. PTY Subprocess Capture (Feature-Gated)\n```rust\n#[cfg(feature = \"pty\")]\nfn run_subprocess_with_capture() {\n    let (master, slave) = openpty()?;\n    let child = Command::new(\"cargo\")\n        .args([\"test\"])\n        .stdin(slave)\n        .stdout(slave)\n        .stderr(slave)\n        .spawn()?;\n    \n    // Read from master, forward to log viewer\n    // All output goes through ftui (one-writer rule preserved)\n}\n```\n\n## Tests Required\n\n### Unit Tests\n- [ ] Model state transitions\n- [ ] Command generation\n- [ ] Log viewer updates\n- [ ] Status bar formatting\n\n### Integration Tests\n- [ ] Full app lifecycle (start → use → exit)\n- [ ] Resize handling\n- [ ] Log streaming at high volume\n- [ ] Modal transitions\n\n### PTY Tests\n- [ ] Inline mode cursor contract\n- [ ] Scrollback preservation\n- [ ] Cleanup on exit\n- [ ] Cleanup on panic\n- [ ] No flicker under load\n\n### Performance Tests\n- [ ] 60 FPS with 1000 log lines\n- [ ] Smooth scrolling\n- [ ] Low latency input response\n\n## Documentation\nThe harness should be WELL DOCUMENTED as it serves as the primary example:\n- Inline comments explaining patterns\n- README with usage instructions\n- Architecture diagram\n\n## Acceptance Criteria (from Plan 17.4)\n- [ ] \"Hello world harness\" in < 200 LOC\n- [ ] \"Tool output streaming\" is one function call\n- [ ] \"Pinned bottom UI\" is one config option\n- [ ] \"Temporary full-screen modal\" is supported without rewriting\n- [ ] No flicker under sustained log output\n- [ ] PTY tests pass (cursor, cleanup, scrollback)\n\n## Dependencies\n- Requires: bd-29v (LogViewer widget)\n- Requires: bd-2dc (Status/Panel widgets)\n- Requires: bd-gpe (TextInput widget)\n- Requires: bd-35p (Spinner/Progress)\n- Requires: bd-10i.8.2 (Runtime)\n- Blocks: bd-2ky9 (E2E tests use this)\n- Blocks: bd-wo2 (Tutorial documents this)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:50:43.295616067Z","created_by":"ubuntu","updated_at":"2026-02-01T00:37:49.807481386Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2kj","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T22:53:53.308923193Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2kj","depends_on_id":"bd-10i.8.2","type":"blocks","created_at":"2026-01-31T22:53:51.799707368Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2kj","depends_on_id":"bd-29v","type":"blocks","created_at":"2026-01-31T22:53:52.939855940Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2kj","depends_on_id":"bd-2dc","type":"blocks","created_at":"2026-02-01T00:37:49.807444647Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2kj","depends_on_id":"bd-35p","type":"blocks","created_at":"2026-02-01T00:37:48.168715847Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2kj","depends_on_id":"bd-fbp","type":"blocks","created_at":"2026-01-31T22:53:52.193367037Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2kj","depends_on_id":"bd-gpe","type":"blocks","created_at":"2026-01-31T22:53:52.567678843Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ky9","title":"E2E Test Scripts with Comprehensive Logging","description":"# E2E Test Scripts with Comprehensive Logging\n\n## Background\nPlan Section Testing + Verification requires end-to-end tests that validate the complete pipeline from user input to terminal output. The user specifically requested \"comprehensive unit tests and e2e test scripts with great, detailed logging.\"\n\n## E2E Test Philosophy\nE2E tests should:\n1. Test the complete system as a user would experience it\n2. Run in a PTY to capture real terminal behavior\n3. Log every step for post-mortem debugging\n4. Be deterministic and reproducible\n5. Cover happy paths and error cases\n\n## E2E Test Script Structure\n\n### Directory Layout\n```\ntests/\n  e2e/\n    fixtures/          # Test input files\n    expected/          # Expected output snapshots\n    scripts/           # Test runner scripts\n      run_all.sh       # Master test runner\n      test_inline.sh   # Inline mode tests\n      test_altscreen.sh # Alt-screen tests\n      test_cleanup.sh  # Cleanup/panic tests\n      test_input.sh    # Input handling tests\n    lib/\n      common.sh        # Shared utilities\n      logging.sh       # Logging functions\n      pty.sh           # PTY spawning helpers\n```\n\n### Logging Framework (logging.sh)\n```bash\n#!/bin/bash\n# Comprehensive logging for E2E tests\n\nLOG_LEVEL=${LOG_LEVEL:-DEBUG}\nLOG_FILE=${LOG_FILE:-/tmp/ftui_e2e_$(date +%Y%m%d_%H%M%S).log}\n\nlog() {\n    local level=$1\n    shift\n    local timestamp=$(date +\"%Y-%m-%d %H:%M:%S.%3N\")\n    local caller=\"${BASH_SOURCE[2]}:${BASH_LINENO[1]}\"\n    echo \"[$timestamp] [$level] [$caller] $*\" | tee -a \"$LOG_FILE\"\n}\n\nlog_debug() { [[ \"$LOG_LEVEL\" == \"DEBUG\" ]] && log \"DEBUG\" \"$@\"; }\nlog_info()  { log \"INFO\" \"$@\"; }\nlog_warn()  { log \"WARN\" \"$@\"; }\nlog_error() { log \"ERROR\" \"$@\"; }\n\nlog_test_start() {\n    local test_name=$1\n    log_info \"==========================================\"\n    log_info \"STARTING TEST: $test_name\"\n    log_info \"==========================================\"\n}\n\nlog_test_pass() {\n    local test_name=$1\n    log_info \"✓ PASSED: $test_name\"\n}\n\nlog_test_fail() {\n    local test_name=$1\n    local reason=$2\n    log_error \"✗ FAILED: $test_name\"\n    log_error \"  Reason: $reason\"\n    log_error \"  Log file: $LOG_FILE\"\n}\n\nlog_hex_dump() {\n    local label=$1\n    local data=$2\n    log_debug \"$label (hex): $(echo -n \"$data\" | xxd -p | tr -d n)\"\n}\n```\n\n## E2E Test Categories\n\n### 1. Inline Mode Tests (test_inline.sh)\nTests that streaming logs + UI chrome works correctly.\n\n```bash\ntest_inline_log_scroll() {\n    log_test_start \"Inline mode: log scrolling\"\n    \n    # Setup\n    local pty_output=$(mktemp)\n    log_debug \"PTY output file: $pty_output\"\n    \n    # Run ftui app that streams 100 log lines with 6-line UI\n    log_info \"Spawning ftui inline mode app...\"\n    timeout 10s script -q -c \"./target/debug/ftui-harness --mode inline --ui-height 6 --log-count 100\" \"$pty_output\"\n    local exit_code=$?\n    log_debug \"Exit code: $exit_code\"\n    \n    # Verify\n    log_info \"Verifying output...\"\n    \n    # Check scrollback preservation\n    if grep -q \"Log line 1\" \"$pty_output\"; then\n        log_debug \"Early log lines found in scrollback ✓\"\n    else\n        log_test_fail \"Inline log scroll\" \"Early log lines missing from scrollback\"\n        return 1\n    fi\n    \n    # Check UI region intact\n    if tail -6 \"$pty_output\" | grep -q \"\\[Status\\]\"; then\n        log_debug \"UI region present at bottom ✓\"\n    else\n        log_test_fail \"Inline log scroll\" \"UI region not at expected position\"\n        return 1\n    fi\n    \n    log_test_pass \"Inline mode: log scrolling\"\n    rm \"$pty_output\"\n}\n```\n\n### 2. Cleanup Tests (test_cleanup.sh)\nTests that terminal is restored after exit/panic.\n\n```bash\ntest_panic_cleanup() {\n    log_test_start \"Panic cleanup: terminal restored\"\n    \n    # Capture terminal state before\n    local before_state=$(stty -g)\n    log_debug \"Terminal state before: $before_state\"\n    \n    # Run app that panics\n    log_info \"Running app that will panic...\"\n    ./target/debug/ftui-panic-test 2>/dev/null || true\n    \n    # Capture terminal state after\n    local after_state=$(stty -g)\n    log_debug \"Terminal state after: $after_state\"\n    \n    # Verify restoration\n    if [[ \"$before_state\" == \"$after_state\" ]]; then\n        log_debug \"Terminal state restored ✓\"\n    else\n        log_test_fail \"Panic cleanup\" \"Terminal state not restored\"\n        log_error \"  Before: $before_state\"\n        log_error \"  After:  $after_state\"\n        return 1\n    fi\n    \n    # Check cursor visible (SGR sequence check)\n    log_info \"Checking cursor visibility...\"\n    # ... additional checks ...\n    \n    log_test_pass \"Panic cleanup: terminal restored\"\n}\n```\n\n### 3. Input Tests (test_input.sh)\nTests for keyboard, mouse, paste handling.\n\n### 4. ANSI Output Tests\nVerify presenter output matches expected sequences.\n\n## Test Output Format\n\nEach test run produces:\n1. Console output (PASS/FAIL per test)\n2. Detailed log file with timestamps\n3. JSON summary for CI\n4. PTY captures for failed tests\n\n### JSON Summary Format\n```json\n{\n  \"timestamp\": \"2026-01-31T23:45:00Z\",\n  \"total\": 50,\n  \"passed\": 48,\n  \"failed\": 2,\n  \"skipped\": 0,\n  \"duration_ms\": 12345,\n  \"tests\": [\n    {\n      \"name\": \"test_inline_log_scroll\",\n      \"status\": \"passed\",\n      \"duration_ms\": 234,\n      \"log_lines\": 45\n    },\n    {\n      \"name\": \"test_panic_cleanup\",\n      \"status\": \"failed\",\n      \"duration_ms\": 567,\n      \"error\": \"Terminal state not restored\",\n      \"log_file\": \"/tmp/ftui_e2e_20260131_234500.log\"\n    }\n  ]\n}\n```\n\n## E2E Test Inventory\n\n| Test | Description | Priority |\n|------|-------------|----------|\n| inline_basic | Basic inline mode display | P0 |\n| inline_log_scroll | Log scrolling preserves scrollback | P0 |\n| inline_resize | Resize re-anchors UI | P0 |\n| inline_cursor | Cursor position contract | P0 |\n| altscreen_enter_exit | Alt-screen lifecycle | P0 |\n| cleanup_normal | Terminal restored on exit | P0 |\n| cleanup_panic | Terminal restored on panic | P0 |\n| cleanup_io_error | Terminal restored on IO error | P1 |\n| input_key_basic | Basic key parsing | P0 |\n| input_key_modifiers | Modifier key detection | P1 |\n| input_mouse_click | Mouse click handling | P1 |\n| input_mouse_scroll | Mouse scroll handling | P1 |\n| input_paste | Bracketed paste handling | P1 |\n| input_focus | Focus events | P2 |\n| ansi_sgr | SGR sequence output | P0 |\n| ansi_osc8 | OSC 8 hyperlink output | P1 |\n| ansi_sync | Synchronized output | P1 |\n| unicode_basic | ASCII width handling | P0 |\n| unicode_wide | CJK wide chars | P0 |\n| unicode_emoji | Emoji rendering | P0 |\n| unicode_zwj | ZWJ sequences | P1 |\n\n## Acceptance Criteria\n- [ ] run_all.sh executes all E2E tests\n- [ ] Each test has detailed logging\n- [ ] Failed tests produce actionable diagnostics\n- [ ] JSON summary generated for CI\n- [ ] PTY captures preserved on failure\n- [ ] Tests run in < 60 seconds total\n- [ ] All P0 tests must pass for v1\n\n## Dependencies\n- Requires: bd-2kj (Agent Harness exists to test)\n- Requires: bd-10i.11.2 (PTY framework)\n- Blocks: bd-2gx (Quality Gates)\n\n## CI Integration\n- Run on every PR\n- Block merge on P0 test failures\n- Upload log artifacts on failure","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-01T00:22:54.577032739Z","created_by":"ubuntu","updated_at":"2026-02-01T00:37:46.636554049Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ky9","depends_on_id":"bd-10i.11","type":"parent-child","created_at":"2026-02-01T00:37:13.931465468Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2ky9","depends_on_id":"bd-10i.11.2","type":"blocks","created_at":"2026-02-01T00:37:15.214382302Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2ky9","depends_on_id":"bd-2kj","type":"blocks","created_at":"2026-02-01T00:37:46.636506330Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2m5","title":"SIMD-accelerated cell comparison and buffer operations","description":"# SIMD/autovec accelerated hot paths (NO unsafe)\n\n## Objective\nImprove hot-path performance (cell comparisons, clears, copies, ASCII width checks) **without introducing unsafe code**.\n\nProject constraint: `#![forbid(unsafe_code)]` across our crates. We must not create an “unsafe-only SIMD crate”.\n\n## Plan Alignment\nThe plan mentions optional SIMD acceleration. In this repo, that must translate into one of:\n- compiler autovectorization via carefully-written scalar loops\n- safe portable SIMD (only if available without `unsafe` in our Rust toolchain)\n- leveraging well-vetted dependencies that encapsulate unsafe internally (our crate remains `forbid(unsafe_code)`)\n\n## Scope\nTarget the following operations, in priority order:\n1. Cell equality comparisons in diff scan\n2. Buffer clear/fill\n3. Row/rect copies\n4. ASCII-width fast paths\n\n## Strategy\n- Write scalar loops that are friendly to autovec:\n  - contiguous slices\n  - minimal branching\n  - row-major iteration\n- Use benchmark-driven iteration:\n  - measure p50/p95 for 80x24 and larger terminals\n  - confirm no regressions in correctness tests\n\n## Explicit Non-Goal\n- Adding `unsafe` blocks or `#[target_feature]` functions inside ftui code.\n\nIf later we decide explicit unsafe SIMD is required, that needs an explicit policy change (and likely an ADR + safety review).\n\n## Tests Required\n- Property tests confirming optimized paths exactly match the reference scalar behavior.\n- Benchmarks that show improvements and include regression budgets.\n\n## Acceptance Criteria\n- [ ] Optimizations preserve correctness (property tests pass; byte-for-byte identical results where applicable).\n- [ ] Benchmarks demonstrate measurable improvements on at least one key hot path.\n- [ ] No unsafe code is introduced in ftui crates.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:20:50.805814276Z","created_by":"ubuntu","updated_at":"2026-02-01T00:35:47.032300226Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2m5","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T22:22:46.216463669Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2rs","title":"Implement clipboard integration (OSC 52)","description":"PHASE 7 EXTRAS - CLIPBOARD INTEGRATION\n\n## Background\nOSC 52 allows setting the system clipboard from terminal applications. This enables copy/paste functionality without external dependencies.\n\n## Technical Requirements\n\n### OSC 52 Protocol\nSequence: ESC ] 52 ; c ; <base64-data> BEL\n\nc = clipboard selection:\n- c = clipboard\n- p = primary (X11)\n- s = secondary\n- 0-7 = cut buffers\n\n### Clipboard API\n\npub struct Clipboard {\n    caps: TerminalCapabilities,\n}\n\nimpl Clipboard {\n    /// Check if OSC 52 is supported\n    pub fn is_available(&self) -> bool {\n        self.caps.osc52\n    }\n    \n    /// Set clipboard content\n    pub fn set(&self, content: &str, writer: &mut impl Write) -> io::Result<()> {\n        if !self.is_available() {\n            return Err(io::Error::new(\n                io::ErrorKind::Unsupported,\n                \"OSC 52 not available\"\n            ));\n        }\n        \n        let encoded = base64::encode(content);\n        write!(writer, \"\\x1b]52;c;{}\\x07\", encoded)?;\n        writer.flush()\n    }\n    \n    /// Clear clipboard\n    pub fn clear(&self, writer: &mut impl Write) -> io::Result<()> {\n        write!(writer, \"\\x1b]52;c;\\x07\")?;\n        writer.flush()\n    }\n}\n\n### Terminal Compatibility\nOSC 52 support varies:\n- ✅ iTerm2, kitty, alacritty, WezTerm, foot\n- ⚠️ tmux (needs set-clipboard on)\n- ⚠️ screen (needs clipboard support)\n- ❌ Many terminal emulators disable by default\n\n### Detection Strategy\n1. Check known terminal from TERM/TERM_PROGRAM\n2. Check tmux/screen allow-passthrough\n3. Attempt set and check for response (risky)\n4. Default: assume unsupported\n\n### Size Limits\nMost terminals limit OSC 52 payload:\n- Common limit: 74994 bytes (base64)\n- Split large content or fail gracefully\n\n### Fallback Options\nWhen OSC 52 unavailable:\n- Fall back to external clipboard tool (feature: clipboard-fallback)\n  - macOS: pbcopy/pbpaste\n  - Linux: xclip, xsel, wl-copy\n  - Windows: clip.exe\n- Or return error for application to handle\n\n## Tests Required\n- [ ] OSC 52 sequence generation\n- [ ] Base64 encoding correct\n- [ ] Size limit handling\n- [ ] Clear clipboard works\n- [ ] Capability detection\n- [ ] Fallback to external tools\n- [ ] Error handling when unavailable\n\n## Acceptance Criteria\n- [ ] OSC 52 set clipboard\n- [ ] Capability detection\n- [ ] Size limit enforcement\n- [ ] Clear clipboard\n- [ ] Optional external fallback\n- [ ] Feature gate: clipboard\n\n## Location: ftui-extras crate (feature = \"clipboard\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:39:12.769788961Z","created_by":"ubuntu","updated_at":"2026-01-31T22:39:22.604131369Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2rs","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T22:39:22.604101432Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2ss","title":"Document Windows v1 Limitations and Compatibility","description":"# Document Windows v1 Limitations and Compatibility\n\n## Background\nPlan Section ADR-004 and Section 0.6.6 require a \"Windows limitations\" section that is honest about what works and what doesn't.\n\n## Document Location\n`docs/WINDOWS.md` or `docs/compatibility/windows.md`\n\n## Required Content\n\n### 1. Supported Features (v1)\nDocument what IS expected to work on Windows:\n- [ ] Raw mode enter/exit and cleanup on panic\n- [ ] Key input handling (basic keys, modifiers)\n- [ ] Resize events\n- [ ] Basic mouse support (where Crossterm supports it)\n- [ ] Color output:\n  - 16 colors (always)\n  - 256 colors (Windows Terminal, modern ConHost)\n  - TrueColor (Windows Terminal)\n\n### 2. Known Limitations (v1)\nBe honest about what MAY NOT work or is best-effort:\n- [ ] DEC synchronized output (mode 2026): Not widely supported\n- [ ] OSC 8 hyperlinks: Windows Terminal only (cmd.exe/ConHost: no)\n- [ ] Bracketed paste: Varies by terminal\n- [ ] Focus events: May not work in all environments\n- [ ] Kitty keyboard protocol: Limited support\n- [ ] Scroll-region optimization: Behavior varies\n- [ ] Mouse SGR mode: May fall back to legacy encoding\n\n### 3. Terminal Compatibility Matrix (Windows)\n| Feature | Windows Terminal | cmd.exe | ConHost | PowerShell |\n|---------|------------------|---------|---------|------------|\n| TrueColor | ✓ | ✗ | ~ | depends |\n| OSC 8 Links | ✓ | ✗ | ✗ | ~ |\n| Mouse | ✓ | ✗ | ~ | ~ |\n| Sync Output | ✗ | ✗ | ✗ | ✗ |\n\n### 4. Configuration Recommendations\n- Recommend Windows Terminal for best experience\n- Document any required ConPTY settings\n- Explain TERM/COLORTERM environment handling on Windows\n\n### 5. Troubleshooting Section\nCommon Windows issues:\n- \"Colors don't show\": Check terminal emulator\n- \"Mouse not working\": Enable in terminal settings\n- \"Cleanup not working\": Known ConHost limitation\n- \"Unicode display broken\": Font/codepage issues\n\n### 6. Future Improvements\nList what may improve in future versions:\n- Better ConHost support\n- WSL integration notes\n- Specific terminal emulator enhancements\n\n## Cross-References\n- Link to ADR-004 for decision context\n- Link to terminal compatibility matrix (bd-1un)\n- Link to capability detection implementation\n\n## Acceptance Criteria\n- [ ] WINDOWS.md exists with all sections\n- [ ] Honest about limitations (not marketing fluff)\n- [ ] Tested on actual Windows systems\n- [ ] Includes actionable troubleshooting\n- [ ] Linked from main README.md\n\n## Location\n`docs/WINDOWS.md`","status":"open","priority":1,"issue_type":"docs","created_at":"2026-01-31T23:18:18.126663735Z","created_by":"ubuntu","updated_at":"2026-01-31T23:18:23.485129522Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2ss","depends_on_id":"bd-10i.10.4","type":"blocks","created_at":"2026-01-31T23:18:23.485084968Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2u4","title":"Implement snapshot/golden testing framework","description":"TESTING - SNAPSHOT TESTS\n\n## Background\nSnapshot testing captures expected Buffer output and compares against future runs. Essential for preventing visual regressions and validating rendering correctness.\n\n## Technical Requirements\n- Snapshot capture:\n  - Buffer → text representation (with ANSI or stripped)\n  - Buffer → binary serialization\n  - Configurable normalization (strip cursor position, etc.)\n- Snapshot storage:\n  - tests/snapshots/ directory\n  - Filename based on test name + variant\n  - Human-readable format for review\n- Comparison:\n  - Exact match mode\n  - Fuzzy match mode (ignore whitespace variations)\n  - Diff output on failure showing changes\n- Update workflow:\n  - BLESS=1 env var to update snapshots\n  - cargo insta integration optional\n\n## Design Rationale\nVisual output is hard to assert with unit tests. Snapshots capture 'known good' output and flag any changes for human review. Prevents subtle rendering regressions.\n\n## Acceptance Criteria\n- [ ] Snapshot capture API\n- [ ] Text and binary formats\n- [ ] Diff output on mismatch\n- [ ] Update/bless workflow\n- [ ] Integration with cargo test\n- [ ] Document snapshot review process\n- [ ] Sample snapshots for core widgets\n\n## Integration\n- Consider insta crate for snapshot management\n- Support parallel test execution\n- Snapshot files committed to git\n\n## Location: ftui-harness crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:21:02.513675763Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:45.971542074Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2u4","depends_on_id":"bd-10i.11.1","type":"blocks","created_at":"2026-01-31T22:22:45.971507198Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2uk","title":"Implement Text type with styled spans","description":"# Implement Text type (Segment/Span collection)\n\n## Background\nPlan Section 0.4 and Appendix D establish a text pipeline:\n- `Segment` is the atomic styled unit (Cow<str> where possible)\n- higher-level markup/text APIs produce segments\n- widgets/layout paint segments into `Frame`/`Buffer`\n\nText must support:\n- ergonomic construction for app authors\n- deterministic style application\n- width-correct wrapping/truncation (ZWJ/emoji/combining)\n- fast paths for ASCII-heavy workloads (see bd-v6y)\n\n## Proposed model\nA `Text` is an owned collection of segments (or spans) plus helpers.\n\nOption A (generic, most faithful to plan):\n```rust\npub struct Text<'a> {\n    segments: Vec<Segment<'a>>,\n}\n```\n\nOption B (ergonomic, no lifetimes in app code):\n- `Text` stores `Segment<'static>` (Cow<'static, str>)\n- constructors accept `&str` and own when needed\n\nWe should pick the option that keeps the public API pleasant while preserving the plan's \"borrow when you can\" benefit for string literals.\n\n## Required behaviors\n- Append/push spans/segments\n- Apply a base style (inheritance) deterministically\n- Split into lines (preserve styles)\n- Truncate to width with ellipsis (width-correct)\n- Wrap to width (width-correct)\n\n## Width correctness\n- ASCII fast path must be correct and allocation-free (bd-v6y)\n- Non-ASCII path must use Unicode width + (ideally) grapheme segmentation\n- Must not wrap mid-grapheme for common emoji/ZWJ sequences\n\n## Tests\n- Line splitting preserves styles across `\\n`\n- Truncation is width-correct for:\n  - ASCII\n  - CJK wide chars\n  - emoji/ZWJ sequences\n- Wrapping is width-correct and stable across widths\n\n## Acceptance Criteria\n- [ ] `Text` type exists with an ergonomic builder API.\n- [ ] Wrapping/truncation is width-correct.\n- [ ] ASCII fast path is integrated (bd-v6y).\n- [ ] Unit tests cover ASCII, CJK, emoji/ZWJ cases.\n\n## Location\n`ftui-text` crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:18:51.038800704Z","created_by":"ubuntu","updated_at":"2026-01-31T23:16:06.591430721Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2uk","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T22:22:12.067575457Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2uk","depends_on_id":"bd-1ho.1","type":"blocks","created_at":"2026-01-31T23:15:51.396823035Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2vr","title":"Create comprehensive E2E test suite","description":"# Create comprehensive E2E test suite\n\n## Background\nEnd-to-end tests verify the complete rendering pipeline from widget construction through terminal output. Must test real terminal interactions, not mocked abstractions.\n\n## Technical Requirements\n\n### E2E Test Infrastructure\n- `scripts/e2e_test.sh` master script\n- Individual test scripts per feature area\n- JSON output for CI parsing\n- Verbose mode with full trace output\n- Exit codes: 0=pass, 1=fail, 2=skip\n\n### Test Categories\n\n#### 1. Rendering Tests (scripts/e2e/render/)\n- `hello_world.sh` - Basic text output\n- `colors.sh` - Full color palette rendering\n- `unicode.sh` - Emoji, CJK, RTL text\n- `styles.sh` - Bold, italic, underline, strikethrough\n- `hyperlinks.sh` - OSC 8 hyperlink rendering\n\n#### 2. Layout Tests (scripts/e2e/layout/)\n- `flex_horizontal.sh` - Row layout constraints\n- `flex_vertical.sh` - Column layout constraints\n- `grid.sh` - 2D grid positioning\n- `nested.sh` - Complex nested layouts\n- `resize.sh` - Terminal resize handling\n\n#### 3. Widget Tests (scripts/e2e/widgets/)\n- `block.sh` - Borders, titles, padding\n- `paragraph.sh` - Text wrapping, alignment\n- `table.sh` - Column sizing, selection\n- `list.sh` - Selection, scrolling\n- `input.sh` - Text entry, cursor\n\n#### 4. Input Tests (scripts/e2e/input/)\n- `keyboard.sh` - Key events, modifiers\n- `mouse.sh` - Click, scroll, drag\n- `paste.sh` - Bracketed paste mode\n- `focus.sh` - Focus in/out events\n\n#### 5. Integration Tests (scripts/e2e/integration/)\n- `full_app.sh` - Complete application lifecycle\n- `inline_mode.sh` - Scrollback-native rendering\n- `alt_screen.sh` - Alternate screen buffer\n- `raw_mode.sh` - Raw terminal mode transitions\n\n### Test Script Template\n```bash\n#!/bin/bash\nset -euo pipefail\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nsource \"${SCRIPT_DIR}/../common.sh\"\n\nTEST_NAME=\"render/hello_world\"\nlog_start \"${TEST_NAME}\"\n\n# Run the test binary\noutput=$(cargo run --example hello_world 2>&1) || fail \"Example failed to run\"\n\n# Verify output\nassert_contains \"${output}\" \"Hello\"\nassert_no_errors \"${output}\"\n\nlog_pass \"${TEST_NAME}\"\n```\n\n### Logging Requirements\nAll test scripts must provide detailed logging:\n\n**Start Phase:**\n- Timestamp (ISO 8601)\n- Test name and category\n- Environment info (TERM, COLORTERM, shell)\n- Configuration parameters\n\n**Progress Phase:**\n- Major checkpoint announcements\n- Timing for each phase\n- Resource usage snapshots\n\n**Failure Phase:**\n- Full context dump\n- Expected vs actual comparison\n- Stack trace if available\n- Terminal state capture\n- Reproduction command\n\n**Success Phase:**\n- Duration breakdown\n- Resource usage summary\n- Bytes emitted count\n\n### common.sh Functions\n```bash\nlog_start() { echo \"[$(date -Iseconds)] START: $1\"; }\nlog_progress() { echo \"[$(date -Iseconds)] PROGRESS: $1\"; }\nlog_pass() { echo \"[$(date -Iseconds)] PASS: $1 (${SECONDS}s)\"; }\nlog_fail() { echo \"[$(date -Iseconds)] FAIL: $1 - $2\" >&2; exit 1; }\nfail() { log_fail \"${TEST_NAME}\" \"$1\"; }\nassert_contains() { [[ \"$1\" == *\"$2\"* ]] || fail \"Expected to contain: $2\"; }\nassert_no_errors() { [[ \"$1\" != *\"error\"* ]] || fail \"Found error in output\"; }\ncapture_terminal_state() { echo \"TERM=$TERM COLORTERM=$COLORTERM\"; }\n```\n\n### CI Integration\n- JUnit XML output for test runners\n- Parallel execution where safe\n- Retry logic for flaky tests (max 2 retries)\n- Artifact collection on failure (logs, screenshots, terminal state)\n\n## Acceptance Criteria\n- [ ] Master `e2e_test.sh` script with `--verbose` and `--json` flags\n- [ ] `common.sh` with all helper functions\n- [ ] 5+ rendering tests with detailed logging\n- [ ] 5+ layout tests with detailed logging\n- [ ] 5+ widget tests with detailed logging\n- [ ] 5+ input tests with detailed logging\n- [ ] 3+ integration tests with detailed logging\n- [ ] JSON output mode for CI parsing\n- [ ] Verbose trace mode showing all operations\n- [ ] CI-friendly exit codes (0/1/2)\n- [ ] Test duration < 60s total\n- [ ] JUnit XML report generation\n\n## Location: scripts/e2e/","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:28:13.459580138Z","created_by":"ubuntu","updated_at":"2026-02-01T00:37:14.579063940Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2vr","depends_on_id":"bd-10i.8.2","type":"blocks","created_at":"2026-01-31T22:29:24.582439311Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2vr","depends_on_id":"bd-2ky9","type":"blocks","created_at":"2026-02-01T00:37:14.579014397Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2w5","title":"Implement view_string() easy mode adapter","description":"# Implement view_string() Easy Mode Adapter\n\n## Background\nPlan Section 0.8.2 and 12.3 describe a \"Easy mode adapter\" for trivial apps and prototyping. This allows developers to return a String from view() while still going through the full kernel pipeline.\n\n## Why This Matters\n- Enables quick prototyping without learning full Frame API\n- Familiar model for developers coming from Bubbletea\n- Keeps kernel discipline (String still goes through Frame)\n- Lower barrier to entry for simple apps\n\n## Technical Design\n\n### Model Trait Extension\n```rust\n/// Optional trait for models that want string-based views\npub trait StringModel: Model {\n    /// Return view as string (styled text with markup)\n    fn view_string(&self) -> String;\n}\n\n/// Blanket implementation: view_string -> Frame\nimpl<M: StringModel> Model for M {\n    fn view(&self, frame: &mut Frame) {\n        let text = self.view_string();\n        let parsed = Text::from_markup(&text);\n        frame.render_widget(parsed, frame.area());\n    }\n}\n```\n\n### Alternative: Wrapper Type\n```rust\n/// Wrapper that converts StringModel to Model\npub struct StringModelAdapter<M: StringModel> {\n    inner: M,\n}\n\nimpl<M: StringModel> Model for StringModelAdapter<M> {\n    type Message = M::Message;\n    \n    fn update(&mut self, msg: Self::Message) -> Cmd<Self::Message> {\n        self.inner.update(msg)\n    }\n    \n    fn view(&self, frame: &mut Frame) {\n        let text = self.inner.view_string();\n        let parsed = Text::from_markup(&text);\n        frame.render_widget(Paragraph::new(parsed), frame.area());\n    }\n}\n```\n\n### Pipeline Preservation\nString -> Text/Segments -> Frame draw -> Diff -> Presenter\n\nThis ensures:\n- Markup is properly parsed\n- Styles are correctly applied\n- Width measurement is correct\n- Diffing works normally\n- All kernel guarantees hold\n\n## Usage Example\n```rust\nstruct Counter { count: i32 }\n\nimpl StringModel for Counter {\n    fn view_string(&self) -> String {\n        format\\!(\"[bold]Count:[/] {}\", self.count)\n    }\n}\n\nfn main() -> Result<()> {\n    App::string_model(Counter { count: 0 })\n        .screen_mode(ScreenMode::Inline { ui_height: 1 })\n        .run()\n}\n```\n\n## API Options\n\n### Option 1: StringModel trait\n```rust\nApp::string_model(model)\n```\n\n### Option 2: view() callback\n```rust\nApp::new(model)\n    .view(|state| format\\!(\"Count: {}\", state.count))\n```\n\n### Option 3: Both\nSupport both patterns for flexibility.\n\n## Tests Required\n- [ ] view_string() produces correct Frame output\n- [ ] Markup parsing works correctly\n- [ ] Multi-line strings render properly\n- [ ] Width measurement correct\n- [ ] Style application correct\n- [ ] Diffing works as expected\n\n## Acceptance Criteria\n- [ ] StringModel trait or equivalent\n- [ ] Integration with App/Program\n- [ ] Proper pipeline (not bypass)\n- [ ] Documentation with examples\n- [ ] Tests for all paths\n\n## Location: ftui-runtime crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:53:03.545821731Z","created_by":"ubuntu","updated_at":"2026-01-31T22:54:03.936757737Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2w5","depends_on_id":"bd-10i.8.2","type":"blocks","created_at":"2026-01-31T22:54:03.587890261Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2w5","depends_on_id":"bd-3mo","type":"blocks","created_at":"2026-01-31T22:54:03.936708244Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2wi","title":"Implement Grid layout for 2D positioning","description":"PHASE 5 - GRID LAYOUT\n\n## Background\nGrid layout provides 2D positioning with rows/columns. More powerful than Flex for dashboard-style layouts with multiple regions.\n\n## Technical Requirements\n- Grid struct with rows × cols dimensions\n- Cell addressing: grid[(row, col)]\n- Column/row constraints (reuse Flex constraint types)\n- Cell spanning: colspan/rowspan for merged cells\n- Gap between cells (row_gap, col_gap)\n- Area naming: grid.area('sidebar') returns Rect\n- Template syntax for declarative grid definition\n\n## Design Rationale\nCSS Grid concepts adapted for TUI. Area naming enables semantic layout references. Cell spanning handles common dashboard patterns.\n\n## Acceptance Criteria\n- [ ] Grid struct with constraint-based sizing\n- [ ] Row and column constraint solving\n- [ ] Cell span support (colspan, rowspan)\n- [ ] Named area definition and lookup\n- [ ] Gap configuration\n- [ ] Template DSL for grid definition\n- [ ] Overflow handling for too-small grids\n- [ ] Property tests for area calculations\n\n## Performance Budget\n- Grid solve for 10×10: < 500µs\n- Area lookup: O(1) after solve\n\n## Location: ftui-layout crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:13.186902512Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:19.086437578Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2wi","depends_on_id":"bd-yzu","type":"blocks","created_at":"2026-01-31T22:22:19.086408393Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2wo","title":"Implement tmux/screen passthrough and mux detection","description":"# Implement tmux/screen Passthrough and Mux Detection\n\n## Background\nPlan Section 9.4 and ADR-001 describe multiplexer (tmux/screen/zellij) detection and passthrough handling. This is important for inline mode to work correctly under multiplexers.\n\n## Why This Matters\n- tmux/screen intercept escape sequences\n- Some features (sync output, OSC 8) need passthrough\n- Scroll regions behave differently under muxes\n- Detection enables correct fallback strategies\n\n## Technical Design\n\n### Detection\n```rust\nimpl TerminalCapabilities {\n    pub fn detect() -> Self {\n        // Multiplexer detection\n        let in_tmux = std::env::var(\"TMUX\").is_ok();\n        let in_screen = std::env::var(\"STY\").is_ok();\n        let in_zellij = std::env::var(\"ZELLIJ\").is_ok();\n        \n        // Note: WezTerm/Kitty built-in muxes don't need special handling\n        \n        Self {\n            in_tmux,\n            in_screen,\n            in_zellij,\n            // ...\n        }\n    }\n    \n    pub fn in_any_mux(&self) -> bool {\n        self.in_tmux || self.in_screen || self.in_zellij\n    }\n}\n```\n\n### tmux Passthrough Wrapper\n```rust\n/// Wrap sequence for tmux passthrough\n/// tmux intercepts escape sequences unless wrapped in DCS passthrough\npub fn tmux_wrap(sequence: &str) -> String {\n    if in_tmux() {\n        // Double escapes for tmux\n        let escaped = sequence.replace('\\\\x1b', \"\\\\x1b\\\\x1b\");\n        format\\!(\"\\\\x1bPtmux;{}\\\\x1b\\\\\\\\\", escaped)\n    } else {\n        sequence.to_string()\n    }\n}\n\n// Usage example for OSC 8 hyperlinks under tmux\nfn emit_hyperlink(url: &str) -> String {\n    let osc = format\\!(\"\\\\x1b]8;;{}\\\\x1b\\\\\\\\\", url);\n    tmux_wrap(&osc)\n}\n```\n\n### Mux-Aware Feature Policies\n```rust\nimpl TerminalCapabilities {\n    /// Returns whether sync output should be enabled\n    pub fn use_sync_output(&self) -> bool {\n        // Disable in multiplexers (passthrough unreliable)\n        if self.in_any_mux() {\n            return false;\n        }\n        self.sync_output\n    }\n    \n    /// Returns whether scroll-region optimization is safe\n    pub fn use_scroll_region(&self) -> bool {\n        // Conservative in muxes due to quirks\n        if self.in_any_mux() {\n            return false;  // Fall back to overlay redraw\n        }\n        self.scroll_region\n    }\n    \n    /// OSC 8 hyperlink support\n    pub fn use_hyperlinks(&self) -> bool {\n        // tmux passthrough needed for hyperlinks\n        // Only enable if passthrough is reliable\n        if self.in_tmux {\n            // Modern tmux (3.3+) supports OSC 8 passthrough\n            // but detection is fragile\n            return false;  // Conservative default\n        }\n        self.osc8_hyperlinks\n    }\n}\n```\n\n### Screen Passthrough\n```rust\n/// screen uses different passthrough syntax\npub fn screen_wrap(sequence: &str) -> String {\n    if in_screen() {\n        // screen uses P escape sequence\n        format\\!(\"\\\\x1bP{}\\\\x1b\\\\\\\\\", sequence)\n    } else {\n        sequence.to_string()\n    }\n}\n```\n\n### Zellij Handling\n```rust\n// Zellij generally has better passthrough than tmux/screen\n// but some features still need care\nimpl TerminalCapabilities {\n    pub fn zellij_passthrough_mode(&self) -> bool {\n        // Zellij 0.39+ has improved passthrough\n        self.in_zellij\n    }\n}\n```\n\n## Integration Points\n\n1. **TerminalCapabilities::detect()** - Detect multiplexer presence\n2. **Presenter output** - Apply passthrough wrapping where needed\n3. **ADR-001 inline mode** - Fall back to overlay redraw in muxes\n4. **Feature policies** - Conservative defaults in mux environments\n\n## Tests Required\n- [ ] TMUX env var detection\n- [ ] STY env var detection (screen)\n- [ ] ZELLIJ env var detection\n- [ ] tmux_wrap produces correct output\n- [ ] screen_wrap produces correct output\n- [ ] Feature policies respect mux detection\n- [ ] PTY test under tmux (if CI supports)\n\n## Acceptance Criteria\n- [ ] Mux detection in TerminalCapabilities\n- [ ] in_any_mux() helper method\n- [ ] Passthrough wrappers for tmux/screen\n- [ ] Feature policies mux-aware\n- [ ] Documentation of mux limitations\n\n## Location: ftui-core crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:55:01.998491733Z","created_by":"ubuntu","updated_at":"2026-01-31T22:55:09.706951315Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2wo","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:55:09.706897083Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2wo","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T22:55:09.339827361Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2x0j","title":"Implement property tests for diff correctness and presenter roundtrip","description":"# Implement Property Tests for Diff and Presenter Correctness\n\n## Background\nPlan Section 13.1 and J specifically require property tests to ensure diff correctness and presenter output validation. Property tests use randomized inputs to find edge cases humans miss.\n\n## Property Test Categories\n\n### Category 1: Diff Correctness\n**Property**: Applying diff changes to old buffer produces new buffer\n\n```rust\nproptest! {\n    #[test]\n    fn diff_apply_produces_target(\n        width in 10u16..200,\n        height in 5u16..100,\n        changes in proptest::collection::vec(\n            (0u16..200, 0u16..100, any::<Cell>()), \n            0..1000\n        )\n    ) {\n        // Create old buffer\n        let mut old = Buffer::new(width, height);\n        \n        // Apply random changes to create new buffer\n        let mut new = old.clone();\n        for (x, y, cell) in &changes {\n            if *x < width && *y < height {\n                new.set(*x, *y, cell.clone());\n            }\n        }\n        \n        // Compute diff\n        let diff = BufferDiff::compute(&old, &new);\n        \n        // Apply diff to old should produce new\n        let mut result = old.clone();\n        for (x, y) in diff.changes() {\n            let cell = new.get(*x, *y).unwrap().clone();\n            result.set(*x, *y, cell);\n        }\n        \n        // Verify buffers match\n        for y in 0..height {\n            for x in 0..width {\n                prop_assert_eq!(\n                    result.get(x, y),\n                    new.get(x, y),\n                    \"Mismatch at ({}, {})\", x, y\n                );\n            }\n        }\n    }\n}\n```\n\n### Category 2: Presenter Roundtrip\n**Property**: Presenter output applied to terminal model matches source buffer\n\n```rust\nproptest! {\n    #[test]\n    fn presenter_roundtrip_correct(\n        width in 10u16..80,\n        height in 5u16..40,\n        fill_ratio in 0.0f32..1.0,\n    ) {\n        // Create random buffer\n        let buffer = generate_random_buffer(width, height, fill_ratio);\n        \n        // Present to bytes\n        let mut output = Vec::new();\n        let mut presenter = Presenter::new(&mut output, TerminalCapabilities::basic());\n        presenter.present_full(&buffer, &GraphemePool::new(), &LinkRegistry::new())\n            .unwrap();\n        \n        // Apply to terminal model\n        let mut model = TerminalModel::new(width, height);\n        model.apply_output(&output).unwrap();\n        \n        // Verify match\n        prop_assert!(\n            model.matches(&buffer, &GraphemePool::new()),\n            \"Presenter output doesn't reproduce buffer\"\n        );\n    }\n}\n```\n\n### Category 3: Style State Never Leaks\n**Property**: After complete frame, style is reset\n\n```rust\nproptest! {\n    #[test]\n    fn style_state_reset_after_present(\n        width in 10u16..80,\n        height in 5u16..40,\n    ) {\n        let buffer = generate_styled_buffer(width, height);\n        \n        let mut output = Vec::new();\n        let mut presenter = Presenter::new(&mut output, TerminalCapabilities::basic());\n        presenter.present_full(&buffer, &GraphemePool::new(), &LinkRegistry::new())\n            .unwrap();\n        \n        // Output must end with SGR 0 (reset)\n        let output_str = String::from_utf8_lossy(&output);\n        prop_assert!(\n            output_str.ends_with(\"\\x1b[0m\") || \n            output_str.contains(\"\\x1b[0m\\x1b[\"),  // Reset before final positioning\n            \"Style not reset at end: {}\", &output_str[output_str.len().saturating_sub(50)..]\n        );\n    }\n}\n```\n\n### Category 4: Links Properly Closed\n**Property**: Every OSC 8 link open has corresponding close\n\n```rust\nproptest! {\n    #[test]\n    fn links_balanced(width in 10u16..80, height in 5u16..40) {\n        let buffer = generate_buffer_with_links(width, height);\n        \n        let mut output = Vec::new();\n        let mut presenter = Presenter::new(&mut output, TerminalCapabilities { \n            osc8_hyperlinks: true, \n            ..TerminalCapabilities::basic() \n        });\n        presenter.present_full(&buffer, &GraphemePool::new(), &links())\n            .unwrap();\n        \n        let output_str = String::from_utf8_lossy(&output);\n        \n        // Count link opens and closes\n        let opens = output_str.matches(\"\\x1b]8;;\").count()  // link with URL\n            + output_str.matches(\"\\x1b]8;id=\").count();     // link with id\n        let closes = output_str.matches(\"\\x1b]8;;\\x1b\\\\\").count();\n        \n        // Every open needs a close (or one final close)\n        prop_assert!(\n            opens <= closes,\n            \"Unbalanced links: {} opens, {} closes\", opens, closes\n        );\n    }\n}\n```\n\n### Category 5: Width Invariants\n**Property**: Rendering never writes beyond buffer bounds\n\n```rust\nproptest! {\n    #[test]\n    fn render_within_bounds(\n        width in 10u16..80,\n        height in 5u16..40,\n        text in \".*\",\n    ) {\n        let mut buffer = Buffer::new(width, height);\n        \n        // Render text into buffer (via whatever rendering API)\n        render_text(&mut buffer, &text, 0, 0, width);\n        \n        // Check no writes beyond bounds\n        // (Buffer should enforce this internally, but verify)\n        for y in 0..height {\n            let mut x = 0;\n            while x < width {\n                let cell = buffer.get(x, y).unwrap();\n                let cell_width = cell.width() as u16;\n                \n                // Wide char can't overflow right edge\n                prop_assert!(\n                    x + cell_width <= width,\n                    \"Wide char at ({}, {}) overflows (width {})\",\n                    x, y, cell_width\n                );\n                \n                x += cell_width.max(1);\n            }\n        }\n    }\n}\n```\n\n## Test Helpers Needed\n- `generate_random_buffer(w, h, fill_ratio)` - Random content\n- `generate_styled_buffer(w, h)` - Random styles\n- `generate_buffer_with_links(w, h)` - Random hyperlinks\n- `Arbitrary` impl for Cell, CellContent, CellAttrs, PackedRgba\n\n## Running Property Tests\n```bash\n# Run with many iterations\nPROPTEST_CASES=10000 cargo test --test prop_tests\n\n# Generate regression cases on failure\nPROPTEST_ENABLE_FAILURE_PERSISTENCE=1 cargo test\n```\n\n## Acceptance Criteria\n- [ ] Diff apply property test passes 10k iterations\n- [ ] Presenter roundtrip property test passes 10k iterations\n- [ ] Style reset property test passes 10k iterations\n- [ ] Link balance property test passes 10k iterations\n- [ ] Width bounds property test passes 10k iterations\n- [ ] No panics under property testing\n- [ ] Regression cases saved for failed tests\n\n## Location\n`tests/prop_tests.rs`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:21:15.739827546Z","created_by":"ubuntu","updated_at":"2026-01-31T23:21:23.803374191Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2x0j","depends_on_id":"bd-10i.11.1","type":"blocks","created_at":"2026-01-31T23:21:23.803332893Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2x0j","depends_on_id":"bd-10i.4.1","type":"blocks","created_at":"2026-01-31T23:21:22.515794868Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2x0j","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T23:21:23.163621516Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2yd","title":"Implement StyleSheet registry for named styles","description":"PHASE 4 - STYLESHEET REGISTRY\n\n## Background\nStyleSheet provides named style registration similar to CSS classes. Enables theme-able applications and consistent style reuse without hardcoding colors.\n\n## Technical Requirements\n- StyleSheet struct with HashMap<StyleId, Style>\n- StyleId: either interned string or u32 index\n- Register named styles: stylesheet.define('error', Style::new().fg(RED).bold())\n- Lookup by name: stylesheet.get('error')\n- Style composition: stylesheet.compose(['base', 'error']) merges in order\n- Default styles for common semantic names (error, warning, info, success, muted)\n\n## Design Rationale\nNamed styles decouple visual appearance from widget logic. Themes can override the stylesheet without changing widget code. Matches patterns from Textual/Rich.\n\n## Acceptance Criteria\n- [ ] StyleSheet with define/get/compose API\n- [ ] StyleId type (string or integer based on perf analysis)\n- [ ] Thread-safe for read access (RwLock or immutable after init)\n- [ ] Default semantic style set\n- [ ] Style merging for composition\n- [ ] Clear error handling for missing styles\n\n## Integration Points\n- Widgets reference styles by name\n- Theme loading populates stylesheet\n- Buffer.set_style() accepts Style or StyleId\n\n## Location: ftui-style crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:18:40.688288609Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:11.824857915Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2yd","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T22:22:11.824828780Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2yu","title":"Implement run grouping and style-run coalescing in Presenter","description":"# Implement Run Grouping and Style-Run Coalescing in Presenter\n\n## Background\nADR-002 and Plan Section 8.1 specify that the Presenter must emit \"grouped runs\" rather than per-cell cursor moves. This is critical for minimal ANSI output and flicker reduction.\n\n## Why This Matters\nWithout run grouping:\n- Each changed cell requires a cursor move: `\\x1b[y;xH`\n- Each cell change might reset style: `\\x1b[0m...`\n- Output is O(changes × escape_overhead)\n- Slow terminals show visible tearing\n\nWith run grouping:\n- Consecutive changed cells emit one cursor move\n- Style only changes when cell style differs\n- Output is O(runs × escape_overhead)\n- Smooth, fast rendering\n\n## Technical Design\n\n### ChangeRun Structure\n```rust\n/// A contiguous run of changed cells on a single row\npub struct ChangeRun {\n    pub y: u16,   // Row\n    pub x0: u16,  // Start column (inclusive)\n    pub x1: u16,  // End column (inclusive)\n}\n```\n\n### Run Grouping Algorithm\n```rust\nimpl BufferDiff {\n    /// Convert point changes into row-major runs\n    pub fn runs(&self, width: u16) -> Vec<ChangeRun> {\n        if self.changes.is_empty() {\n            return Vec::new();\n        }\n        \n        // Sort by (y, x) for row-major order\n        let mut sorted: Vec<_> = self.changes.iter().copied().collect();\n        sorted.sort_by_key(|(x, y)| (*y, *x));\n        \n        let mut runs = Vec::new();\n        let mut i = 0;\n        \n        while i < sorted.len() {\n            let (x0, y) = sorted[i];\n            let mut x1 = x0;\n            i += 1;\n            \n            // Coalesce consecutive x positions on same row\n            while i < sorted.len() {\n                let (x, yy) = sorted[i];\n                if yy != y || x != x1 + 1 {\n                    break;\n                }\n                x1 = x;\n                i += 1;\n            }\n            \n            runs.push(ChangeRun { y, x0, x1 });\n        }\n        \n        runs\n    }\n}\n```\n\n### Style-Run Coalescing\nWithin a run, group cells by style to minimize SGR changes:\n\n```rust\nimpl Presenter {\n    fn emit_run(\n        &mut self,\n        run: &ChangeRun,\n        buffer: &Buffer,\n        pool: &GraphemePool,\n        links: &LinkRegistry,\n    ) -> io::Result<()> {\n        // Single cursor move for entire run\n        self.move_cursor_to(run.x0, run.y)?;\n        \n        // Emit cells, tracking style changes\n        for x in run.x0..=run.x1 {\n            let cell = buffer.get_unchecked(x, run.y);\n            if cell.is_continuation() {\n                continue;  // Skip wide char continuations\n            }\n            \n            // Only emit style change if different from current\n            self.emit_style_if_changed(cell)?;\n            self.emit_link_if_changed(cell, links)?;\n            self.emit_content(cell, pool)?;\n            \n            // Cursor advances naturally after character output\n            self.cursor_x += cell.width() as u16;\n        }\n        \n        Ok(())\n    }\n    \n    fn emit_style_if_changed(&mut self, cell: &Cell) -> io::Result<()> {\n        let new_style = CellStyle {\n            fg: cell.fg,\n            bg: cell.bg,\n            attrs: cell.attrs.flags(),\n        };\n        \n        if Some(new_style) == self.current_style {\n            return Ok(());  // No change needed\n        }\n        \n        // Emit minimal SGR change\n        // v1: reset+apply (simple, correct)\n        // future: incremental (fewer bytes)\n        self.writer.write_all(b\"\\x1b[0\")?;\n        // ... emit style codes ...\n        self.writer.write_all(b\"m\")?;\n        self.current_style = Some(new_style);\n        \n        Ok(())\n    }\n}\n```\n\n### Optimization Opportunities\n1. **Skip cursor move when at expected position** - After emitting a run, cursor may be at next change\n2. **Batch style attributes** - Emit `\\x1b[0;1;38;2;r;g;bm` not separate sequences\n3. **Link run grouping** - Keep link open across cells with same link_id\n4. **Empty cell optimization** - Runs of spaces can use `\\x1b[nX` (erase characters)\n\n## Performance Targets\n- Cursor moves reduced by 50-90% vs naive\n- Style changes reduced by 30-70%\n- Bytes per frame for \"small changes\" is O(changes), not O(screen)\n\n## Tests Required\n- [ ] Empty diff produces no runs\n- [ ] Single cell change produces one run\n- [ ] Consecutive cells on row produce one run\n- [ ] Non-consecutive cells produce multiple runs\n- [ ] Cross-row changes produce separate runs\n- [ ] Style tracking minimizes SGR output\n- [ ] Link tracking minimizes OSC 8 output\n- [ ] Benchmark: bytes emitted vs naive approach\n\n## Acceptance Criteria\n- [ ] BufferDiff::runs() implemented\n- [ ] Presenter uses runs for emission\n- [ ] Style-run coalescing active\n- [ ] Link-run coalescing active\n- [ ] Benchmark shows byte reduction\n- [ ] PTY tests verify correct output\n\n## Location: ftui-render crate (diff.rs, presenter.rs)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:52:42.940861576Z","created_by":"ubuntu","updated_at":"2026-01-31T22:54:03.212147662Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2yu","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T22:54:03.212116303Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2yu","depends_on_id":"bd-10i.4.1","type":"blocks","created_at":"2026-01-31T22:54:02.859312055Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-2yu","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T22:54:02.508150100Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-2zd","title":"Implement scroll-region optimization for inline mode","description":"PHASE 2.5 - SCROLL REGION OPTIMIZATION\n\n## Background\nScroll regions (DECSTBM) can optimize inline mode by pinning the UI region and letting logs scroll naturally. This is an OPTIMIZATION, not the baseline.\n\n## Technical Requirements\n\n### DECSTBM Usage\n- Set scroll region to exclude UI: ESC[1;{log_bottom}r\n- Logs scroll within region, UI stays pinned\n- Must restore scroll region on exit\n\n### Capability Gating\nOnly use when:\n- caps.scroll_region == true\n- NOT in tmux/screen/zellij (mux passthrough issues)\n- Terminal known to support correctly\n\n### Implementation\n\npub struct ScrollRegionPresenter {\n    ui_height: u16,\n    scroll_region_active: bool,\n}\n\nimpl ScrollRegionPresenter {\n    pub fn setup_scroll_region(&mut self, writer: &mut TerminalWriter) {\n        if !self.can_use_scroll_region() {\n            return;  // Fall back to overlay\n        }\n        \n        let (_, height) = writer.size();\n        let log_bottom = height - self.ui_height;\n        \n        // Set scroll region (excludes UI at bottom)\n        write!(writer, \"\\x1b[1;{}r\", log_bottom)?;\n        self.scroll_region_active = true;\n    }\n    \n    pub fn restore_scroll_region(&mut self, writer: &mut TerminalWriter) {\n        if self.scroll_region_active {\n            writer.write_all(b\"\\x1b[r\")?;  // Reset to full screen\n            self.scroll_region_active = false;\n        }\n    }\n    \n    fn can_use_scroll_region(&self) -> bool {\n        let caps = TerminalCapabilities::detect();\n        caps.scroll_region && \n        !caps.in_tmux &&\n        !caps.in_screen &&\n        !caps.in_zellij\n    }\n}\n\n### Mux Detection\n- TMUX env var presence\n- TERM containing \"screen\"\n- ZELLIJ env var presence\n\n### Resize Handling\nOn terminal resize:\n1. Disable scroll region\n2. Recalculate dimensions\n3. Re-enable if still appropriate\n\n## Tests Required\n- [ ] Scroll region setup/teardown\n- [ ] Logs scroll within region\n- [ ] UI stays pinned at bottom\n- [ ] Mux detection works\n- [ ] Resize re-anchoring\n- [ ] PTY test: scroll region behavior\n\n## Acceptance Criteria\n- [ ] DECSTBM used correctly\n- [ ] Capability gating works\n- [ ] Mux passthrough disabled\n- [ ] Fallback to overlay works\n- [ ] Clean restore on exit\n\n## Location: ftui-render crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:30:39.520720244Z","created_by":"ubuntu","updated_at":"2026-01-31T22:32:18.606601626Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2zd","depends_on_id":"bd-fbp","type":"blocks","created_at":"2026-01-31T22:32:18.606568613Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-30h","title":"Implement Sparkline and Chart widgets","description":"PHASE 7 - EXTRAS: DATA VISUALIZATION\n\n## Background\nSparkline and Chart widgets provide data visualization for metrics, trends, and timeseries. Common requirement for monitoring dashboards and CLI tools.\n\n## Technical Requirements\n\n### Sparkline Widget\n- Compact single-line visualization\n- Data as Vec<f64> or iterator\n- Auto-scaling to min/max range\n- Configurable bar character set (▁▂▃▄▅▆▇█)\n- Color gradient based on value\n- Reference line support (mean, threshold)\n\n### Chart Widget (BarChart, LineChart)\n- BarChart:\n  - Horizontal/vertical orientation\n  - Grouped and stacked modes\n  - Labels and value display\n  - Color per series\n- LineChart:\n  - Multiple series support\n  - Point markers optional\n  - Area fill under line\n  - Axis labels and ticks\n  - Legend positioning\n\n## Design Rationale\nFeature-gated for projects that need visualization. Sparkline is minimal overhead. Full charts use Canvas internally for rendering.\n\n## Acceptance Criteria\n- [ ] Sparkline with auto-scaling\n- [ ] Sparkline color gradient\n- [ ] BarChart with orientations\n- [ ] BarChart grouped/stacked\n- [ ] LineChart multi-series\n- [ ] LineChart axis rendering\n- [ ] Feature gate: charts\n\n## Location: ftui-extras crate (feature = \"charts\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:19:54.798796411Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:35.360701005Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-30h","depends_on_id":"bd-3k4","type":"blocks","created_at":"2026-01-31T22:22:35.360672091Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-35p","title":"Implement Progress and Spinner widgets","description":"# Implement Progress and Spinner Widgets\n\n## Background & Strategic Importance\nProgress indicators and spinners are essential for agent harness UIs showing tool execution status. When an agent is running a tool (like `grep`, `cargo build`, or an API call), users need visual feedback that something is happening. These widgets provide that feedback.\n\n## Why P2 (But Blocks Agent Harness)\nWhile marked P2, these widgets are depended on by the Agent Harness reference application (bd-2kj). The harness needs:\n- Spinner to show \"tool running\" state\n- Progress bar for operations with known duration/steps\n\n---\n\n## Technical Design\n\n### Spinner Widget\n\n```rust\nuse tracing::{debug, trace, instrument};\n\n/// Animated spinner for indeterminate progress.\n///\n/// # Design Rationale\n/// - Static frame arrays for memory efficiency\n/// - Stateful widget pattern for animation frame tracking\n/// - Multiple presets for different aesthetic preferences\n/// - Label support for context (\"Loading...\" text)\npub struct Spinner {\n    /// Animation frames (static borrowed strings)\n    frames: &'static [&'static str],\n    /// Style for spinner character\n    style: Style,\n    /// Optional label shown after spinner\n    label: Option<Text>,\n    /// Speed in ticks per frame (default: 1)\n    speed: u8,\n}\n\n/// Preset spinner animations.\npub mod spinners {\n    /// Braille dot pattern (smooth, modern)\n    pub const DOTS: &[&str] = &[\"⠋\", \"⠙\", \"⠹\", \"⠸\", \"⠼\", \"⠴\", \"⠦\", \"⠧\", \"⠇\", \"⠏\"];\n    /// Classic ASCII (works everywhere)\n    pub const LINE: &[&str] = &[\"|\", \"/\", \"-\", \"\\\\\"];\n    /// Full braille rotation\n    pub const BRAILLE: &[&str] = &[\"⣾\", \"⣽\", \"⣻\", \"⢿\", \"⡿\", \"⣟\", \"⣯\", \"⣷\"];\n    /// Moon phases (fun, distinctive)\n    pub const MOON: &[&str] = &[\"🌑\", \"🌒\", \"🌓\", \"🌔\", \"🌕\", \"🌖\", \"🌗\", \"🌘\"];\n    /// Block animation\n    pub const BLOCKS: &[&str] = &[\"▖\", \"▘\", \"▝\", \"▗\"];\n    /// Arrow rotation\n    pub const ARROWS: &[&str] = &[\"←\", \"↖\", \"↑\", \"↗\", \"→\", \"↘\", \"↓\", \"↙\"];\n    /// Simple dots\n    pub const SIMPLE_DOTS: &[&str] = &[\".\", \"..\", \"...\", \"..\"];\n}\n\n/// State for spinner animation.\npub struct SpinnerState {\n    /// Current frame index\n    frame: usize,\n    /// Tick counter for speed control\n    tick_count: u32,\n}\n\nimpl SpinnerState {\n    pub fn new() -> Self {\n        Self { frame: 0, tick_count: 0 }\n    }\n\n    /// Advance to next frame. Call this from runtime tick handler.\n    pub fn tick(&mut self, total_frames: usize, speed: u8) {\n        self.tick_count += 1;\n        if self.tick_count >= speed as u32 {\n            self.tick_count = 0;\n            self.frame = (self.frame + 1) % total_frames;\n            trace!(frame = self.frame, \"Spinner tick\");\n        }\n    }\n}\n```\n\n### Spinner API\n\n```rust\nimpl Spinner {\n    /// Create spinner with dots preset.\n    pub fn new() -> Self {\n        debug!(\"Creating Spinner with dots preset\");\n        Self {\n            frames: spinners::DOTS,\n            style: Style::default().fg(Color::Cyan),\n            label: None,\n            speed: 1,\n        }\n    }\n\n    /// Use a different preset.\n    pub fn preset(mut self, frames: &'static [&'static str]) -> Self {\n        self.frames = frames;\n        self\n    }\n\n    /// Add label text.\n    pub fn label(mut self, label: impl Into<Text>) -> Self {\n        self.label = Some(label.into());\n        self\n    }\n\n    /// Set style for spinner character.\n    pub fn style(mut self, style: Style) -> Self {\n        self.style = style;\n        self\n    }\n\n    /// Set animation speed (ticks per frame, higher = slower).\n    pub fn speed(mut self, speed: u8) -> Self {\n        self.speed = speed.max(1);\n        self\n    }\n}\n\nimpl StatefulWidget for Spinner {\n    type State = SpinnerState;\n\n    fn render(&self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        if area.width == 0 || area.height == 0 {\n            return;\n        }\n\n        // Render spinner frame\n        let frame = self.frames[state.frame % self.frames.len()];\n        let spinner_width = unicode_width::UnicodeWidthStr::width(frame) as u16;\n        buf.set_string(area.x, area.y, frame, self.style);\n\n        // Render label if present\n        if let Some(ref label) = self.label {\n            let label_x = area.x + spinner_width + 1;\n            if label_x < area.x + area.width {\n                let label_area = Rect::new(label_x, area.y, area.width - spinner_width - 1, 1);\n                label.render(label_area, buf);\n            }\n        }\n    }\n}\n```\n\n### Progress Bar Widget\n\n```rust\n/// Progress bar for determinate progress (known total).\n///\n/// # Design Rationale\n/// - f64 ratio for smooth progress (0.0 to 1.0)\n/// - Configurable fill characters for aesthetic options\n/// - Label position options (left, right, center, none)\n/// - ETA calculation as optional companion\npub struct ProgressBar {\n    /// Progress ratio (0.0 to 1.0)\n    ratio: f64,\n    /// Bar style\n    bar_style: ProgressStyle,\n    /// Optional label (e.g., \"50%\" or \"5/10\")\n    label: Option<String>,\n    /// Label position\n    label_position: LabelPosition,\n}\n\n#[derive(Clone, Copy, Debug, Default)]\npub enum LabelPosition {\n    /// Label on left of bar\n    Left,\n    /// Label on right of bar\n    Right,\n    /// Label centered over bar\n    #[default]\n    Center,\n    /// No label\n    Hidden,\n}\n\n/// Visual style for progress bar.\npub struct ProgressStyle {\n    /// Style for filled portion\n    fill_style: Style,\n    /// Style for empty portion\n    empty_style: Style,\n    /// Style for partial fill (edge)\n    partial_style: Style,\n    /// Characters: [filled, partial, empty]\n    chars: ProgressChars,\n}\n\npub type ProgressChars = [char; 3];\n\n/// Preset progress bar styles.\npub mod progress_styles {\n    use super::ProgressChars;\n    /// Block style (Unicode full/half/empty blocks)\n    pub const BLOCK: ProgressChars = ['█', '▓', '░'];\n    /// ASCII style (works everywhere)\n    pub const ASCII: ProgressChars = ['=', '>', ' '];\n    /// Dot style\n    pub const DOTS: ProgressChars = ['●', '○', '○'];\n    /// Fine blocks (8 levels)\n    pub const FINE: ProgressChars = ['█', '▌', ' '];\n}\n```\n\n### Progress Bar API\n\n```rust\nimpl ProgressBar {\n    /// Create progress bar at 0%.\n    pub fn new() -> Self {\n        debug!(\"Creating ProgressBar\");\n        Self {\n            ratio: 0.0,\n            bar_style: ProgressStyle::default(),\n            label: None,\n            label_position: LabelPosition::Center,\n        }\n    }\n\n    /// Set progress ratio (clamped to 0.0..=1.0).\n    pub fn ratio(mut self, ratio: f64) -> Self {\n        self.ratio = ratio.clamp(0.0, 1.0);\n        self\n    }\n\n    /// Set progress from current/total.\n    pub fn progress(mut self, current: u64, total: u64) -> Self {\n        self.ratio = if total == 0 { 0.0 } else { current as f64 / total as f64 };\n        self\n    }\n\n    /// Auto-generate percentage label.\n    pub fn with_percentage_label(mut self) -> Self {\n        self.label = Some(format!(\"{:.0}%\", self.ratio * 100.0));\n        self\n    }\n\n    /// Auto-generate count label.\n    pub fn with_count_label(mut self, current: u64, total: u64) -> Self {\n        self.label = Some(format!(\"{}/{}\", current, total));\n        self\n    }\n\n    /// Set custom label.\n    pub fn label(mut self, label: impl Into<String>) -> Self {\n        self.label = Some(label.into());\n        self\n    }\n\n    /// Set label position.\n    pub fn label_position(mut self, position: LabelPosition) -> Self {\n        self.label_position = position;\n        self\n    }\n\n    /// Use a preset style.\n    pub fn style(mut self, style: ProgressStyle) -> Self {\n        self.bar_style = style;\n        self\n    }\n}\n\nimpl Widget for ProgressBar {\n    #[instrument(skip(self, area, buf), fields(ratio = self.ratio))]\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        if area.width == 0 || area.height == 0 {\n            return;\n        }\n\n        let width = area.width as usize;\n        let filled_width = (self.ratio * width as f64) as usize;\n        let partial = (self.ratio * width as f64).fract();\n\n        // Build bar string\n        let mut bar = String::with_capacity(width * 4); // Unicode can be multi-byte\n\n        // Filled portion\n        for _ in 0..filled_width.min(width) {\n            bar.push(self.bar_style.chars[0]);\n        }\n\n        // Partial fill (if at edge)\n        if filled_width < width && partial > 0.0 {\n            bar.push(self.bar_style.chars[1]);\n        }\n\n        // Empty portion\n        let remaining = width.saturating_sub(filled_width).saturating_sub(if partial > 0.0 { 1 } else { 0 });\n        for _ in 0..remaining {\n            bar.push(self.bar_style.chars[2]);\n        }\n\n        // Render bar\n        let bar_graphemes: Vec<&str> = bar.graphemes(true).take(width).collect();\n        for (i, g) in bar_graphemes.iter().enumerate() {\n            let style = if i < filled_width {\n                self.bar_style.fill_style\n            } else if i == filled_width && partial > 0.0 {\n                self.bar_style.partial_style\n            } else {\n                self.bar_style.empty_style\n            };\n            buf.set_string(area.x + i as u16, area.y, g, style);\n        }\n\n        // Render label\n        if let Some(ref label) = self.label {\n            let label_x = match self.label_position {\n                LabelPosition::Left => area.x,\n                LabelPosition::Right => area.x + area.width - label.len() as u16,\n                LabelPosition::Center => area.x + (area.width - label.len() as u16) / 2,\n                LabelPosition::Hidden => return,\n            };\n            buf.set_string(label_x, area.y, label, Style::default().add_modifier(Modifier::BOLD));\n        }\n\n        trace!(filled_width, \"Rendered ProgressBar\");\n    }\n}\n```\n\n### Progress with ETA\n\n```rust\n/// Helper for calculating ETA and throughput.\n///\n/// Use this alongside ProgressBar for time estimates.\npub struct ProgressWithEta {\n    /// Current progress count\n    current: u64,\n    /// Total count\n    total: u64,\n    /// When tracking started\n    started_at: Instant,\n}\n\nimpl ProgressWithEta {\n    pub fn new(total: u64) -> Self {\n        debug!(total, \"Creating ProgressWithEta\");\n        Self {\n            current: 0,\n            total,\n            started_at: Instant::now(),\n        }\n    }\n\n    /// Update current progress.\n    pub fn set_current(&mut self, current: u64) {\n        self.current = current.min(self.total);\n    }\n\n    /// Increment progress by one.\n    pub fn inc(&mut self) {\n        self.current = (self.current + 1).min(self.total);\n    }\n\n    /// Get completion ratio.\n    pub fn ratio(&self) -> f64 {\n        if self.total == 0 { 0.0 } else { self.current as f64 / self.total as f64 }\n    }\n\n    /// Get elapsed time.\n    pub fn elapsed(&self) -> Duration {\n        self.started_at.elapsed()\n    }\n\n    /// Estimate time remaining.\n    pub fn eta(&self) -> Duration {\n        if self.current == 0 {\n            return Duration::MAX;\n        }\n        let elapsed = self.elapsed();\n        let rate = self.current as f64 / elapsed.as_secs_f64();\n        let remaining = self.total - self.current;\n        Duration::from_secs_f64(remaining as f64 / rate)\n    }\n\n    /// Get items per second throughput.\n    pub fn items_per_second(&self) -> f64 {\n        let elapsed = self.elapsed().as_secs_f64();\n        if elapsed == 0.0 { 0.0 } else { self.current as f64 / elapsed }\n    }\n\n    /// Format ETA as human-readable string.\n    pub fn eta_string(&self) -> String {\n        let eta = self.eta();\n        if eta == Duration::MAX {\n            \"calculating...\".to_string()\n        } else if eta.as_secs() < 60 {\n            format!(\"{}s\", eta.as_secs())\n        } else if eta.as_secs() < 3600 {\n            format!(\"{}m {}s\", eta.as_secs() / 60, eta.as_secs() % 60)\n        } else {\n            format!(\"{}h {}m\", eta.as_secs() / 3600, (eta.as_secs() % 3600) / 60)\n        }\n    }\n}\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tracing_test::traced_test;\n\n    // --- Spinner Tests ---\n\n    #[test]\n    fn test_spinner_frame_cycling() {\n        let spinner = Spinner::new();\n        let mut state = SpinnerState::new();\n        let total = spinners::DOTS.len();\n\n        for expected in 0..total * 2 {\n            assert_eq!(state.frame, expected % total);\n            state.tick(total, 1);\n        }\n    }\n\n    #[test]\n    fn test_spinner_with_label() {\n        let spinner = Spinner::new().label(\"Loading...\");\n        // Should render spinner + \" Loading...\"\n        let area = Rect::new(0, 0, 20, 1);\n        let mut buf = Buffer::empty(area);\n        let mut state = SpinnerState::new();\n        spinner.render(area, &mut buf, &mut state);\n        // Verify label is rendered\n    }\n\n    #[test]\n    fn test_spinner_speed_control() {\n        let spinner = Spinner::new().speed(2);\n        let mut state = SpinnerState::new();\n        let total = spinners::DOTS.len();\n\n        // Should take 2 ticks to advance frame\n        state.tick(total, 2);\n        assert_eq!(state.frame, 0); // Not advanced yet\n        state.tick(total, 2);\n        assert_eq!(state.frame, 1); // Now advanced\n    }\n\n    // --- ProgressBar Tests ---\n\n    #[test]\n    fn test_progress_bar_empty() {\n        let bar = ProgressBar::new().ratio(0.0);\n        let area = Rect::new(0, 0, 10, 1);\n        let mut buf = Buffer::empty(area);\n        bar.render(area, &mut buf);\n        // All empty chars\n    }\n\n    #[test]\n    fn test_progress_bar_full() {\n        let bar = ProgressBar::new().ratio(1.0);\n        let area = Rect::new(0, 0, 10, 1);\n        let mut buf = Buffer::empty(area);\n        bar.render(area, &mut buf);\n        // All filled chars\n    }\n\n    #[test]\n    fn test_progress_bar_half() {\n        let bar = ProgressBar::new().ratio(0.5);\n        let area = Rect::new(0, 0, 10, 1);\n        let mut buf = Buffer::empty(area);\n        bar.render(area, &mut buf);\n        // 5 filled, 5 empty\n    }\n\n    #[test]\n    fn test_progress_bar_overflow() {\n        let bar = ProgressBar::new().ratio(1.5); // Over 100%\n        assert!((bar.ratio - 1.0).abs() < f64::EPSILON); // Clamped to 1.0\n    }\n\n    #[test]\n    fn test_progress_from_count() {\n        let bar = ProgressBar::new().progress(50, 100);\n        assert!((bar.ratio - 0.5).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn test_progress_with_label() {\n        let bar = ProgressBar::new().ratio(0.5).with_percentage_label();\n        assert_eq!(bar.label, Some(\"50%\".to_string()));\n    }\n\n    // --- ProgressWithEta Tests ---\n\n    #[test]\n    fn test_eta_calculation() {\n        let mut progress = ProgressWithEta::new(100);\n        // Simulate some elapsed time\n        std::thread::sleep(Duration::from_millis(100));\n        progress.set_current(50);\n\n        let eta = progress.eta();\n        // ETA should be roughly equal to elapsed (50% done in 100ms = 100ms remaining)\n        assert!(eta.as_millis() > 50 && eta.as_millis() < 200);\n    }\n\n    #[test]\n    fn test_items_per_second() {\n        let mut progress = ProgressWithEta::new(100);\n        std::thread::sleep(Duration::from_millis(100));\n        progress.set_current(10);\n\n        let rate = progress.items_per_second();\n        // Should be roughly 100 items/sec (10 items in 100ms)\n        assert!(rate > 50.0 && rate < 200.0);\n    }\n\n    #[test]\n    fn test_wide_character_spinner() {\n        let spinner = Spinner::new().preset(spinners::MOON);\n        let area = Rect::new(0, 0, 10, 1);\n        let mut buf = Buffer::empty(area);\n        let mut state = SpinnerState::new();\n        spinner.render(area, &mut buf, &mut state);\n        // Should handle wide emoji correctly\n    }\n}\n```\n\n---\n\n## Acceptance Criteria\n\n### Spinner\n- [ ] Multiple preset animations available (dots, line, braille, moon, etc.)\n- [ ] Animation advances on tick()\n- [ ] Speed control works (ticks per frame)\n- [ ] Label renders after spinner\n- [ ] Wide character spinners (emoji) work correctly\n\n### Progress Bar\n- [ ] Ratio 0.0 renders empty bar\n- [ ] Ratio 1.0 renders full bar\n- [ ] Partial fill renders correctly\n- [ ] Labels render at correct positions\n- [ ] Multiple style presets available\n- [ ] Works at any width\n\n### ProgressWithEta\n- [ ] ETA calculation is reasonable\n- [ ] Items per second is accurate\n- [ ] eta_string() formats nicely\n\n### Integration\n- [ ] Works in Agent Harness UI\n- [ ] No flicker during animation\n- [ ] Correct width handling\n\n### Logging\n- [ ] debug! on creation\n- [ ] trace! on tick/render with state info\n\n---\n\n## Location\n`ftui-widgets/src/widgets/spinner.rs`\n`ftui-widgets/src/widgets/progress.rs`","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:31:44.547803785Z","created_by":"ubuntu","updated_at":"2026-02-01T00:34:59.320753452Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-35p","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:32:20.218510171Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-376","title":"Implement interactive widgets (List, Scrollbar, Input)","description":"PHASE 5 - INTERACTIVE WIDGETS\n\n## Background\nInteractive widgets handle user input and state changes. List provides selectable items, Scrollbar visualizes scroll position, Input accepts text entry.\n\n## Technical Requirements\n\n### List Widget\n- Items with optional styling per item\n- Single/multi selection modes\n- Keyboard navigation (up/down/pageup/pagedown/home/end)\n- Highlight style for selected item\n- Scroll into view on selection change\n- Item filtering/search support\n\n### Scrollbar Widget\n- Vertical and horizontal orientation\n- Track, thumb, and arrow styles\n- Thumb size proportional to content ratio\n- Click/drag support (if mouse enabled)\n- Auto-hide when content fits\n\n### Input Widget\n- Single-line text input\n- Cursor positioning with blinking\n- Text selection (shift+arrow)\n- Clipboard operations (copy/paste)\n- Placeholder text when empty\n- Password mode (masked input)\n- Input validation hooks\n\n## Design Rationale\nThese widgets encapsulate common interaction patterns. State management follows Elm architecture - widgets emit events, parent handles state updates.\n\n## Acceptance Criteria\n- [ ] List with selection modes\n- [ ] List keyboard navigation\n- [ ] Scrollbar sizing algorithm\n- [ ] Scrollbar orientation support\n- [ ] Input cursor management\n- [ ] Input text selection\n- [ ] All widgets implement StatefulWidget trait\n- [ ] Event emission for state changes\n\n## StatefulWidget Trait\npub trait StatefulWidget {\n    type State;\n    fn render(&self, area: Rect, buf: &mut Buffer, state: &mut Self::State);\n}\n\n## Location: ftui-widgets crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:33.823793890Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:20.398953138Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-376","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:22:20.398922120Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-376","depends_on_id":"bd-wr2","type":"blocks","created_at":"2026-01-31T22:22:20.135191747Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-381","title":"Implement syntax highlighting for code blocks","description":"PHASE 7 - EXTRAS: SYNTAX HIGHLIGHTING\n\n## Background\nSyntax highlighting is essential for code-centric TUI applications. Feature-gated as optional extra.\n\n## Technical Requirements\n\n### Highlighting Engine\n- Use syntect or tree-sitter for parsing\n- Support common languages: Rust, Python, TypeScript, JSON, YAML, TOML, Markdown\n- Theme integration (VS Code themes, base16, etc.)\n- Line number gutter option\n- Diff highlighting (additions, deletions)\n\n### API Design\n\npub struct SyntaxHighlighter {\n    syntax_set: SyntaxSet,\n    theme_set: ThemeSet,\n    current_theme: String,\n}\n\nimpl SyntaxHighlighter {\n    pub fn new() -> Self;\n    \n    /// Highlight code string\n    pub fn highlight(&self, code: &str, lang: &str) -> Text;\n    \n    /// Highlight with line numbers\n    pub fn highlight_numbered(&self, code: &str, lang: &str, start_line: usize) -> Text;\n    \n    /// Set theme\n    pub fn set_theme(&mut self, name: &str);\n    \n    /// Get available themes\n    pub fn themes(&self) -> &[String];\n}\n\n### Performance Considerations\n- Lazy syntax loading\n- Incremental re-highlighting for edits\n- Cache parsed syntax per file extension\n- Background highlighting for large files\n\n## Tests Required\n- [ ] Rust code highlights correctly\n- [ ] Unknown language falls back gracefully\n- [ ] Theme switching works\n- [ ] Line numbers align correctly\n- [ ] Diff highlighting marks changes\n\n## Acceptance Criteria\n- [ ] 10+ languages supported\n- [ ] 3+ built-in themes\n- [ ] Integration with Paragraph widget\n- [ ] Performance: < 10ms for 1000 lines\n\n## Location: ftui-extras crate (feature = \"syntax\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:44:16.720155418Z","created_by":"ubuntu","updated_at":"2026-02-01T00:32:04.263566020Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-381","depends_on_id":"bd-22q","type":"blocks","created_at":"2026-01-31T22:44:35.866274611Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-381","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:44:33.713706561Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-381","depends_on_id":"bd-3ky.13","type":"blocks","created_at":"2026-02-01T00:32:03.661288488Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-381","depends_on_id":"bd-3ky.3","type":"blocks","created_at":"2026-02-01T00:32:03.039902379Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-381","depends_on_id":"bd-3ky.4","type":"blocks","created_at":"2026-02-01T00:32:04.263523440Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-397","title":"Create adversarial tests for escape injection","description":"TESTING - ADVERSARIAL SECURITY TESTS\n\n## Background\nFrankenTUI must be secure against untrusted content. Escape sequences in user-provided text could corrupt the terminal or execute malicious sequences. This implements ADR-006 (Sanitize-by-Default).\n\n## Threat Model\n\n### Attack Vectors\n1. **Log injection**: Untrusted output contains escape sequences\n2. **Title injection**: OSC sequences to change window title\n3. **Clipboard injection**: OSC 52 to set clipboard\n4. **Cursor corruption**: CSI sequences to move cursor\n5. **Mode hijacking**: Enabling raw mode, mouse, etc.\n\n### Example Malicious Inputs\n- \"\\x1b[2J\" - Clear screen\n- \"\\x1b[H\" - Home cursor\n- \"\\x1b]0;pwned\\x07\" - Set window title\n- \"\\x1b]52;c;SGVsbG8=\\x07\" - Set clipboard\n- \"\\x1b[?1049h\" - Enter alt screen\n- \"\\x1b[?1000h\" - Enable mouse\n- \"\\x1b[31mred\\x1b[0m\" - Color injection\n\n## Technical Requirements\n\n### Sanitizer Implementation\npub fn sanitize_for_display(input: &str) -> Cow<str> {\n    // Fast path: no control characters\n    if !input.bytes().any(|b| b < 0x20 || b == 0x7F || b == 0x1B) {\n        return Cow::Borrowed(input);\n    }\n    \n    // Slow path: filter control sequences\n    let mut output = String::with_capacity(input.len());\n    let mut chars = input.chars().peekable();\n    \n    while let Some(c) = chars.next() {\n        match c {\n            '\\x1b' => skip_escape_sequence(&mut chars),\n            c if c.is_control() && c != '\\n' && c != '\\t' => {\n                // Replace with visual representation\n                output.push_str(&format!(\"^{}\", (c as u8 + 64) as char));\n            }\n            _ => output.push(c),\n        }\n    }\n    \n    Cow::Owned(output)\n}\n\n### Test Categories\n\n#### 1. Escape Sequence Filtering\n- [ ] ESC [ ... (CSI) filtered\n- [ ] ESC ] ... (OSC) filtered\n- [ ] ESC P ... (DCS) filtered\n- [ ] ESC _ ... (APC) filtered\n- [ ] ESC ^ ... (PM) filtered\n\n#### 2. Control Character Handling\n- [ ] NUL (0x00) filtered\n- [ ] BEL (0x07) filtered\n- [ ] BS (0x08) filtered\n- [ ] Tab (0x09) preserved\n- [ ] LF (0x0A) preserved\n- [ ] CR (0x0D) handled\n- [ ] DEL (0x7F) filtered\n\n#### 3. Incomplete Sequence Handling\n- [ ] Truncated ESC at end\n- [ ] Truncated CSI at end\n- [ ] Truncated OSC at end\n- [ ] Invalid sequence bytes\n\n#### 4. Raw Passthrough (Explicit Opt-In)\n- [ ] raw_text() API exists\n- [ ] Loud documentation warning\n- [ ] Works for ANSI colors when intended\n\n## PTY Tests\n\n### Test Script\nfor payload in \"${MALICIOUS_PAYLOADS[@]}\"; do\n    # Run payload through ftui log viewer\n    echo \"$payload\" | ftui-test-harness\n    \n    # Verify terminal state unchanged\n    verify_terminal_state\n    \n    # Verify no escape sequences in output\n    verify_no_escapes\ndone\n\n## Acceptance Criteria\n- [ ] All ESC/CSI/OSC/DCS/APC filtered by default\n- [ ] Control characters filtered except tab/newline\n- [ ] Fast path for clean input (no allocation)\n- [ ] Raw passthrough API documented with warnings\n- [ ] PTY tests verify terminal state preserved\n- [ ] Fuzz testing for parser robustness\n\n## Location: ftui-text crate + tests/adversarial/","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:32:05.241501461Z","created_by":"ubuntu","updated_at":"2026-01-31T23:23:45.436902390Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-397","depends_on_id":"bd-10i.11.2","type":"blocks","created_at":"2026-01-31T22:32:20.756074625Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-397","depends_on_id":"bd-10i.8.4","type":"blocks","created_at":"2026-01-31T23:23:45.436858908Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-397","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:32:20.492615671Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3aqs","title":"Implement output bytes tracking and budget monitoring","description":"# Implement output bytes tracking and budget monitoring\n\n## Background\nPlan Section 0.12 defines performance budgets including bytes emitted per present:\n- \"For small change frames, emitted bytes should be O(changes), not O(screen)\"\n- \"Track and regress-test: bytes/frame for representative harness scenes\"\n\nThis is critical for ensuring diff-based rendering actually achieves its goal of minimal output.\n\n## Purpose\nTrack exactly how many bytes are emitted during each present() operation to:\n1. Verify O(changes) output size\n2. Detect regressions\n3. Validate run-grouping effectiveness\n4. Profile presenter efficiency\n\n## Implementation\n\n### Counter Integration\n\n```rust\n/// Presenter with byte counting\npub struct Presenter<W: Write> {\n    writer: CountingWriter<BufWriter<W>>,\n    // ... other fields\n}\n\n/// Write wrapper that counts bytes\nstruct CountingWriter<W> {\n    inner: W,\n    bytes_written: u64,\n}\n\nimpl<W: Write> Write for CountingWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let n = self.inner.write(buf)?;\n        self.bytes_written += n as u64;\n        Ok(n)\n    }\n    \n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n}\n\nimpl<W: Write> CountingWriter<W> {\n    fn bytes_written(&self) -> u64 {\n        self.bytes_written\n    }\n    \n    fn reset_counter(&mut self) {\n        self.bytes_written = 0;\n    }\n}\n```\n\n### Presenter Stats\n\n```rust\n/// Statistics from a present() call\n#[derive(Debug, Clone)]\npub struct PresentStats {\n    /// Bytes emitted for this frame\n    pub bytes_emitted: u64,\n    \n    /// Number of cells changed\n    pub cells_changed: usize,\n    \n    /// Number of runs (groups of consecutive changes)\n    pub run_count: usize,\n    \n    /// Time spent in present()\n    pub duration: std::time::Duration,\n}\n\nimpl<W: Write> Presenter<W> {\n    /// Present with stats collection\n    pub fn present_with_stats(\n        &mut self,\n        buffer: &Buffer,\n        diff: &BufferDiff,\n        pool: &GraphemePool,\n        links: &LinkRegistry,\n    ) -> io::Result<PresentStats> {\n        self.writer.reset_counter();\n        let start = std::time::Instant::now();\n        \n        let runs = diff.runs(buffer.width());\n        let run_count = runs.len();\n        \n        // ... do actual presentation ...\n        \n        self.writer.flush()?;\n        \n        Ok(PresentStats {\n            bytes_emitted: self.writer.bytes_written(),\n            cells_changed: diff.len(),\n            run_count,\n            duration: start.elapsed(),\n        })\n    }\n}\n```\n\n### Budget Thresholds\n\n```rust\n/// Expected bytes per cell change (approximate)\n/// Worst case: cursor move + full SGR reset + 3-byte char\nconst BYTES_PER_CELL_MAX: u64 = 30;\n\n/// Bytes for sync output wrapper\nconst SYNC_OVERHEAD: u64 = 16;\n\n/// Expected bytes for a frame with N changes\npub fn expected_max_bytes(cells_changed: usize, runs: usize) -> u64 {\n    // cursor move per run (10 bytes) + cells * max_per_cell + sync\n    (runs as u64 * 10) + (cells_changed as u64 * BYTES_PER_CELL_MAX) + SYNC_OVERHEAD\n}\n\n/// Check if output is within budget\npub fn check_budget(stats: &PresentStats) -> bool {\n    let budget = expected_max_bytes(stats.cells_changed, stats.run_count);\n    stats.bytes_emitted <= budget\n}\n```\n\n### Logging for Debugging\n\n```rust\nimpl PresentStats {\n    pub fn log(&self) {\n        tracing::debug!(\n            bytes = self.bytes_emitted,\n            cells_changed = self.cells_changed,\n            runs = self.run_count,\n            duration_us = self.duration.as_micros(),\n            bytes_per_cell = self.bytes_per_cell(),\n            \"Present stats\"\n        );\n    }\n    \n    pub fn bytes_per_cell(&self) -> f64 {\n        if self.cells_changed == 0 {\n            0.0\n        } else {\n            self.bytes_emitted as f64 / self.cells_changed as f64\n        }\n    }\n}\n```\n\n## Test Scenarios\n\n### 1. Full Redraw Baseline\n```rust\n#[test]\nfn test_full_redraw_bytes() {\n    let buffer = filled_buffer(80, 24); // All cells filled\n    let stats = present_full_with_stats(&buffer);\n    \n    // Full 80x24 = 1920 cells\n    // Should be < 60KB (generous budget for full redraw)\n    assert!(stats.bytes_emitted < 60_000, \n        \"Full redraw too large: {} bytes\", stats.bytes_emitted);\n}\n```\n\n### 2. Small Change (Spinner Tick)\n```rust\n#[test]\nfn test_spinner_update_bytes() {\n    // Spinner changes 1 cell\n    let diff = BufferDiff::from_changes(vec![(5, 5)]);\n    let stats = present_diff_with_stats(&buffer, &diff);\n    \n    // 1 cell change should be < 50 bytes\n    assert!(stats.bytes_emitted < 50,\n        \"Single cell update too large: {} bytes\", stats.bytes_emitted);\n}\n```\n\n### 3. Status Bar Update\n```rust\n#[test]\nfn test_status_bar_bytes() {\n    // 80-column status bar = 80 cells in one run\n    let diff = BufferDiff::from_run(0, 23, 80);\n    let stats = present_diff_with_stats(&buffer, &diff);\n    \n    // 80 cells in 1 run should be < 3KB\n    assert!(stats.bytes_emitted < 3000,\n        \"Status bar too large: {} bytes\", stats.bytes_emitted);\n}\n```\n\n## CI Integration\n\n### Benchmark Tests\n```rust\n// tests/bytes_budget.rs\n#[test]\nfn regression_bytes_spinner() {\n    let stats = simulate_spinner_frame();\n    // Regression threshold: 50 bytes\n    assert!(stats.bytes_emitted <= 50, \n        \"REGRESSION: spinner bytes increased to {}\", stats.bytes_emitted);\n}\n\n#[test]\nfn regression_bytes_log_append() {\n    let stats = simulate_log_append_frame();\n    // Regression threshold: 100 bytes for log line + UI refresh\n    assert!(stats.bytes_emitted <= 100);\n}\n```\n\n### Report Format\n```\nPresent Stats Report:\n  Scenario                  | Cells | Runs | Bytes | Bytes/Cell\n  --------------------------|-------|------|-------|------------\n  Full redraw (80x24)       | 1920  | 24   | 45230 | 23.6\n  Status bar update         | 80    | 1    | 1850  | 23.1\n  Spinner tick              | 1     | 1    | 32    | 32.0\n  Cursor blink              | 1     | 1    | 28    | 28.0\n  Log + UI (typical)        | 86    | 2    | 2100  | 24.4\n```\n\n## Acceptance Criteria\n- [ ] CountingWriter accurately tracks bytes\n- [ ] PresentStats captures all relevant metrics\n- [ ] Budget thresholds defined and documented\n- [ ] Regression tests for key scenarios\n- [ ] Logging available for debugging\n- [ ] CI reports bytes emitted\n\n## Dependencies\n- Requires: bd-10i.4.3 (Presenter implementation)\n- Blocks: bd-19x (Performance benchmarks)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:22:04.623182152Z","created_by":"ubuntu","updated_at":"2026-02-01T00:26:31.508090917Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3aqs","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T23:22:12.536010396Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3bp","title":"Rich Renderables Collection (rich_rust port)","description":"# Rich Renderables Collection (adapted into ftui-widgets)\n\n## Purpose\nThis epic tracks a set of composable renderables/layout helpers inspired by `rich_rust`.\n\nUnlike a widget zoo, these are meant to be small building blocks that make it easier to implement the **agent harness essential widgets** in Phase 5.\n\n## Reference Source\n- `legacy_reference_library_code/rich_rust/`\n\n## Plan Alignment\nPlan Phase 5 requires:\n- `Renderable` trait\n- Panel\n- Text wrapping\n- Table (basic)\n- Viewport/TextInput (harness essentials)\n\nThis epic’s renderables are optional but useful for building those features with less bespoke code.\n\n## Scope\nRenderables in this epic are expected to:\n- render into `Frame`/`Buffer` deterministically\n- have clear layout contracts\n- be testable via snapshot tests (frame grids)\n\n## Non-Goals\n- porting every rich renderable\n- shipping “pretty” renderables that aren’t needed for the harness before Gate 1–2\n\n## Success Criteria\n- [ ] Each renderable has deterministic snapshot tests and is integrated into the widget layer.\n- [ ] Dependencies are explicit (renderables depend on core primitives, not vice versa).\n- [ ] Renderables do not introduce new side-channel output (one-writer rule preserved).","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T22:58:58.234325316Z","created_by":"ubuntu","updated_at":"2026-02-01T00:23:53.195570238Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp","depends_on_id":"bd-10i.7","type":"parent-child","created_at":"2026-01-31T23:59:06.432587757Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp","depends_on_id":"bd-1ho","type":"blocks","created_at":"2026-01-31T23:04:25.777460862Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":29,"issue_id":"bd-3bp","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.1","title":"Implement Align renderable (text alignment container)","description":"# Implement Align renderable (horizontal/vertical alignment)\n\n## Objective\nImplement an alignment wrapper that positions a child renderable within an available rect according to horizontal/vertical alignment rules.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/renderables/align.rs`\n\n## Scope\n- Horizontal alignment: left / center / right\n- Vertical alignment: top / middle / bottom\n- Optional: alignment relative to baseline for text (future)\n\n## Design Notes\n- Alignment should be pure geometry (compute a child rect from parent rect + child measurement).\n- Must be deterministic and clip-safe.\n\n## Tests Required\n- Unit tests for rect computations.\n- Snapshot tests showing alignment with a simple child across widths/heights.\n\n## Acceptance Criteria\n- [ ] Align wrapper computes correct placement rects for all align modes.\n- [ ] Child render is clipped to the computed rect.\n- [ ] Unit tests cover edge cases (child larger than parent, zero sizes).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:59:08.463381546Z","created_by":"ubuntu","updated_at":"2026-02-01T00:29:23.801941466Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.1","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:03:54.710013480Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.1","depends_on_id":"bd-1ho.3","type":"blocks","created_at":"2026-01-31T23:03:54.004147312Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.1","depends_on_id":"bd-3bp","type":"parent-child","created_at":"2026-01-31T22:59:08.463381546Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.1","depends_on_id":"bd-6e9.8","type":"blocks","created_at":"2026-01-31T23:03:55.241850657Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":28,"issue_id":"bd-3bp.1","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.10","title":"Implement Rule renderable (horizontal line)","description":"# Implement Rule renderable (horizontal line / divider)\n\n## Objective\nImplement a divider component that draws a horizontal rule, optionally with a centered/left title.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/renderables/rule.rs`\n\n## Scope\n- Render a horizontal line across the available width.\n- Optional title text:\n  - left / center / right\n  - truncate safely under narrow widths\n- Style customization for the rule and title.\n\n## Tests Required\n- Snapshot tests for:\n  - no-title divider\n  - titled divider at different widths\n  - unicode title truncation\n\n## Acceptance Criteria\n- [ ] Rule renders correctly across widths, including very narrow cases.\n- [ ] Titles (if enabled) are placed and truncated safely.\n- [ ] Snapshot tests exist and are deterministic.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:00:13.951008425Z","created_by":"ubuntu","updated_at":"2026-02-01T00:29:44.741908578Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.10","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:04:04.561487154Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.10","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:04:05.054923940Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.10","depends_on_id":"bd-3bp","type":"parent-child","created_at":"2026-01-31T23:00:13.951008425Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.10","depends_on_id":"bd-3ky.2","type":"blocks","created_at":"2026-02-01T00:29:16.695982568Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":22,"issue_id":"bd-3bp.10","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.11","title":"Implement Traceback renderable (error display)","description":"# Implement Traceback renderable (error display) (optional)\n\n## Objective\nProvide an optional renderable to display error stacks/tracebacks in a readable way.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Render an error message with:\n  - headline\n  - optional frames / causes\n  - optional code snippet display (if provided)\n\n## Tests Required\n- Snapshot tests for representative error stacks.\n- Unit tests for truncation/wrapping behavior.\n\n## Acceptance Criteria\n- [ ] Traceback renderable formats errors deterministically.\n- [ ] Narrow-width behavior is defined and tested.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:00:21.292787140Z","created_by":"ubuntu","updated_at":"2026-02-01T00:34:11.468576962Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.11","depends_on_id":"bd-10i.4.2","type":"blocks","created_at":"2026-01-31T23:04:06.637786543Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.11","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-02-01T00:01:08.404988411Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.11","depends_on_id":"bd-381","type":"blocks","created_at":"2026-01-31T23:04:05.598465203Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.11","depends_on_id":"bd-3bp.8","type":"blocks","created_at":"2026-01-31T23:04:06.098869052Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":37,"issue_id":"bd-3bp.11","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.12","title":"Implement Tree renderable (hierarchical display)","description":"# Implement Tree renderable (hierarchical display) (optional)\n\n## Objective\nProvide an optional tree renderable (hierarchical lists) suitable for file trees or structured views.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Render a hierarchy with:\n  - indentation\n  - branch characters (ASCII/unicode)\n  - expand/collapse state (optional)\n\n## Tests Required\n- Snapshot tests for a few small trees.\n- Unit tests for indentation/branch rendering rules.\n\n## Acceptance Criteria\n- [ ] Tree renderable renders stable indentation/branch visuals.\n- [ ] Snapshot tests cover representative trees.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:00:30.776900763Z","created_by":"ubuntu","updated_at":"2026-02-01T00:34:12.089163394Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.12","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-02-01T00:01:09.054204112Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.12","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:04:07.159810350Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.12","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:04:07.666256190Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":36,"issue_id":"bd-3bp.12","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.13","title":"Rich Renderables Test Suite","description":"Comprehensive test suite for all rich_rust renderables. Ensures correct rendering, measurement, and styling across all components.\n\n## Testing Philosophy\nRenderables require three types of verification:\n1. **Measurement correctness** - min/max width calculations\n2. **Rendering correctness** - Output matches expected segments\n3. **Style propagation** - Styles cascade properly through nesting\n\n## Test Requirements by Renderable\n\n### Align (bd-3bp.1)\nUnit tests:\n- `test_align_left_no_change` - Left alignment is identity\n- `test_align_center_even_width` - Symmetric padding for even widths\n- `test_align_center_odd_width` - Extra space goes right\n- `test_align_right_full_pad` - All padding on left\n- `test_align_justify_word_spacing` - Even word spacing\n- `test_align_vertical_middle` - Correct top/bottom padding\n- `test_align_custom_fill_char` - Non-space fill characters\n\nSnapshot tests:\n- `snapshot_align_all_modes` - Visual grid of all alignment modes\n\n### Columns (bd-3bp.2)\nUnit tests:\n- `test_columns_equal_width` - Each column gets 1/N of space\n- `test_columns_ratio_distribution` - Proportional width allocation\n- `test_columns_fixed_width` - Fixed columns don't flex\n- `test_columns_auto_width` - Auto columns shrink to content\n- `test_columns_gutter_applied` - Correct spacing between columns\n- `test_columns_overflow_truncate` - Content truncated when too wide\n- `test_columns_height_alignment` - Shorter columns padded to match tallest\n\nProperty tests:\n- `prop_total_width_matches` - Sum of column widths + gutters = total\n- `prop_no_overlap` - Column content areas don't overlap\n\n### Emoji (bd-3bp.3)\nUnit tests:\n- `test_emoji_lookup_valid` - Known emoji names resolve\n- `test_emoji_lookup_invalid` - Unknown names return None\n- `test_emoji_width_standard` - Most emoji are 2 cells\n- `test_emoji_width_variation` - Variation selectors handled\n- `test_emoji_zwj_family` - Family emoji width correct\n- `test_emoji_skin_tone` - Skin tone modifiers work\n- `test_emoji_shortcode_replace` - :thumbsup: -> 👍\n\nCorpus tests:\n- `corpus_all_emoji` - Test all emoji in database\n\n### Group (bd-3bp.4)\nUnit tests:\n- `test_group_single_item` - Single item renders unchanged\n- `test_group_multiple_items` - Items stacked vertically\n- `test_group_with_separator` - Separator between each pair\n- `test_group_measurement_max` - Width is max of all children\n- `test_group_measurement_sum` - Height is sum of all children\n- `test_group_nested` - Groups can contain groups\n\n### JSON (bd-3bp.5)\nUnit tests:\n- `test_json_primitive_string` - String with quotes and escapes\n- `test_json_primitive_number` - Integer and float formatting\n- `test_json_primitive_bool` - true/false styling\n- `test_json_primitive_null` - null styling\n- `test_json_object_empty` - {} formatting\n- `test_json_object_single_key` - No trailing comma\n- `test_json_object_multiple_keys` - Commas between entries\n- `test_json_array_inline` - Small arrays on one line\n- `test_json_array_multiline` - Large arrays split across lines\n- `test_json_nested_deep` - Correct indentation at depth\n- `test_json_invalid_fallback` - Invalid JSON shows error\n\nSnapshot tests:\n- `snapshot_json_complex_document` - Full document rendering\n\n### Layout (bd-3bp.6)\nUnit tests:\n- `test_layout_single_cell` - One item fills grid\n- `test_layout_multiple_rows` - Items wrap to next row\n- `test_layout_column_span` - Item spans multiple columns\n- `test_layout_row_span` - Item spans multiple rows\n- `test_layout_gap_applied` - Row and column gaps\n- `test_layout_auto_sizing` - Auto columns fit content\n- `test_layout_fr_distribution` - Fr units divide remaining space\n\nProperty tests:\n- `prop_no_cell_overlap` - Grid cells don't overlap\n- `prop_bounds_respected` - All content within grid bounds\n\n### Padding (bd-3bp.7)\nUnit tests:\n- `test_padding_all` - Equal padding on all sides\n- `test_padding_horizontal` - Left/right only\n- `test_padding_vertical` - Top/bottom only\n- `test_padding_individual` - Each side different\n- `test_padding_measurement` - Min/max adjusted by padding\n- `test_padding_style_applied` - Padding area styled\n\n### Panel (bd-3bp.8)\nUnit tests:\n- `test_panel_rounded_border` - Rounded corners render\n- `test_panel_square_border` - Square corners render\n- `test_panel_double_border` - Double-line border\n- `test_panel_ascii_fallback` - ASCII-only border chars\n- `test_panel_title_left` - Title at top-left\n- `test_panel_title_center` - Title centered in top border\n- `test_panel_title_truncation` - Long title truncated with ellipsis\n- `test_panel_subtitle` - Subtitle on bottom border\n- `test_panel_content_padding` - Content inset from border\n\nSnapshot tests:\n- `snapshot_panel_all_styles` - Grid of all border styles\n\n### Pretty (bd-3bp.9)\nUnit tests:\n- `test_pretty_primitive_types` - i32, f64, bool, char\n- `test_pretty_string_quoted` - Strings show quotes\n- `test_pretty_vec_inline` - Small vecs on one line\n- `test_pretty_vec_multiline` - Large vecs split\n- `test_pretty_struct` - Named fields with values\n- `test_pretty_enum_unit` - Variant name only\n- `test_pretty_enum_tuple` - Variant with tuple args\n- `test_pretty_depth_limit` - Stops at max depth with ...\n- `test_pretty_string_limit` - Long strings truncated\n\n### Rule (bd-3bp.10)\nUnit tests:\n- `test_rule_full_width` - Fills available width\n- `test_rule_with_title` - Title centered in line\n- `test_rule_title_left` - Title at left edge\n- `test_rule_custom_char` - Non-default line character\n- `test_rule_ascii_fallback` - Uses - instead of ─\n\n### Traceback (bd-3bp.11)\nUnit tests:\n- `test_traceback_single_frame` - One stack frame\n- `test_traceback_multiple_frames` - Stack of frames\n- `test_traceback_with_source` - Source code context\n- `test_traceback_without_source` - Graceful degradation\n- `test_traceback_chained_cause` - Caused by: chain\n- `test_traceback_frame_filter` - Hide stdlib frames\n- `test_traceback_hyperlinks` - File paths are clickable\n\n### Tree (bd-3bp.12)\nUnit tests:\n- `test_tree_single_node` - Root only\n- `test_tree_single_child` - Root with one child\n- `test_tree_multiple_children` - Root with siblings\n- `test_tree_deep_nesting` - Multi-level hierarchy\n- `test_tree_guide_last_child` - └── for last child\n- `test_tree_guide_middle_child` - ├── for middle children\n- `test_tree_collapsed_node` - Collapsed indicator\n- `test_tree_ascii_fallback` - Uses +-- instead of ├──\n\nSnapshot tests:\n- `snapshot_tree_filesystem` - Typical directory structure\n\n## Measurement Protocol Tests\nFor all renderables:\n- `test_measure_returns_valid` - min <= max\n- `test_measure_respects_constraint` - max <= max_width param\n- `test_render_fits_measurement` - Rendered output <= measured width\n\n## Logging Requirements\n- `tracing::debug!` for measurement decisions\n- `tracing::debug!` for style resolution\n- `tracing::trace!` for segment construction\n- Measurement cache hit/miss logged at trace level\n\nDependencies: All renderables, Testing infrastructure (bd-10i.11)\n\n\n## Acceptance Criteria\n- [ ] Snapshot tests cover each renderable’s core behaviors and edge cases.\n- [ ] Tests are deterministic and provide readable diffs on failure.\n- [ ] The suite runs in CI and blocks regressions for Phase 5 widgets.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:16:05.699642278Z","created_by":"ubuntu","updated_at":"2026-02-01T00:29:50.906170029Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.13","depends_on_id":"bd-10i.11","type":"blocks","created_at":"2026-01-31T23:18:02.243281204Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.1","type":"blocks","created_at":"2026-01-31T23:18:25.067172386Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.10","type":"blocks","created_at":"2026-01-31T23:18:30.426875072Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.11","type":"blocks","created_at":"2026-01-31T23:18:30.987026894Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.12","type":"blocks","created_at":"2026-01-31T23:18:31.567714063Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.2","type":"blocks","created_at":"2026-01-31T23:18:25.783648515Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.3","type":"blocks","created_at":"2026-01-31T23:18:26.368454149Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.4","type":"blocks","created_at":"2026-01-31T23:18:26.950713408Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.5","type":"blocks","created_at":"2026-01-31T23:18:27.542909999Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.6","type":"blocks","created_at":"2026-01-31T23:18:28.151181827Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.7","type":"blocks","created_at":"2026-01-31T23:18:28.747205834Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.8","type":"blocks","created_at":"2026-01-31T23:18:29.277542898Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.13","depends_on_id":"bd-3bp.9","type":"blocks","created_at":"2026-01-31T23:18:29.865454340Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":6,"issue_id":"bd-3bp.13","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.2","title":"Implement Columns renderable (column layout)","description":"# Implement Columns renderable (column layout)\n\n## Objective\nImplement a column layout container that places children side-by-side with configurable spacing and width allocation.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/renderables/columns.rs`\n\n## Scope\n- Place N children in horizontal columns.\n- Support:\n  - fixed spacing between columns\n  - proportional or constraint-based width allocation (delegate to ftui Flex where possible)\n- Deterministic rendering order.\n\n## Integration Notes\n- Prefer to use `bd-yzu` (Flex) for width allocation rather than implementing a second constraint solver.\n\n## Tests Required\n- Unit tests for width allocation and rect computation.\n- Snapshot tests for 2/3/4-column layouts under narrow and wide terminals.\n\n## Acceptance Criteria\n- [ ] Columns container positions children side-by-side with correct spacing.\n- [ ] Width allocation is deterministic and uses ftui layout primitives.\n- [ ] Unit + snapshot tests cover representative cases.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Equal width distribution across columns\n- [ ] Ratio-based width distribution\n- [ ] Fixed width columns\n- [ ] Auto-fit columns to content\n- [ ] Range-constrained columns (min/max)\n- [ ] Gutter spacing between columns\n- [ ] Per-column padding\n- [ ] Expand mode fills available width\n- [ ] Fit mode uses minimum necessary width\n\n### Layout Requirements\n- [ ] Column widths sum to available width (with gutters)\n- [ ] Content truncated when column too narrow\n- [ ] Vertical alignment within row\n- [ ] Shorter columns padded to match tallest\n- [ ] No content overlap between columns\n\n### Measurement Requirements\n- [ ] Minimum = sum of column minimums + gutters\n- [ ] Maximum = sum of column maximums + gutters\n- [ ] Constraint solving for ratio columns\n\n### Logging Requirements\n- [ ] tracing::debug! for width distribution decisions\n- [ ] tracing::trace! for column measurement\n- [ ] tracing::warn! for constraint violations\n\n### Test Coverage\n- [ ] Unit tests for each width mode\n- [ ] Property test: no column overlap\n- [ ] Property test: total width correct\n- [ ] Snapshot tests for visual verification\n- [ ] Edge case: zero-width column\n- [ ] Edge case: single column","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:59:14.940919021Z","created_by":"ubuntu","updated_at":"2026-02-01T00:29:31.029653401Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.2","depends_on_id":"bd-1ho.3","type":"blocks","created_at":"2026-01-31T23:03:55.768351680Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.2","depends_on_id":"bd-3bp","type":"parent-child","created_at":"2026-01-31T22:59:14.940919021Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.2","depends_on_id":"bd-yzu","type":"blocks","created_at":"2026-01-31T23:03:56.304298019Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":27,"issue_id":"bd-3bp.2","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.3","title":"Implement Emoji renderable (emoji display)","description":"# Implement Emoji renderable (optional)\n\n## Objective\nProvide an optional renderable that displays emoji/text with sane width handling and fallback behavior.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Render emoji characters into `Buffer` respecting ftui width rules.\n- Define fallback behavior when:\n  - terminal/font renders emoji as double-width unexpectedly\n  - emoji is unsupported (render placeholder)\n\n## Tests Required\n- Unit tests for width expectations using the existing width corpus.\n- Snapshot tests for representative emoji sequences (including ZWJ).\n\n## Acceptance Criteria\n- [ ] Emoji renderable renders without corrupting layout.\n- [ ] Width handling is consistent with ftui text measurement.\n- [ ] Snapshot tests cover representative emoji + ZWJ sequences.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:59:22.066848834Z","created_by":"ubuntu","updated_at":"2026-02-01T00:34:09.495876665Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.3","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T23:14:42.077987167Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.3","depends_on_id":"bd-10i.3.5","type":"blocks","created_at":"2026-01-31T23:03:57.334151791Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.3","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-02-01T00:01:06.500105437Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.3","depends_on_id":"bd-v6y","type":"blocks","created_at":"2026-01-31T23:03:56.821229783Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":40,"issue_id":"bd-3bp.3","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.4","title":"Implement Group renderable (composite container)","description":"# Implement Group renderable (composite container)\n\n## Objective\nImplement a simple composite container that renders multiple children in a deterministic order.\n\nUnlike Layout/Columns, Group itself does not necessarily reposition children; it is primarily a composition primitive.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/renderables/group.rs`\n\n## Scope\n- A `Group` type that holds N children.\n- Deterministic render order.\n- Optional: group-level style application (future; keep minimal initially).\n\n## Tests Required\n- Unit tests verifying order and that all children render.\n- Snapshot tests with a few trivial children to validate composition.\n\n## Acceptance Criteria\n- [ ] Group renders children in stable order.\n- [ ] Group does not allocate per-frame in steady-state (where feasible).\n- [ ] Unit + snapshot tests exist.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:59:27.080696290Z","created_by":"ubuntu","updated_at":"2026-02-01T00:29:37.637184958Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.4","depends_on_id":"bd-1ho.1","type":"blocks","created_at":"2026-01-31T23:03:58.384812401Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.4","depends_on_id":"bd-1ho.3","type":"blocks","created_at":"2026-01-31T23:03:57.877674128Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.4","depends_on_id":"bd-3bp","type":"parent-child","created_at":"2026-01-31T22:59:27.080696290Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":26,"issue_id":"bd-3bp.4","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.5","title":"Implement JSON renderable (pretty JSON display)","description":"# Implement JSON renderable (pretty JSON display) (optional)\n\n## Objective\nProvide an optional renderable that formats and displays JSON in a human-friendly way.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Pretty-print JSON with indentation.\n- Optional coloring/highlighting if syntax highlighting is enabled.\n- Graceful handling of invalid JSON (show error + raw text).\n\n## Tests Required\n- Unit tests for formatting and error handling.\n- Snapshot tests for a few JSON fixtures (small/large/nested).\n\n## Acceptance Criteria\n- [ ] Valid JSON renders in a stable, pretty format.\n- [ ] Invalid JSON renders an explicit error without panicking.\n- [ ] Snapshot tests cover representative fixtures.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:59:36.616288826Z","created_by":"ubuntu","updated_at":"2026-02-01T00:34:10.165129917Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.5","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-02-01T00:01:07.129819170Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.5","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:03:58.909419880Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.5","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:03:59.433016217Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":39,"issue_id":"bd-3bp.5","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.6","title":"Implement Layout renderable (advanced grid layout)","description":"# Implement Layout renderable (composition container)\n\n## Objective\nImplement a layout composition renderable that can place child renderables using a higher-level layout spec.\n\nThis should build on ftui’s layout primitives (Grid/Flex) rather than inventing a parallel layout engine.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/renderables/layout.rs`\n\n## Scope\n- A `Layout` container that:\n  - accepts children + a layout specification\n  - computes placement rects deterministically\n  - renders children in a stable order\n\n## Integration Notes\n- Prefer delegating placement math to:\n  - `bd-2wi` (Grid layout)\n  - (optionally) `bd-yzu` (Flex layout)\n- Keep this layer as “glue” + ergonomics, not a second constraint solver.\n\n## Tests Required\n- Unit tests for placement decisions (rect lists) on small examples.\n- Snapshot tests for a few composed layouts.\n\n## Acceptance Criteria\n- [ ] Layout container can position multiple children deterministically.\n- [ ] Placement uses ftui layout primitives (no parallel solver).\n- [ ] Unit + snapshot tests exist and are deterministic.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:59:42.211918374Z","created_by":"ubuntu","updated_at":"2026-02-01T00:28:51.700575614Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.6","depends_on_id":"bd-1ho.3","type":"blocks","created_at":"2026-01-31T23:03:59.931165042Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.6","depends_on_id":"bd-2wi","type":"blocks","created_at":"2026-02-01T00:28:43.138559957Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.6","depends_on_id":"bd-3bp","type":"parent-child","created_at":"2026-01-31T22:59:42.211918374Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.6","depends_on_id":"bd-3bp.2","type":"blocks","created_at":"2026-01-31T23:04:00.415155711Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":25,"issue_id":"bd-3bp.6","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.7","title":"Implement Padding renderable (spacing container)","description":"# Implement Padding renderable (spacing container)\n\n## Objective\nImplement a padding container that wraps a child renderable and applies `Sides` padding around it.\n\nThis is a basic building block for Panel, layouts, and widget composition.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/renderables/padding.rs`\n\n## Scope\n- A padding wrapper that:\n  - computes an inner rect (frame minus padding)\n  - renders the child into the inner rect\n  - reports measurement bounds that include padding\n\n## Design Notes\n- Padding must never produce negative dimensions; clamp at 0.\n- If padding consumes all space, child render is a no-op.\n\n## Tests Required\n- Unit tests for inner-rect calculation across edge cases:\n  - zero padding\n  - padding larger than frame\n  - asymmetric padding\n- Snapshot tests showing padding effect with a simple child.\n\n## Acceptance Criteria\n- [ ] Padding correctly computes inner rect and clamps at 0.\n- [ ] Child rendering is clipped to inner rect.\n- [ ] Measurement bounds include padding consistently.\n- [ ] Unit tests and at least one snapshot test exist.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:59:48.822726004Z","created_by":"ubuntu","updated_at":"2026-02-01T00:28:24.051102236Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.7","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T23:14:43.394230844Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.7","depends_on_id":"bd-10i.3.7","type":"blocks","created_at":"2026-01-31T23:04:00.959334944Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.7","depends_on_id":"bd-1ho.3","type":"blocks","created_at":"2026-01-31T23:04:01.499464026Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.7","depends_on_id":"bd-3bp","type":"parent-child","created_at":"2026-01-31T22:59:48.822726004Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":24,"issue_id":"bd-3bp.7","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.8","title":"Implement Panel renderable (bordered box)","description":"# Implement Panel widget/renderable (bordered box + title)\n\n## Objective\nImplement a Panel component that draws a border around content with optional title/subtitle and configurable padding.\n\nThis is a harness-essential building block (status panels, tool boxes, input chrome).\n\n## Reference (for ideas)\n- `legacy_reference_library_code/rich_rust/src/renderables/panel.rs`\n\n## Scope\n- Border styles (via `BorderChars` presets + custom):\n  - rounded, square, double, heavy, ascii\n- Title placement (at least top-left/top-center/top-right)\n- Subtitle support (optional, but plan-friendly)\n- Title truncation for narrow panels (must be Unicode-width correct)\n- Padding between border and content\n- Style customization for border and title\n- Safe/ASCII-only mode for maximum compatibility\n\n## Integration Notes\n- Must render via `Buffer` operations (no direct terminal output).\n- Should reuse:\n  - `BorderChars` presets (`bd-1ho.4`)\n  - padding helpers (`bd-3bp.7`)\n  - drawing ops (`bd-3ky.2`)\n  - `Text` type for styled titles (`bd-2uk`)\n\n## Tests Required\n- Snapshot tests across:\n  - widths (narrow/normal/wide)\n  - border presets (including ascii)\n  - title alignments\n  - unicode titles (emoji/combining) with truncation\n- Unit tests for layout math (inner rect calculation).\n\n## Acceptance Criteria\n- [ ] Panel renders borders correctly with all presets and custom borders.\n- [ ] Titles are positioned correctly and truncated safely under narrow widths.\n- [ ] Padding is applied correctly and never draws out of bounds.\n- [ ] Snapshot tests cover representative cases and are deterministic.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Support all border styles: Rounded, Square, Double, Heavy, Ascii, None\n- [ ] Title placement: top-left, top-center, top-right\n- [ ] Subtitle placement: bottom-left, bottom-center, bottom-right\n- [ ] Title truncation with ellipsis when panel too narrow\n- [ ] Content padding (inner spacing from border)\n- [ ] Border style/color customization\n- [ ] Expand mode fills available width\n- [ ] Fit mode uses minimum necessary width\n- [ ] ASCII fallback for non-Unicode terminals\n\n### Rendering Requirements\n- [ ] Border characters are single-cell (no emoji)\n- [ ] Title renders inline with top border\n- [ ] Content properly indented from border\n- [ ] Wide characters in title handled correctly\n- [ ] Minimum width = border (2) + title (if any)\n\n### Measurement Requirements\n- [ ] Minimum = content minimum + border + padding\n- [ ] Maximum = content maximum + border + padding\n- [ ] Respects max_width constraint\n\n### Logging Requirements\n- [ ] tracing::debug! for border style selection\n- [ ] tracing::trace! for title truncation decisions\n- [ ] tracing::warn! for content overflow\n\n### Test Coverage\n- [ ] Snapshot tests for all border styles\n- [ ] Unit tests for title placement variants\n- [ ] Property test: output width <= specified width\n- [ ] Integration test: nested panels","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:59:56.154048039Z","created_by":"ubuntu","updated_at":"2026-02-01T00:28:06.911644040Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.8","depends_on_id":"bd-1ho.4","type":"blocks","created_at":"2026-01-31T23:04:01.991836820Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.8","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:04:03.012459619Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.8","depends_on_id":"bd-3bp","type":"parent-child","created_at":"2026-01-31T22:59:56.154048039Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.8","depends_on_id":"bd-3bp.7","type":"blocks","created_at":"2026-01-31T23:04:02.497288949Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.8","depends_on_id":"bd-3ky.2","type":"blocks","created_at":"2026-02-01T00:27:52.648224176Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":23,"issue_id":"bd-3bp.8","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3bp.9","title":"Implement Pretty renderable (pretty printing)","description":"# Implement Pretty renderable (optional)\n\n## Objective\nProvide an optional “pretty printer” renderable for structured data.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Pretty-print common Rust structures (or a generic tree-like structure).\n- Deterministic formatting (stable ordering where applicable).\n\n## Tests Required\n- Unit tests for formatting.\n- Snapshot tests for a few representative structures.\n\n## Acceptance Criteria\n- [ ] Pretty formatting is deterministic.\n- [ ] Snapshot tests cover representative outputs.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:00:07.607762605Z","created_by":"ubuntu","updated_at":"2026-02-01T00:34:10.813119346Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3bp.9","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-02-01T00:01:07.777541248Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.9","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:04:03.523962015Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3bp.9","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:04:04.019683541Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":38,"issue_id":"bd-3bp.9","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3cc","title":"Implement Frame struct (Buffer + metadata)","description":"# Implement Frame struct (Buffer + metadata)\n\n## Background\nPlan Section 6.1 defines Frame as the container for a render pass: the Buffer grid plus metadata needed for presentation and interaction.\n\n## Frame Purpose\nFrame is the \"render target\" that view() methods write to. It bundles:\n1. The cell grid (Buffer)\n2. Optional hit testing grid (HitGrid)\n3. Cursor metadata\n\n## Structure\n\n```rust\n/// Frame = Buffer + metadata for a render pass\n/// \n/// # Design Rationale\n/// Frame is passed to Model::view() and contains everything needed to render.\n/// The Buffer holds cells; metadata controls cursor and enables mouse hit testing.\n/// \n/// Frame does NOT own pools (GraphemePool, LinkRegistry) - those are passed separately\n/// or accessed via RenderContext to allow sharing across frames.\npub struct Frame {\n    /// The cell grid for this render pass\n    pub buffer: Buffer,\n    \n    /// Optional hit grid for mouse hit testing\n    /// When Some, widgets can register clickable regions\n    pub hit_grid: Option<HitGrid>,\n    \n    /// Cursor position (if app wants to show cursor)\n    /// Coordinates are relative to buffer (0-indexed)\n    pub cursor_position: Option<(u16, u16)>,\n    \n    /// Whether cursor should be visible\n    pub cursor_visible: bool,\n}\n```\n\n## Frame Lifecycle\n\n```rust\nimpl Frame {\n    /// Create a new frame with given dimensions\n    pub fn new(width: u16, height: u16) -> Self {\n        Self {\n            buffer: Buffer::new(width, height),\n            hit_grid: None,\n            cursor_position: None,\n            cursor_visible: true,\n        }\n    }\n    \n    /// Create frame with hit testing enabled\n    pub fn with_hit_grid(width: u16, height: u16) -> Self {\n        Self {\n            buffer: Buffer::new(width, height),\n            hit_grid: Some(HitGrid::new(width, height)),\n            cursor_position: None,\n            cursor_visible: true,\n        }\n    }\n    \n    /// Dimensions\n    pub fn width(&self) -> u16 { self.buffer.width() }\n    pub fn height(&self) -> u16 { self.buffer.height() }\n    \n    /// Clear frame for next render\n    pub fn clear(&mut self) {\n        self.buffer.clear();\n        if let Some(ref mut grid) = self.hit_grid {\n            grid.clear();\n        }\n    }\n    \n    /// Set cursor position (None to hide)\n    pub fn set_cursor(&mut self, position: Option<(u16, u16)>) {\n        self.cursor_position = position;\n    }\n    \n    /// Show/hide cursor\n    pub fn set_cursor_visible(&mut self, visible: bool) {\n        self.cursor_visible = visible;\n    }\n}\n```\n\n## Integration Points\n\n### With Model::view()\n```rust\ntrait Model {\n    fn view(&self, frame: &mut Frame);\n}\n\nimpl Model for MyApp {\n    fn view(&self, frame: &mut Frame) {\n        // Draw widgets to frame.buffer\n        // Register hit regions with frame.hit_grid\n        // Set cursor position if needed\n        self.status_bar.render(frame);\n        frame.set_cursor(Some((self.cursor_x, self.cursor_y)));\n    }\n}\n```\n\n### With Presenter\n```rust\n// Runtime uses Frame for diff and presentation\nlet diff = BufferDiff::compute(&prev_buffer, &frame.buffer);\npresenter.present(&frame.buffer, &diff, &pool, &links)?;\n\n// Handle cursor separately\nif frame.cursor_visible {\n    if let Some((x, y)) = frame.cursor_position {\n        presenter.position_cursor(x, y)?;\n    }\n    presenter.show_cursor()?;\n} else {\n    presenter.hide_cursor()?;\n}\n```\n\n## HitGrid (Optional Feature)\nHit grid enables mouse interaction by mapping screen positions to widget IDs.\n\n```rust\n/// Hit testing grid for mouse interaction\npub struct HitGrid {\n    width: u16,\n    height: u16,\n    cells: Vec<Option<HitId>>,\n}\n\n/// Identifier for a clickable region\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\npub struct HitId(pub u32);\n\nimpl HitGrid {\n    pub fn register(&mut self, rect: Rect, id: HitId) {\n        for y in rect.y..(rect.y + rect.height) {\n            for x in rect.x..(rect.x + rect.width) {\n                if let Some(cell) = self.get_mut(x, y) {\n                    *cell = Some(id);\n                }\n            }\n        }\n    }\n    \n    pub fn hit_test(&self, x: u16, y: u16) -> Option<HitId> {\n        self.get(x, y).and_then(|c| *c)\n    }\n}\n```\n\n## Tests Required\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_frame_creation() {\n        let frame = Frame::new(80, 24);\n        assert_eq\\!(frame.width(), 80);\n        assert_eq\\!(frame.height(), 24);\n        assert\\!(frame.hit_grid.is_none());\n        assert\\!(frame.cursor_position.is_none());\n        assert\\!(frame.cursor_visible);\n    }\n    \n    #[test]\n    fn test_frame_with_hit_grid() {\n        let frame = Frame::with_hit_grid(80, 24);\n        assert\\!(frame.hit_grid.is_some());\n    }\n    \n    #[test]\n    fn test_frame_cursor() {\n        let mut frame = Frame::new(80, 24);\n        frame.set_cursor(Some((10, 5)));\n        assert_eq\\!(frame.cursor_position, Some((10, 5)));\n        \n        frame.set_cursor_visible(false);\n        assert\\!(\\!frame.cursor_visible);\n    }\n    \n    #[test]\n    fn test_hit_grid_registration() {\n        let mut frame = Frame::with_hit_grid(80, 24);\n        let hit_id = HitId(42);\n        let rect = Rect::new(10, 5, 20, 3);\n        \n        if let Some(ref mut grid) = frame.hit_grid {\n            grid.register(rect, hit_id);\n            \n            // Inside rect\n            assert_eq\\!(grid.hit_test(15, 6), Some(hit_id));\n            \n            // Outside rect\n            assert_eq\\!(grid.hit_test(5, 5), None);\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Frame holds Buffer + optional HitGrid\n- [ ] Cursor position and visibility tracked\n- [ ] HitGrid registration and hit testing work\n- [ ] clear() resets both buffer and hit grid\n- [ ] Tests pass\n\n## Dependencies\n- Requires: bd-10i.3.6 (Buffer implementation)\n- Blocks: bd-10i.8.2 (Runtime uses Frame)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:49:50.364819793Z","created_by":"ubuntu","updated_at":"2026-02-01T00:24:10.525656713Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3cc","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-01-31T22:53:47.983923493Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3cc","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:53:47.602013413Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3e8","title":"Implement structured logging with tracing","description":"INFRASTRUCTURE - LOGGING & TRACING\n\n## Background\nComprehensive logging is critical for debugging terminal rendering issues, performance analysis, and understanding execution flow. Must support both development debugging and production diagnostics.\n\n## Technical Requirements\n\n### Tracing Infrastructure\n- Use tracing crate for structured, async-aware logging\n- Log levels: ERROR, WARN, INFO, DEBUG, TRACE\n- Span-based instrumentation for render pipeline\n- Subscriber configuration for:\n  - Development: pretty-printed to stderr\n  - Testing: captured for assertions\n  - Production: JSON structured output (optional)\n\n### Key Instrumentation Points\n- Frame lifecycle: start → render → diff → present → complete\n- Widget rendering: widget type, area, render time\n- Buffer operations: resize, clear, set (at TRACE level)\n- Input parsing: raw bytes → parsed events\n- State changes: model updates, command execution\n- Error conditions: with full context\n\n### Log Format\nDevelopment:\n  2026-01-31T12:00:00.123Z INFO ftui::render frame_start frame=42 widgets=15\n  2026-01-31T12:00:00.125Z DEBUG ftui::diff changed_cells=120 skip_rows=10\n  \nTesting (structured capture):\n  LogEntry { level: INFO, target: \"ftui::render\", msg: \"frame_start\", ... }\n\n### Feature Gates\n- feature = \"tracing\" - enables all instrumentation\n- feature = \"tracing-json\" - JSON subscriber for production\n- Default: tracing disabled for minimal overhead\n\n## Design Rationale\nTerminal UIs are notoriously hard to debug. Structured tracing with spans enables understanding complex render pipelines. Feature-gated to avoid overhead in release builds.\n\n## Acceptance Criteria\n- [ ] tracing subscriber configuration\n- [ ] Frame-level span instrumentation\n- [ ] Widget render spans with timing\n- [ ] Input parsing tracing\n- [ ] Error context capture\n- [ ] Test log capture mechanism\n- [ ] Feature gate documentation\n- [ ] Example showing log output\n\n## Performance Budget\n- Disabled: zero overhead (compiled out)\n- Enabled: < 1µs per span enter/exit\n\n## Location: ftui-core crate (feature = \"tracing\")","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:27:56.000241382Z","created_by":"ubuntu","updated_at":"2026-01-31T22:29:24.287545487Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3e8","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:29:24.287504810Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3hy","title":"Define per-module unit test coverage requirements","description":"TESTING - UNIT TEST COVERAGE MATRIX\n\n## Background\nEach module in FrankenTUI must have comprehensive unit tests. This bead defines the required test coverage for every crate and module.\n\n## Coverage Requirements by Crate\n\n### ftui-core (≥ 80% coverage)\n#### Cell Module\n- [ ] CellContent creation from char, grapheme\n- [ ] CellContent width calculation (ASCII, CJK, emoji)\n- [ ] PackedRgba from RGB, RGBA, named colors\n- [ ] PackedRgba Porter-Duff alpha blending\n- [ ] PackedRgba opacity scaling\n- [ ] CellAttrs bitfield operations\n- [ ] CellAttrs merge/override\n- [ ] Cell construction and defaults\n- [ ] Cell bits_eq correctness\n- [ ] Cell continuation sentinel\n- [ ] Cell builder methods\n\n#### Buffer Module\n- [ ] Buffer creation with dimensions\n- [ ] Buffer get/set bounds checking\n- [ ] Buffer scissor stack operations\n- [ ] Buffer opacity stack operations\n- [ ] Buffer clear operations\n- [ ] Wide character handling\n- [ ] Cell iteration\n- [ ] Resize behavior (if supported)\n\n### ftui-render (≥ 75% coverage)\n#### Diff Module\n- [ ] BufferDiff empty (no changes)\n- [ ] BufferDiff single cell change\n- [ ] BufferDiff row changes\n- [ ] BufferDiff skip unchanged rows\n- [ ] BufferDiff wide character changes\n- [ ] Diff iteration order\n\n#### Presenter Module\n- [ ] ANSI escape sequence generation\n- [ ] Cursor movement optimization\n- [ ] Color state tracking\n- [ ] Attribute state tracking\n- [ ] SGR sequence batching\n- [ ] Hyperlink OSC 8 handling\n\n### ftui-style (≥ 80% coverage)\n- [ ] Style creation and defaults\n- [ ] Style merge (cascading)\n- [ ] Style patch (override)\n- [ ] Style builder pattern\n- [ ] StyleSheet define/get\n- [ ] StyleSheet compose\n- [ ] Named style inheritance\n\n### ftui-text (≥ 80% coverage)\n- [ ] Text creation from string\n- [ ] Text span appending\n- [ ] Text width calculation\n- [ ] Text truncation with ellipsis\n- [ ] Text line splitting\n- [ ] GraphemePool interning\n- [ ] GraphemePool refcounting\n- [ ] Unicode edge cases (ZWJ, VS15/16)\n\n### ftui-layout (≥ 70% coverage)\n- [ ] Rect operations (intersection, contains)\n- [ ] Flex horizontal layout\n- [ ] Flex vertical layout\n- [ ] Flex constraint types (Fixed, Percent, Min, Max, Ratio)\n- [ ] Flex gap handling\n- [ ] Grid row/column solving\n- [ ] Grid cell spanning\n- [ ] Grid named areas\n\n### ftui-runtime (≥ 70% coverage)\n- [ ] TerminalWriter mode transitions\n- [ ] Program/Model lifecycle\n- [ ] Cmd execution\n- [ ] Event dispatch\n- [ ] Subscription handling\n\n### ftui-widgets (≥ 70% coverage)\n- [ ] Block border rendering\n- [ ] Block title positioning\n- [ ] Paragraph text wrapping\n- [ ] Paragraph alignment\n- [ ] Table column sizing\n- [ ] Table row selection\n- [ ] List item rendering\n- [ ] List selection state\n- [ ] Input cursor positioning\n- [ ] Input text selection\n\n## Test Quality Guidelines\n\n### Each Test Must\n1. Test ONE behavior (single assertion focus)\n2. Have descriptive name: test_<function>_<scenario>_<expected>\n3. Include edge cases (empty, max, boundary)\n4. Be deterministic (no random, no time)\n5. Be fast (< 10ms each)\n6. Be independent (no shared mutable state)\n\n### Property Testing Requirements\nUse proptest for:\n- Numeric overflow (widths, coordinates)\n- Unicode string handling\n- Color calculations\n- Layout constraint solving\n\n## Acceptance Criteria\n- [ ] Test module in each crate\n- [ ] Coverage thresholds met per crate\n- [ ] Property tests for numeric operations\n- [ ] Edge case coverage documented\n- [ ] Test naming conventions followed\n- [ ] No flaky tests\n\n## Location: Each crate's tests/ or src/**/tests.rs","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:29:14.532567931Z","created_by":"ubuntu","updated_at":"2026-01-31T22:29:26.163983601Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3hy","depends_on_id":"bd-10i.2.1","type":"blocks","created_at":"2026-01-31T22:29:26.163954296Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3i6","title":"Implement bracketed paste and mouse SGR protocol","description":"PHASE 3 - ADVANCED INPUT PROTOCOLS\n\n## Background\nBracketed paste mode prevents pasted content from being interpreted as commands. SGR mouse protocol provides precise mouse reporting with modifiers.\n\n## Technical Requirements\n\n### Bracketed Paste Mode\nEscape sequences:\n- Enable: ESC[?2004h\n- Disable: ESC[?2004l\n- Paste start: ESC[200~\n- Paste end: ESC[201~\n\npub struct BracketedPasteParser {\n    in_paste: bool,\n    paste_buffer: Vec<u8>,\n    max_paste_size: usize,  // Default: 1MB\n}\n\nimpl BracketedPasteParser {\n    pub fn parse(&mut self, byte: u8) -> Option<InputEvent> {\n        if self.in_paste {\n            // Accumulate until paste end sequence\n            // Enforce max_paste_size limit\n        } else {\n            // Check for paste start sequence\n        }\n    }\n}\n\npub enum InputEvent {\n    Key(KeyEvent),\n    Mouse(MouseEvent),\n    Paste(String),  // Complete paste content\n    Resize(u16, u16),\n    Focus(bool),\n}\n\n### SGR Mouse Protocol (1006)\nEscape sequence: ESC[<Cb;Cx;CyM or ESC[<Cb;Cx;Cym\n\nstruct SgrMouseParser;\n\nimpl SgrMouseParser {\n    /// Parse SGR extended mouse report\n    pub fn parse(&self, params: &[u8]) -> Option<MouseEvent> {\n        // Parse: <button;column;rowM or <button;column;rowm\n        // Button encoding:\n        //   0 = left, 1 = middle, 2 = right\n        //   +4 = shift, +8 = meta, +16 = ctrl\n        //   32 = motion, 64 = scroll\n        // M = press, m = release\n    }\n}\n\npub struct MouseEvent {\n    pub kind: MouseEventKind,\n    pub column: u16,\n    pub row: u16,\n    pub modifiers: KeyModifiers,\n}\n\npub enum MouseEventKind {\n    Down(MouseButton),\n    Up(MouseButton),\n    Drag(MouseButton),\n    Moved,\n    ScrollDown,\n    ScrollUp,\n    ScrollLeft,\n    ScrollRight,\n}\n\n### Enable/Disable Mouse\npub fn enable_mouse_capture(writer: &mut impl Write) -> io::Result<()> {\n    // Enable SGR extended mode (1006)\n    // Enable any-event tracking (1003) or button-event (1002)\n    write!(writer, \"\\x1b[?1000h\\x1b[?1006h\")?;\n    Ok(())\n}\n\npub fn disable_mouse_capture(writer: &mut impl Write) -> io::Result<()> {\n    write!(writer, \"\\x1b[?1006l\\x1b[?1000l\")?;\n    Ok(())\n}\n\n### Paste Size Limits\n- Default max: 1MB\n- Configurable via builder\n- Large pastes: return error or truncate\n\n### Focus Events (bonus)\n- Enable: ESC[?1004h\n- Disable: ESC[?1004l\n- Focus in: ESC[I\n- Focus out: ESC[O\n\n## Tests Required\n- [ ] Bracketed paste parse correct\n- [ ] Paste size limit enforced\n- [ ] SGR mouse button decoding\n- [ ] SGR mouse position decoding\n- [ ] Modifier key detection\n- [ ] Scroll events\n- [ ] Motion events\n- [ ] Focus events\n\n## Acceptance Criteria\n- [ ] Bracketed paste with size limit\n- [ ] SGR mouse protocol parsing\n- [ ] All mouse event types\n- [ ] Modifier key capture\n- [ ] Focus in/out events\n- [ ] Enable/disable APIs\n\n## Location: ftui-core crate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:37:03.205238952Z","created_by":"ubuntu","updated_at":"2026-01-31T22:37:55.993493314Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3i6","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:37:55.993463057Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3k4","title":"Implement Canvas widget for custom drawing","description":"PHASE 7 - EXTRAS: CANVAS WIDGET\n\n## Background\nCanvas widget enables arbitrary pixel/shape drawing using Braille/block characters. Useful for graphs, plots, and custom visualizations that exceed normal cell-based rendering.\n\n## Technical Requirements\n- Canvas coordinate system (virtual pixels mapped to cells)\n- Drawing primitives:\n  - Point, Line, Rectangle, Circle, Ellipse\n  - Polygon (filled/outline)\n  - Text at arbitrary positions\n- Braille mode: 2×4 dots per cell = 8 pixels\n- Block mode: 2×2 quadrants per cell = 4 pixels\n- Half-block mode: 2×1 vertical halves\n- Color support within resolution limits\n- Painter API for building drawings\n\n## Design Rationale\nFeature-gated extra for visualization use cases. Braille provides highest resolution but requires font support. Multiple modes allow fallback based on terminal capabilities.\n\n## Acceptance Criteria\n- [ ] Canvas struct with configurable resolution mode\n- [ ] All drawing primitives\n- [ ] Braille character mapping\n- [ ] Block character mapping\n- [ ] Color support per primitive\n- [ ] Painter builder pattern\n- [ ] Coordinate transformation (pan, zoom)\n- [ ] Feature gate: canvas\n\n## Performance Budget\n- Line rasterization: Bresenham's algorithm\n- 1000 points render: < 1ms\n\n## Location: ftui-extras crate (feature = \"canvas\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:19:44.847948610Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:35.106522209Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3k4","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:22:35.106494166Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ky","title":"OpenTUI Core Systems (opentui_rust port)","description":"# OpenTUI Core Systems (reference extraction, not a blind port)\n\n## Purpose\nThis epic exists for **traceability** to `opentui_rust`.\n\nWe are not doing a 1:1 port. Instead, we selectively extract ideas and components that strengthen FrankenTUI’s kernel or optional extras.\n\n## Plan Alignment\nThe plan explicitly says:\n- keep only kernel-strengthening primitives\n- de-scope “the widget zoo” into feature-gated layers\n\nThis epic is a place to record what we *borrowed*, why, and where it lands in the ftui crate layout.\n\n## Reference Source\n- `legacy_reference_library_code/opentui_rust/src/`\n\n## What We Intend To Reuse (High-level)\n- Efficient terminal control sequence encoding (CSI/OSC/DEC modes)\n- Buffer drawing helpers (lines/rects/borders) to implement widgets ergonomically\n- Robust raw-mode / cleanup discipline patterns\n- Optional text infrastructure (rope/editor/view) if/when we ship a richer editor\n- Optional unicode utilities (normalization/search/bidi) if/when needed\n- Optional tokenization infrastructure for syntax highlighting\n\n## Tracked Issues (live elsewhere in the plan tree)\nThese issues are the concrete “extractions” and/or feature-gated extras derived from OpenTUI:\n- `bd-3ky.1` ANSI sequence encoding helpers (feeds Presenter / TerminalWriter)\n- `bd-3ky.2` Buffer drawing operations (feeds widget implementations)\n- `bd-3ky.10` Raw mode handling + cleanup patterns (feeds TerminalSession / backend)\n- `bd-3ky.3` Tokenizer engine (optional; feeds syntax highlighting)\n- `bd-3ky.13` Language tokenizers (optional; feeds syntax highlighting)\n- `bd-3ky.4` Highlight theme system (optional; feeds syntax highlighting)\n- `bd-3ky.5` Rope (optional; feeds TextArea/editor)\n- `bd-3ky.6` Editor core (optional; feeds TextArea/editor)\n- `bd-3ky.14` Text View (optional; feeds Viewport/TextArea)\n- `bd-3ky.7` BiDi (optional)\n- `bd-3ky.8` Normalization (optional)\n- `bd-3ky.9` Search (optional)\n\n## Non-Goals\n- A monolithic “OpenTUI port” that blocks ftui kernel shipping\n- Shipping optional features before Gate 1–2 (inline stability + presenter correctness)\n\n## Success Criteria\n- [ ] Each tracked issue above is explicitly mapped to an ftui crate/module and feature flag (where applicable).\n- [ ] Kernel-critical extractions (ANSI encoding, drawing ops, raw-mode discipline) have tests and are used by core ftui paths.\n- [ ] Optional extras remain feature-gated and cannot destabilize inline mode or presenter invariants.\n- [ ] This epic remains a traceability index (no duplicated implementation work hidden here).","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-31T23:00:44.420755776Z","created_by":"ubuntu","updated_at":"2026-02-01T00:23:27.294316159Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky","depends_on_id":"bd-10i","type":"parent-child","created_at":"2026-01-31T23:57:58.959386119Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T23:04:26.303601247Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":4,"issue_id":"bd-3ky","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.1","title":"Implement ANSI sequence generator module","description":"# Implement ANSI sequence encoding helpers (CSI/OSC/DEC)\n\n## Objective\nImplement a small, well-tested set of helpers to encode the ANSI/VT control sequences that ftui emits.\n\nThis is **not** about terminal state tracking or diffing; it is only about producing correct bytes for known operations.\n\n## Why This Exists\nPresenter correctness depends on:\n- emitting syntactically valid sequences\n- emitting correctly terminated OSC strings\n- using consistent conventions (1-indexed CUP, correct separators)\n\nIsolating sequence encoding makes the Presenter easier to reason about and test.\n\n## Reference (for ideas / completeness)\n- `legacy_reference_library_code/opentui_rust/src/ansi/output.rs`\n- `legacy_reference_library_code/opentui_rust/src/ansi/sequences.rs`\n\n## Scope\nSupport encoding helpers for sequences we plan to use:\n\n### CSI sequences\n- SGR (reset, attributes, fg/bg: 16/256/truecolor)\n- CUP cursor positioning (row/col, 1-indexed)\n- relative cursor moves (optional; only if Presenter uses them)\n- EL/ED erase variants used by Presenter\n- DECSTBM scroll region (for inline mode optimizations)\n- DECSET/DECRST toggles used by TerminalSession/TerminalWriter\n- DEC 2026 synchronized output begin/end\n\n### OSC sequences\n- OSC 8 hyperlinks (start/end)\n- (Optional) OSC 52 clipboard (Phase 7)\n- (Optional) OSC title\n\n### Modes\n- bracketed paste enable/disable\n- mouse tracking enable/disable (SGR encoding)\n\n## Design Notes\n- Keep this layer **pure**: it should generate bytes into a buffer, not own terminal state.\n- Avoid per-call allocations where possible (reuse a scratch buffer).\n- Prefer explicit, readable helpers over “clever” formatting.\n\n## Integration Points\n- `bd-10i.4.3` (Presenter) depends on this issue.\n- TerminalSession / TerminalWriter may also reuse the same helpers for mode toggles.\n\n## Tests Required\n- Unit tests for exact bytes for each helper (table-driven).\n- Unit tests for OSC termination correctness (ST vs BEL if supported).\n- Property tests:\n  - sequences are ASCII bytes\n  - OSC sequences are always terminated\n\n## Acceptance Criteria\n- [ ] Helper API exists for the sequences listed in Scope (or an explicit list of omissions is documented).\n- [ ] Unit tests cover every helper and verify exact byte output.\n- [ ] OSC 8 link sequences are always properly terminated.\n- [ ] Presenter uses this layer (no ad-hoc string formatting for core sequences).","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] SGR sequences for all 16, 256, and RGB colors\n- [ ] SGR sequences for all text attributes (bold, italic, underline, etc.)\n- [ ] Cursor movement: absolute (CUP), relative (CUU/CUD/CUF/CUB)\n- [ ] Cursor save/restore (DECSC/DECRC)\n- [ ] Erase sequences: line (EL), screen (ED) with all modes\n- [ ] Scroll region (DECSTBM) setup and restore\n- [ ] Mode switching: DECSET/DECRST for alt screen, mouse, paste\n- [ ] OSC sequences: hyperlinks (OSC 8), title (OSC 0/2), clipboard (OSC 52)\n- [ ] Synchronized output (DEC 2026) with fallback\n- [ ] All sequences batched to single write syscall per frame\n\n### Correctness Requirements\n- [ ] All sequences conform to ECMA-48 and xterm spec\n- [ ] No malformed sequences emitted (valid ESC, CSI, OSC terminators)\n- [ ] State tracking prevents redundant sequences\n- [ ] Proper escaping of user content in OSC parameters\n\n### Performance Requirements\n- [ ] Sequence generation: < 100ns per sequence\n- [ ] Frame buffer assembly: < 50µs for 80x24 terminal\n- [ ] Zero allocation for common sequences (use stack buffers)\n\n### Logging Requirements\n- [ ] tracing::trace! for each sequence emitted (behind feature flag)\n- [ ] tracing::debug! for mode changes\n- [ ] tracing::warn! for fallback activation\n\n### Test Coverage\n- [ ] Unit test for every sequence type\n- [ ] Property test: all output is valid UTF-8\n- [ ] Conformance tests against VT100/xterm reference\n- [ ] Fuzz test: no panics on arbitrary state","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:00:58.180891179Z","created_by":"ubuntu","updated_at":"2026-02-01T00:24:35.391040653Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.1","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T23:59:46.691728039Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":3,"issue_id":"bd-3ky.1","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.10","title":"Implement terminal raw mode handling","description":"# Implement terminal raw mode handling + cleanup discipline\n\n## Objective\nImplement the terminal backend glue needed for ftui to:\n- enter raw mode\n- enable/disable terminal modes (mouse, bracketed paste, focus, sync output)\n- reliably restore the user’s terminal on exit and on panic\n\n## Why This Matters\nMost “TUI flakiness” is actually cleanup failure:\n- cursor stays hidden\n- raw mode persists\n- bracketed paste remains enabled\n- scroll region not reset\n\nWe must treat cleanup as a first-class invariant.\n\n## Reference (for patterns)\n- `legacy_reference_library_code/opentui_rust/src/` terminal/raw mode modules\n\n## Scope\nImplement (or wrap) backend operations:\n- enter/exit raw mode (RAII)\n- show/hide cursor\n- enter/exit alt-screen (optional; inline mode is default)\n- enable/disable:\n  - bracketed paste\n  - mouse (SGR)\n  - focus events\n  - sync output (DEC 2026) where supported\n- ensure drop/cleanup executes even when unwinding (panic path)\n\n## Design Notes\n- This must integrate with the chosen backend (ADR-003).\n- Cleanup must be idempotent (safe to call twice).\n- Failures during cleanup should be logged but must not panic.\n\n## Tests Required\n- PTY integration tests (release mode where relevant) that assert after process exit:\n  - raw mode is restored\n  - cursor is visible\n  - bracketed paste is disabled\n  - mouse mode is disabled\n  - alt-screen exited (if used)\n  - scroll region reset (if used)\n\nScenarios:\n- normal exit\n- panic during render\n- I/O error mid-write (best-effort cleanup)\n\n## Acceptance Criteria\n- [ ] RAII guard exists and is used by runtime/harness entrypoints.\n- [ ] Cleanup is idempotent and does not panic.\n- [ ] PTY tests cover normal + panic cleanup and pass reliably.\n- [ ] Mode toggles are routed through the one-writer policy (no ad-hoc stdout writes).","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Enter raw mode (disable line buffering, echo, signals)\n- [ ] Exit raw mode (restore original termios)\n- [ ] RAII guard for automatic cleanup on drop\n- [ ] Panic hook for emergency cleanup on panic\n- [ ] Alternative screen buffer enter/exit\n- [ ] Mouse mode enable/disable\n- [ ] Bracketed paste mode enable/disable\n- [ ] Cursor visibility control\n- [ ] Signal handling: SIGWINCH, SIGTERM, SIGINT\n\n### Safety Requirements\n- [ ] Terminal always restored on normal exit\n- [ ] Terminal always restored on panic\n- [ ] Terminal restored even on SIGKILL (best effort)\n- [ ] No undefined behavior on double-enter or double-exit\n- [ ] Thread-safe (only one raw mode active at a time)\n\n### Platform Requirements\n- [ ] Unix: termios manipulation\n- [ ] macOS: termios with BSD extensions\n- [ ] Windows: ConsoleMode manipulation (future)\n\n### Logging Requirements\n- [ ] tracing::info! on mode enter/exit\n- [ ] tracing::debug! for termios changes\n- [ ] tracing::error! for restoration failures\n- [ ] tracing::warn! for signal handler issues\n\n### Test Coverage\n- [ ] Unit test: enter/exit cycle\n- [ ] Unit test: RAII cleanup\n- [ ] PTY test: isolation from parent terminal\n- [ ] PTY test: cleanup after simulated panic\n- [ ] Integration test: signal handling","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:02:12.911475071Z","created_by":"ubuntu","updated_at":"2026-02-01T00:25:27.966378772Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.10","depends_on_id":"bd-10i.10.3","type":"blocks","created_at":"2026-02-01T00:25:14.984135057Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.10","depends_on_id":"bd-10i.2.6","type":"blocks","created_at":"2026-02-01T00:25:15.625294185Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.10","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T23:59:47.946966344Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":2,"issue_id":"bd-3ky.10","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.11","title":"Optional: runtime terminal capability probing (bounded timeouts)","description":"# Optional: runtime terminal capability probing (bounded timeouts)\n\n## Background\nPlan Section 0.4/9.1 + TerminalCapabilities contract: v1 detection should be conservative and environment-based.\n\nHowever, the plan allows an optional *feature-gated* probing layer:\n- device attribute queries (DA)\n- OSC queries\n\nCritical constraints:\n- probing must be bounded with timeouts\n- probing must fail-open (unknown => disable feature, never hang startup)\n- probing must not compromise the one-writer rule\n\n## Scope\nAdd an optional probing module that can refine `TerminalCapabilities`.\n\nExamples (only if safe and supported):\n- cursor position report (CPR)\n- DA1/DA2 (device attributes)\n- synchronized output support probing (if an unambiguous probe exists)\n- background color query (for dark/light heuristics) if we decide to support it\n\n## Design constraints\n- Must run only when we have exclusive terminal ownership (TerminalSession active).\n- Must be guarded by a feature flag (e.g., `caps-probe`).\n- Must never block indefinitely; hard timeouts.\n\n## Tests\n- Unit tests for response parsing\n- Integration tests (PTY) to ensure:\n  - probe timeouts do not hang\n  - capability results are conservative when probe fails\n\n## Acceptance Criteria\n- [ ] Feature-gated probe module exists.\n- [ ] All probes are bounded by timeouts and fail-open.\n- [ ] Tests cover success + timeout + malformed responses.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:02:19.243199848Z","created_by":"ubuntu","updated_at":"2026-01-31T23:18:00.759446498Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.11","depends_on_id":"bd-10i.2.6","type":"blocks","created_at":"2026-01-31T23:17:22.209661254Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.11","depends_on_id":"bd-10i.4","type":"parent-child","created_at":"2026-01-31T23:17:06.856234469Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.11","depends_on_id":"bd-10i.4.4","type":"blocks","created_at":"2026-01-31T23:17:22.796892855Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ky.12","title":"Implement optional render/output thread (Mode B)","description":"# Implement optional render/output thread (Mode B)\n\n## Background\nPlan Sections 0.9.2 (Mode B) and 8.2 describe an optional dedicated render/output thread.\n\nThis exists to solve the real harness problem:\n- logs can be produced by background tasks / subprocess capture\n- UI needs tick-driven updates\n- if output interleaves, inline mode breaks\n\nMode B keeps the **one-writer rule** by construction: the render thread is the only place bytes hit the terminal.\n\n## Scope\n- Feature-gated \"Mode B\" operation in addition to the default single-threaded mode.\n- Render/output thread owns:\n  - `TerminalSession` output handle\n  - `Presenter`\n  - `prev_buffer` (front buffer)\n  - inline-mode policy state (ui rect/anchor/height)\n\n## Design\n### Messages\n```rust\nenum OutMsg {\n    Log(Vec<u8>),\n    Render(Buffer),\n    Resize { w: u16, h: u16 },\n    SetMode(ScreenMode),\n    Shutdown,\n}\n```\n\n### Coalescing rules\n- Render messages are coalesced (\"latest wins\"):\n  - drop intermediate renders if a newer one arrives\n  - present at most one buffer per loop iteration\n- Log messages are *not* dropped, but are:\n  - newline-aware\n  - chunked to avoid starving UI\n\n### Error handling\n- Render thread errors propagate back to the Program so we can:\n  - restore terminal state\n  - exit with a useful error\n\n## Test Plan\n- PTY tests must run in both modes:\n  - default single-threaded mode\n  - render/output thread enabled\n- Stress tests:\n  - heavy log spam + UI tick (spinner) + resize storms\n  - ensure cursor invariants and scrollback preservation\n\n## Acceptance Criteria\n- [ ] Mode B can be enabled via feature flag and/or App/Program option.\n- [ ] All terminal writes are serialized in the render thread.\n- [ ] Render coalescing works (latest buffer presented).\n- [ ] Log chunking works and does not starve UI.\n- [ ] PTY tests pass in both Mode A and Mode B.\n\n## Location\nLikely `ftui-core` (thread + terminal ownership) with integration hooks in `ftui-runtime`.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Background thread for frame rendering\n- [ ] Double buffering with atomic swap\n- [ ] Frame rate limiting (configurable FPS cap)\n- [ ] Frame skipping when behind schedule\n- [ ] Graceful shutdown without hanging\n- [ ] Error propagation to main thread\n- [ ] Submit frame (non-blocking)\n- [ ] Flush pending frames (blocking)\n\n### Threading Requirements\n- [ ] Main thread never blocked on I/O\n- [ ] Channel-based command passing\n- [ ] No data races on buffer swap\n- [ ] Proper synchronization on shutdown\n\n### Performance Requirements\n- [ ] Submit latency: < 100µs\n- [ ] Render latency: < 1ms for 80x24\n- [ ] Memory: 2 buffers + channel overhead\n- [ ] No allocation per frame (buffer reuse)\n\n### Error Handling\n- [ ] I/O errors propagated to main thread\n- [ ] Panics in render thread caught\n- [ ] Graceful degradation on slow I/O\n\n### Logging Requirements\n- [ ] tracing::debug! for frame submission\n- [ ] tracing::debug! for frame skip\n- [ ] tracing::trace! for render timing\n- [ ] tracing::error! for I/O failures\n- [ ] tracing::info! for shutdown\n\n### Test Coverage\n- [ ] Unit test: submit/flush cycle\n- [ ] Unit test: frame rate limiting\n- [ ] Stress test: high FPS submission\n- [ ] Stress test: large frame buffers\n- [ ] Error injection test: I/O failure","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:02:25.066721177Z","created_by":"ubuntu","updated_at":"2026-01-31T23:21:00.786052735Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.12","depends_on_id":"bd-10i.2.6","type":"blocks","created_at":"2026-01-31T23:11:20.157864932Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.12","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T23:04:17.439227362Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.12","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T23:04:16.913196123Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.12","depends_on_id":"bd-10i.8","type":"parent-child","created_at":"2026-01-31T23:10:40.488717797Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.12","depends_on_id":"bd-10i.8.1","type":"blocks","created_at":"2026-01-31T23:11:26.835649872Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-3ky.13","title":"Implement language-specific tokenizers (Rust, Python, JS, JSON, TOML, Markdown)","description":"# Implement language tokenizers (optional)\n\n## Objective\nProvide per-language token definitions/adapters for the syntax tokenizer engine so we can highlight common formats.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Languages/formats (initial set):\n  - Rust\n  - Python\n  - JavaScript/TypeScript\n  - JSON\n  - TOML\n  - Markdown (for fenced code blocks)\n\n## Design Notes\n- Keep correctness and safety first: token ranges must always be valid.\n- Avoid heavyweight parsing; tokenization is for highlighting, not compilation.\n\n## Tests Required\n- Table-driven tests per language with representative snippets.\n- Ensure:\n  - keywords/strings/comments detected\n  - token ranges valid\n  - no panics on malformed input\n\n## Acceptance Criteria\n- [ ] At least one language tokenizer works end-to-end in `bd-381`.\n- [ ] Each supported language has tests with representative fixtures.\n- [ ] Malformed input never panics and produces valid ranges.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:04:47.816763643Z","created_by":"ubuntu","updated_at":"2026-02-01T00:32:25.380291577Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.13","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:53.710696913Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.13","depends_on_id":"bd-3ky.3","type":"blocks","created_at":"2026-01-31T23:04:56.197642632Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":9,"issue_id":"bd-3ky.13","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.14","title":"Implement text View (scrollable text display)","description":"# Implement Text View (scrolling + wrapping) (optional)\n\n## Objective\nImplement a text “view” utility that can:\n- compute visible ranges given scroll offset\n- perform wrapping (word-wrap + fallback)\n- support gutters/line numbers (optional)\n\nThis is a Phase 7 extra, but it can be leveraged by the harness Viewport/LogViewer.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/opentui_rust/src/text/view.rs`\n\n## Scope\n- Viewport math:\n  - scroll to line\n  - scroll by page\n  - compute visible lines/range\n- Wrapping:\n  - word wrap\n  - character wrap fallback\n- Optional:\n  - line number gutter\n  - selection highlights\n\n## Tests Required\n- Unit tests for visible range calculations.\n- Snapshot tests for wrapping behavior with Unicode.\n\n## Acceptance Criteria\n- [ ] View calculations are deterministic and tested.\n- [ ] Wrapping is Unicode-width correct (uses ftui width rules).\n- [ ] Viewport/LogViewer uses this (no duplicate wrapping/scroll logic).","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:04:54.331187709Z","created_by":"ubuntu","updated_at":"2026-02-01T00:33:26.976635354Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.14","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T23:14:44.620336451Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.14","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T23:04:57.288139223Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.14","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:54.357047639Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.14","depends_on_id":"bd-3ky.5","type":"blocks","created_at":"2026-01-31T23:04:56.744682359Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.14","depends_on_id":"bd-6e9.8","type":"blocks","created_at":"2026-01-31T23:04:57.928832265Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":8,"issue_id":"bd-3ky.14","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.15","title":"OpenTUI Core Systems Test Suite","description":"Comprehensive test suite for OpenTUI core systems. These are foundational components that require rigorous testing including fuzzing, property tests, and performance benchmarks.\n\n## Testing Philosophy\nCore systems require:\n1. **Correctness** - Behavior matches specification exactly\n2. **Robustness** - Handles malformed input gracefully\n3. **Performance** - Meets latency and throughput targets\n4. **Security** - No buffer overflows, escape injection, etc.\n\n## Test Requirements by Module\n\n### ANSI Sequence Generator (bd-3ky.1)\nUnit tests:\n- `test_sgr_reset` - \\x1b[0m emitted correctly\n- `test_sgr_fg_16` - ANSI 16-color foreground\n- `test_sgr_fg_256` - 256-color foreground\n- `test_sgr_fg_rgb` - 24-bit foreground\n- `test_sgr_bg_all` - Background color variants\n- `test_sgr_bold` - Bold attribute\n- `test_sgr_italic` - Italic attribute\n- `test_sgr_underline_variants` - Single, double, curly\n- `test_cursor_absolute` - CUP sequence\n- `test_cursor_relative` - CUU/CUD/CUF/CUB\n- `test_cursor_save_restore` - DECSC/DECRC\n- `test_erase_line` - EL variants\n- `test_erase_screen` - ED variants\n- `test_scroll_region` - DECSTBM\n- `test_mouse_enable` - SGR mouse mode\n- `test_bracketed_paste` - Enable/disable\n- `test_sync_output` - DEC mode 2026\n- `test_osc_hyperlink` - OSC 8 link sequences\n\nProperty tests:\n- `prop_sequences_valid_ascii` - All bytes are valid escape sequences\n- `prop_sequences_terminate` - All sequences properly terminated\n\nConformance tests:\n- `conformance_vt100` - VT100 compatibility\n- `conformance_xterm` - xterm extensions\n\n### Buffer Drawing (bd-3ky.2)\nUnit tests:\n- `test_draw_hline` - Horizontal line placement\n- `test_draw_vline` - Vertical line placement\n- `test_draw_line_diagonal` - Bresenham algorithm\n- `test_draw_rect_outline` - Rectangle border only\n- `test_draw_rect_filled` - Filled rectangle\n- `test_draw_border` - Border with corner chars\n- `test_print_ascii` - ASCII text at position\n- `test_print_unicode` - Wide characters handled\n- `test_print_styled` - Style applied to cells\n- `test_blit_opaque` - Buffer copied without alpha\n- `test_blit_alpha` - Alpha blending during blit\n- `test_scissor_clips` - Drawing clipped to scissor rect\n\nProperty tests:\n- `prop_draw_in_bounds` - All draws stay within buffer\n- `prop_scissor_respected` - Nothing drawn outside scissor\n\nBenchmark tests:\n- `bench_draw_line_1000` - 1000 lines < 1ms\n- `bench_blit_full_screen` - 80x24 blit < 100µs\n\n### Syntax Tokenizer (bd-3ky.3)\nUnit tests:\n- `test_tokenize_empty` - Empty string yields no tokens\n- `test_tokenize_whitespace` - Whitespace token type\n- `test_tokenize_keyword` - Language keywords detected\n- `test_tokenize_string_single` - Single-quoted strings\n- `test_tokenize_string_double` - Double-quoted strings\n- `test_tokenize_string_escape` - Escaped characters in strings\n- `test_tokenize_string_multiline` - State preserved across lines\n- `test_tokenize_comment_line` - // and # comments\n- `test_tokenize_comment_block` - /* */ comments\n- `test_tokenize_number_int` - Integer literals\n- `test_tokenize_number_float` - Float literals\n- `test_tokenize_number_hex` - Hexadecimal\n- `test_tokenize_operator` - Operators detected\n- `test_tokenize_incremental` - Re-tokenize after edit\n\nFuzz tests:\n- `fuzz_tokenizer_no_panic` - Random input never panics\n- `fuzz_tokenizer_valid_ranges` - Token ranges always valid\n\nPerformance tests:\n- `perf_tokenize_10k_lines` - 10,000 lines < 100ms\n\n### Highlight Theme (bd-3ky.4)\nUnit tests:\n- `test_theme_load_toml` - Parse theme from TOML\n- `test_theme_load_json` - Parse theme from JSON\n- `test_theme_builtin_dark` - Dark theme colors\n- `test_theme_builtin_light` - Light theme colors\n- `test_theme_token_style` - Style lookup by token type\n- `test_theme_fallback` - Unknown token uses default\n- `test_highlighted_buffer_cache` - Cache invalidation on edit\n\n### Text Rope (bd-3ky.5)\nUnit tests:\n- `test_rope_from_empty` - Empty rope\n- `test_rope_from_string` - Initialize from string\n- `test_rope_len_bytes` - Byte length tracking\n- `test_rope_len_lines` - Line count tracking\n- `test_rope_insert_start` - Insert at position 0\n- `test_rope_insert_middle` - Insert in middle\n- `test_rope_insert_end` - Append\n- `test_rope_delete_range` - Delete byte range\n- `test_rope_replace` - Delete + insert\n- `test_rope_line_access` - Get line by index\n- `test_rope_slice` - Extract substring\n- `test_rope_byte_to_line_col` - Coordinate conversion\n- `test_rope_line_col_to_byte` - Reverse conversion\n\nProperty tests:\n- `prop_rope_insert_delete_inverse` - Insert then delete = original\n- `prop_rope_len_consistent` - len() matches actual content\n- `prop_rope_lines_consistent` - line count matches newlines + 1\n\nPerformance tests:\n- `perf_rope_insert_random` - 10,000 random inserts < 100ms\n- `perf_rope_large_file` - 1MB file operations < 10ms\n\n### Text Editor (bd-3ky.6)\nUnit tests:\n- `test_editor_insert_char` - Single character insertion\n- `test_editor_insert_text` - Multi-char insertion\n- `test_editor_delete` - Delete forward\n- `test_editor_backspace` - Delete backward\n- `test_editor_move_cursor` - Arrow key movement\n- `test_editor_move_word` - Ctrl+Arrow movement\n- `test_editor_select_shift` - Shift+Arrow selection\n- `test_editor_select_all` - Ctrl+A selection\n- `test_editor_cut_copy_paste` - Clipboard operations\n- `test_editor_undo` - Single undo\n- `test_editor_undo_chain` - Multiple undos\n- `test_editor_redo` - Redo after undo\n- `test_editor_redo_discard` - New edit clears redo stack\n- `test_editor_transaction` - Grouped operations\n\nProperty tests:\n- `prop_editor_cursor_valid` - Cursor always in bounds\n- `prop_editor_undo_redo_inverse` - Full undo/redo is identity\n\n### Unicode BiDi (bd-3ky.7)\nUnit tests:\n- `test_bidi_ltr_only` - Left-to-right text unchanged\n- `test_bidi_rtl_only` - Right-to-left reversed\n- `test_bidi_mixed` - LTR with embedded RTL\n- `test_bidi_numbers_in_rtl` - Numbers in Arabic text\n- `test_bidi_explicit_marks` - LRM/RLM characters\n- `test_bidi_reorder_for_display` - Visual reordering\n\nConformance tests:\n- `conformance_uax9` - Unicode BiDi algorithm tests\n\n### Unicode Normalization (bd-3ky.8)\nUnit tests:\n- `test_nfc_combining` - Combining characters composed\n- `test_nfd_decompose` - Precomposed decomposed\n- `test_nfkc_compatibility` - Compatibility mappings\n- `test_nfkd_full_decompose` - Full compatibility decomposition\n- `test_quick_check_fast` - Already-normalized detected quickly\n\nConformance tests:\n- `conformance_normalization_tests` - Unicode consortium test suite\n\n### Unicode Search (bd-3ky.9)\nUnit tests:\n- `test_search_exact` - Exact substring match\n- `test_search_case_insensitive` - Case-folded match\n- `test_search_normalized` - NFC-normalized match\n- `test_search_whole_word` - Word boundary detection\n- `test_search_regex` - Regex pattern matching\n- `test_search_find_all` - All occurrences returned\n- `test_search_find_next` - Forward iteration\n- `test_search_find_prev` - Backward iteration\n\n### Terminal Raw Mode (bd-3ky.10)\nUnit tests:\n- `test_raw_mode_enter` - Mode entered successfully\n- `test_raw_mode_exit` - Mode restored on drop\n- `test_raw_mode_panic_cleanup` - Cleaned up on panic\n- `test_alt_screen_enter` - Switch to alt screen\n- `test_alt_screen_exit` - Return to main screen\n- `test_mouse_mode_enable` - Mouse events received\n- `test_signal_handler` - SIGWINCH handled\n\nPTY tests:\n- `pty_raw_mode_isolation` - Mode changes isolated to session\n- `pty_cleanup_on_crash` - Terminal restored after kill -9\n\n### Terminal Queries (bd-3ky.11)\nUnit tests:\n- `test_query_cursor_position` - CPR response parsed\n- `test_query_terminal_size` - Size query works\n- `test_query_timeout` - Timeout on no response\n- `test_query_partial_response` - Handle incomplete response\n\n### Threaded Renderer (bd-3ky.12)\nUnit tests:\n- `test_renderer_submit_frame` - Frame accepted\n- `test_renderer_frame_rate_limit` - FPS capped\n- `test_renderer_skip_frames` - Old frames skipped when behind\n- `test_renderer_shutdown_clean` - Graceful shutdown\n- `test_renderer_error_propagation` - I/O errors reach main thread\n\nStress tests:\n- `stress_renderer_high_fps` - 1000 FPS submission\n- `stress_renderer_large_frames` - 200x50 terminal\n\n### Language Tokenizers (bd-3ky.13)\nUnit tests per language:\n- Rust: keywords, lifetimes, macros, attributes, strings, comments\n- Python: keywords, decorators, f-strings, comments, indentation\n- JavaScript: keywords, template literals, JSX, comments\n- JSON: keys, strings, numbers, booleans, null, structure\n- TOML: sections, keys, strings, arrays, inline tables\n- Markdown: headers, emphasis, links, code blocks, lists\n\n### Text View (bd-3ky.14)\nUnit tests:\n- `test_view_scroll_to_line` - Scroll to specific line\n- `test_view_scroll_by_page` - Page up/down\n- `test_view_visible_range` - Correct range calculation\n- `test_view_wrap_word` - Word wrap at boundaries\n- `test_view_wrap_char` - Character wrap fallback\n- `test_view_line_numbers` - Line number gutter\n- `test_view_selection_highlight` - Selection styling\n- `test_view_search_highlight` - Search result styling\n\n## Logging Requirements\n- `tracing::debug!` for state transitions\n- `tracing::trace!` for per-operation details\n- `tracing::warn!` for recovered errors\n- `tracing::error!` for fatal conditions\n- Performance-sensitive paths use `tracing::trace_span!`\n\n## Coverage Targets\n- Line coverage: >= 95% (core systems are critical)\n- Branch coverage: >= 90%\n- Fuzzing: 1M iterations without crash\n\nDependencies: All OpenTUI modules, Testing infrastructure (bd-10i.11)\n\n\n## Acceptance Criteria\n- [ ] Test scope is aligned to the ftui components we actually ship (kernel-critical vs optional extras are clearly separated).\n- [ ] Suite includes unit + property + snapshot and PTY integration tests where appropriate.\n- [ ] Failures produce actionable logs (bytes/model diffs) and are reproducible in CI.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:17:04.100606955Z","created_by":"ubuntu","updated_at":"2026-02-01T00:25:52.777792373Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.15","depends_on_id":"bd-10i.11","type":"blocks","created_at":"2026-01-31T23:18:02.831842710Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.1","type":"blocks","created_at":"2026-01-31T23:18:34.064768965Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.10","type":"blocks","created_at":"2026-01-31T23:18:39.501250819Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.11","type":"blocks","created_at":"2026-01-31T23:18:40.087004178Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.12","type":"blocks","created_at":"2026-01-31T23:18:40.670255765Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.13","type":"blocks","created_at":"2026-01-31T23:18:41.257648851Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.14","type":"blocks","created_at":"2026-01-31T23:18:41.845876639Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.2","type":"blocks","created_at":"2026-01-31T23:18:34.678871472Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.3","type":"blocks","created_at":"2026-01-31T23:18:35.275303087Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.4","type":"blocks","created_at":"2026-01-31T23:18:35.830634573Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.5","type":"blocks","created_at":"2026-01-31T23:18:36.517946959Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.6","type":"blocks","created_at":"2026-01-31T23:18:37.064537096Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.7","type":"blocks","created_at":"2026-01-31T23:18:37.642713247Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.8","type":"blocks","created_at":"2026-01-31T23:18:38.218533111Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.15","depends_on_id":"bd-3ky.9","type":"blocks","created_at":"2026-01-31T23:18:38.900909122Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":1,"issue_id":"bd-3ky.15","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.2","title":"Implement Buffer drawing operations","description":"# Implement Buffer drawing operations\n\n## Objective\nAdd ergonomic, well-tested drawing helpers on top of the core `Buffer` so widgets/renderables can be implemented without duplicating low-level cell loops.\n\n## Why This Exists\nThe kernel is intentionally minimal, but widgets still need:\n- borders/lines\n- filling rects\n- blitting\n- text printing respecting clipping\n\nIf each widget reimplements these loops, we’ll get inconsistent behavior and bugs.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/opentui_rust/src/` buffer/drawing modules\n\n## Scope\nImplement a `BufferDraw`-style API (name TBD) that operates on a `Buffer` and respects:\n- scissor stack (no drawing outside clip)\n- opacity stack (alpha compositing rules)\n\nOperations to support (minimum):\n- draw horizontal/vertical lines\n- draw rectangle outline + filled rectangle\n- draw borders using a provided border character set\n- print text at position (ASCII + Unicode) without writing out-of-bounds\n- blit/copy regions between buffers (opaque + alpha)\n\nOptional (Phase 7 / nice-to-have):\n- Bresenham diagonal line\n- scroll-region related helpers for inline mode\n\n## Design Notes\n- Keep cell loops cache-friendly (row-major).\n- Avoid allocations inside tight loops.\n- All drawing must be clipped via scissor (even if caller passes a bad rect).\n\n## Tests Required\n- Unit tests for each operation with small fixed buffers (readable expected grids).\n- Property tests:\n  - never writes out of bounds\n  - scissor is always respected\n  - opacity stack always clamps to [0,1]\n\n## Acceptance Criteria\n- [ ] API exists for the “minimum” scope operations above.\n- [ ] All operations respect scissor and opacity stacks.\n- [ ] Unit tests cover border/rect/text/blit semantics.\n- [ ] At least one widget/renderable depends on this (no dead code).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:01:07.671267058Z","created_by":"ubuntu","updated_at":"2026-02-01T00:24:54.696189383Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.2","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-01-31T23:14:42.627519466Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.2","depends_on_id":"bd-10i.3.4","type":"blocks","created_at":"2026-01-31T23:04:10.712265139Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.2","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T23:04:10.193676237Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.2","depends_on_id":"bd-10i.3.7","type":"blocks","created_at":"2026-01-31T23:04:11.241988307Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.2","depends_on_id":"bd-10i.7","type":"parent-child","created_at":"2026-01-31T23:59:47.285566426Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":21,"issue_id":"bd-3ky.2","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.3","title":"Implement syntax tokenizer engine","description":"# Implement syntax tokenizer engine (optional)\n\n## Objective\nImplement a tokenization engine that can turn source text into a stream of tokens suitable for syntax highlighting.\n\nPhase 7 extra; should be feature-gated and must not affect kernel invariants.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/opentui_rust/src/highlight/` and tokenization modules\n\n## Scope\n- A tokenizer interface that supports:\n  - incremental tokenization (optional)\n  - per-language token definitions (delegated to `bd-3ky.13`)\n- Token output should include:\n  - token kind\n  - byte range (start..end)\n  - optional metadata (e.g., nesting)\n\n## Tests Required\n- Unit tests for basic token kinds (keywords/strings/comments) on small fixtures.\n- Fuzz tests ensuring no panics and valid ranges.\n\n## Acceptance Criteria\n- [ ] Tokenizer engine API exists and is used by syntax highlighting (`bd-381`).\n- [ ] Tokens always have valid, in-bounds ranges.\n- [ ] Unit tests + fuzz/no-panic tests exist.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Token types: Keyword, String, Number, Comment, Operator, Punctuation, Identifier, Type, Function, Attribute, Macro, Whitespace, Error\n- [ ] State machine for multi-line tokens (strings, block comments)\n- [ ] State passed between lines for continuations\n- [ ] Incremental re-tokenization on single-line edit\n- [ ] Token range queries (get tokens in byte range)\n- [ ] Token iteration API\n\n### Language Support (via bd-3ky.13)\n- [ ] Grammar definitions are data-driven\n- [ ] New languages can be added without code changes\n- [ ] Fallback to plain text for unknown languages\n\n### Performance Requirements\n- [ ] Tokenize single line: < 10µs for typical 80-char line\n- [ ] Tokenize 10,000 lines: < 100ms\n- [ ] Incremental update: < 1ms for single line change\n- [ ] Memory: < 50 bytes per line state\n\n### Robustness Requirements\n- [ ] Never panic on any input\n- [ ] Malformed syntax produces Error tokens, not crashes\n- [ ] Unterminated strings/comments handled gracefully\n- [ ] Binary/non-UTF8 produces Error tokens\n\n### Logging Requirements\n- [ ] tracing::trace! for token production (debug builds)\n- [ ] tracing::debug! for state transitions\n- [ ] tracing::warn! for tokenization errors\n\n### Test Coverage\n- [ ] Unit tests per token type\n- [ ] Fuzz test: 1M random strings, no panic\n- [ ] Conformance tests for each language\n- [ ] Property test: token ranges cover entire input","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:01:15.428988015Z","created_by":"ubuntu","updated_at":"2026-02-01T00:32:13.462848732Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.3","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:49.186588318Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.3","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:04:11.775766255Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":20,"issue_id":"bd-3ky.3","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.4","title":"Implement highlight theme system","description":"# Implement highlight theme system (optional)\n\n## Objective\nImplement a theme mapping from token kinds to ftui styles, enabling syntax highlighting.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- A `HighlightTheme` that maps token kinds → `Style`.\n- Built-in themes (minimal): light + dark.\n- Optional: load theme from TOML/JSON.\n\n## Integration Notes\n- Must integrate with ftui theme/style system (`bd-22q`, `bd-2yd`, `bd-10x`).\n\n## Tests Required\n- Unit tests for theme parsing (if supported).\n- Snapshot tests for a small highlighted snippet (tokenize + apply theme).\n\n## Acceptance Criteria\n- [ ] Highlight theme can be applied to tokens from `bd-3ky.3`.\n- [ ] At least one builtin theme exists.\n- [ ] Tests validate deterministic styling output.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:01:20.871415257Z","created_by":"ubuntu","updated_at":"2026-02-01T00:32:38.157180235Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.4","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:49.819939020Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.4","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:04:12.806761776Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.4","depends_on_id":"bd-3ky.3","type":"blocks","created_at":"2026-01-31T23:04:12.284361089Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":19,"issue_id":"bd-3ky.4","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.5","title":"Implement text Rope data structure","description":"# Implement text Rope data structure (optional)\n\n## Objective\nImplement a rope (or rope-like) text storage structure to support efficient edits on large, multi-line text.\n\nPhase 7 extra; intended to support TextArea/editor functionality.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/opentui_rust/src/text/` rope/editor modules\n\n## Scope\n- Construction from `&str` / `String`\n- Efficient insert/delete/replace at arbitrary offsets\n- Line-oriented access:\n  - number of lines\n  - get line by index\n  - byte offset ↔ (line, col) conversion\n\n## Tests Required\n- Unit tests for core operations.\n- Property tests:\n  - insert + delete roundtrip\n  - coordinate conversions are consistent\n- Performance sanity tests (benchmarks optional).\n\n## Acceptance Criteria\n- [ ] Rope supports insert/delete/replace with correct results.\n- [ ] Line access and coordinate conversions are correct and tested.\n- [ ] Property tests cover roundtrips and invariants.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Create rope from empty, string, and file\n- [ ] Insert text at any byte position in O(log n)\n- [ ] Delete byte range in O(log n)\n- [ ] Replace (delete + insert) atomically\n- [ ] Get line by index in O(log n)\n- [ ] Slice extraction returns Cow (zero-copy when possible)\n- [ ] Byte offset to line/column conversion\n- [ ] Line/column to byte offset conversion\n- [ ] Character and grapheme iteration\n- [ ] Line iteration with proper newline handling\n\n### Correctness Requirements\n- [ ] All operations maintain rope invariants (balanced tree)\n- [ ] Line count always matches actual newline count + 1\n- [ ] Byte length always matches actual content length\n- [ ] UTF-8 validity preserved on all operations\n- [ ] Operations at grapheme boundaries don't split graphemes\n\n### Performance Requirements\n- [ ] Insert 10,000 random positions: < 100ms\n- [ ] Delete 10,000 random ranges: < 100ms\n- [ ] Load 1MB file: < 50ms\n- [ ] Memory overhead: < 2x document size\n- [ ] Chunk size: 64-256 bytes for cache efficiency\n\n### Logging Requirements\n- [ ] tracing::trace! for rebalance operations\n- [ ] tracing::debug! for large insertions (> 10KB)\n- [ ] tracing::info! for file load completion\n\n### Test Coverage\n- [ ] Unit tests for all public methods\n- [ ] Property test: insert-delete inverse\n- [ ] Property test: line count consistency\n- [ ] Stress test: 1M random edits without crash\n- [ ] Benchmark regression tests","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:01:33.850875181Z","created_by":"ubuntu","updated_at":"2026-02-01T00:32:58.082489689Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.5","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:50.443547644Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":18,"issue_id":"bd-3ky.5","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.6","title":"Implement text Editor core","description":"# Implement text Editor core (optional)\n\n## Objective\nImplement the core editing operations on top of Rope + cursor utilities.\n\nThis is a Phase 7 extra that powers TextArea and potential future editor-like widgets.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/opentui_rust/src/text/editor.rs`\n\n## Scope\n- Editing ops:\n  - insert text\n  - delete forward/backward\n  - newline handling\n- Cursor movement:\n  - left/right/up/down\n  - word-left/word-right\n  - line start/end\n- Optional (can be phased):\n  - selection\n  - undo/redo\n  - transactions/grouped edits\n\n## Tests Required\n- Unit tests for each editing operation.\n- Property tests:\n  - cursor always stays in bounds\n  - undo/redo roundtrips if implemented\n\n## Acceptance Criteria\n- [ ] Editor supports basic insert/delete/move semantics and is tested.\n- [ ] Cursor never becomes invalid/out-of-bounds.\n- [ ] TextArea uses this editor core (no duplicated editing logic).","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Cursor position management (byte offset and line/col)\n- [ ] Selection with anchor and head\n- [ ] Insert character at cursor\n- [ ] Insert text at cursor (multi-char)\n- [ ] Delete forward (Delete key)\n- [ ] Delete backward (Backspace)\n- [ ] Delete word forward/backward\n- [ ] Delete line\n- [ ] Move cursor: left/right/up/down/home/end\n- [ ] Move cursor by word\n- [ ] Select: shift+movement, select all, select word, select line\n- [ ] Cut, copy, paste operations\n- [ ] Undo/redo with history\n- [ ] Transaction grouping for compound operations\n\n### Grapheme Awareness\n- [ ] All operations respect grapheme boundaries\n- [ ] Wide characters handled correctly\n- [ ] Combining marks stay with base character\n- [ ] Cursor never positioned inside grapheme\n\n### History Requirements\n- [ ] Single undo step per logical operation\n- [ ] Undo groups by word boundaries for typing\n- [ ] Paste is single undo unit\n- [ ] Transaction commits as single undo unit\n- [ ] Redo cleared on new edit\n\n### Logging Requirements\n- [ ] tracing::debug! for cursor movement\n- [ ] tracing::debug! for selection changes\n- [ ] tracing::info! for undo/redo\n- [ ] tracing::trace! for individual edits\n\n### Test Coverage\n- [ ] Unit tests for all edit operations\n- [ ] Property test: cursor always valid\n- [ ] Property test: undo/redo inverse\n- [ ] Unicode corpus tests\n- [ ] Stress test: rapid editing","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:01:43.801662252Z","created_by":"ubuntu","updated_at":"2026-02-01T00:33:06.415187180Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.6","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:51.081668711Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.6","depends_on_id":"bd-3ky.5","type":"blocks","created_at":"2026-01-31T23:04:13.314121635Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.6","depends_on_id":"bd-6e9.7","type":"blocks","created_at":"2026-01-31T23:04:13.818753221Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.6","depends_on_id":"bd-6e9.8","type":"blocks","created_at":"2026-01-31T23:04:14.333680692Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":17,"issue_id":"bd-3ky.6","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.7","title":"Implement Unicode bidi algorithm","description":"# Implement Unicode BiDi algorithm (optional)\n\n## Objective\nProvide optional BiDi reordering support for mixed LTR/RTL text.\n\nThis is Phase 7 extra; we should only ship it if we can do it correctly and test it against known corpora.\n\n## Scope\n- A BiDi processing function that can reorder text for display.\n- Optional: support for explicit marks (LRM/RLM).\n\n## Tests Required\n- Conformance tests against known Unicode BiDi test suites (UAX#9).\n- Unit tests for representative mixed-direction strings.\n\n## Acceptance Criteria\n- [ ] BiDi implementation matches UAX#9 expectations on a representative test corpus.\n- [ ] API is optional/feature-gated and does not affect default rendering paths.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:01:49.118921016Z","created_by":"ubuntu","updated_at":"2026-02-01T00:33:39.785400531Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.7","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:51.723100642Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":16,"issue_id":"bd-3ky.7","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.8","title":"Implement Unicode normalization","description":"# Implement Unicode normalization (optional)\n\n## Objective\nProvide optional normalization utilities (NFC/NFD/NFKC/NFKD) for text processing and search.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Normalization functions (at least NFC + NFKC if we need compatibility folding).\n- Fast path / quick-check if supported.\n\n## Tests Required\n- Conformance tests using Unicode normalization test data.\n- Unit tests for common edge cases.\n\n## Acceptance Criteria\n- [ ] Normalization functions are correct on a representative conformance corpus.\n- [ ] API is feature-gated and does not change default rendering behavior unless enabled.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:01:54.782143835Z","created_by":"ubuntu","updated_at":"2026-02-01T00:33:40.510682698Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.8","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:52.358863387Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":15,"issue_id":"bd-3ky.8","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3ky.9","title":"Implement Unicode text search","description":"# Implement Unicode-aware text search (optional)\n\n## Objective\nProvide optional search utilities for text views/editors, including normalization-aware and case-folded search.\n\nPhase 7 extra; feature-gated.\n\n## Scope\n- Exact substring search\n- Case-insensitive search (Unicode case folding, if enabled)\n- Optional: normalization-aware search\n\n## Tests Required\n- Unit tests for:\n  - exact search\n  - overlapping matches\n  - case-fold behavior\n- Property tests to ensure returned ranges are valid.\n\n## Acceptance Criteria\n- [ ] Search returns correct ranges and never panics on arbitrary input.\n- [ ] Optional normalization/case-fold behavior is explicit and tested.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T23:02:05.877682695Z","created_by":"ubuntu","updated_at":"2026-02-01T00:33:41.101039414Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3ky.9","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:53.074438024Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.9","depends_on_id":"bd-3ky.8","type":"blocks","created_at":"2026-01-31T23:04:14.843910884Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-3ky.9","depends_on_id":"bd-6e9.8","type":"blocks","created_at":"2026-01-31T23:04:15.373466997Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":14,"issue_id":"bd-3ky.9","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-3mo","title":"Implement markup parsing for styled text","description":"PHASE 4/EXTRAS - MARKUP PARSER (Feature-gated)\n\n## Background\nMarkup parsing allows writing styled text with inline syntax like [bold]text[/bold] or Rich-style markup. Feature-gated as it's not needed by all apps.\n\n## Technical Requirements\n\n### Markup Syntax Options\n\n#### Option A: BBCode-style\n[bold]Bold text[/bold]\n[italic]Italic[/italic]\n[fg=red]Red text[/fg]\n[bg=#00ff00]Green background[/bg]\n[link=https://example.com]Click here[/link]\n\n#### Option B: Rich-style (Python Rich compatible)\n[bold]Bold[/bold]\n[red]Red text[/red]\n[on blue]Blue background[/on blue]\n[link=url]Link text[/link]\n[#ff0000]Hex color[/#ff0000]\n\n### Parser Structure\n\npub struct MarkupParser {\n    style_stack: Vec<Style>,\n    current_style: Style,\n}\n\nimpl MarkupParser {\n    /// Parse markup string into styled Text\n    pub fn parse(&mut self, input: &str) -> Result<Text, MarkupError> {\n        let mut spans = Vec::new();\n        let mut current_text = String::new();\n        \n        for token in self.tokenize(input)? {\n            match token {\n                Token::Text(s) => current_text.push_str(&s),\n                Token::StyleStart(style) => {\n                    if !current_text.is_empty() {\n                        spans.push(Span::styled(\n                            std::mem::take(&mut current_text),\n                            self.current_style.clone(),\n                        ));\n                    }\n                    self.style_stack.push(self.current_style.clone());\n                    self.current_style = self.current_style.merge(style);\n                }\n                Token::StyleEnd => {\n                    if !current_text.is_empty() {\n                        spans.push(Span::styled(\n                            std::mem::take(&mut current_text),\n                            self.current_style.clone(),\n                        ));\n                    }\n                    self.current_style = self.style_stack.pop().unwrap_or_default();\n                }\n            }\n        }\n        \n        Ok(Text::from_spans(spans))\n    }\n}\n\n### Error Handling\npub enum MarkupError {\n    UnmatchedTag { tag: String, position: usize },\n    InvalidColor { value: String },\n    InvalidAttribute { name: String },\n    NestedLinkNotAllowed,\n}\n\n### Extension: Emoji Shortcodes\nOptional: :smile: -> 😀, :rocket: -> 🚀\n\npub fn expand_emoji(input: &str) -> Cow<str> {\n    // Fast path: no colons\n    if !input.contains(':') {\n        return Cow::Borrowed(input);\n    }\n    // Replace :name: patterns with Unicode\n}\n\n### Integration\n// Direct usage\nlet text = markup!(\"[bold]Hello[/bold] [red]world[/red]\");\n\n// Via Text\nlet text = Text::from_markup(\"[bold]Hello[/bold]\");\n\n// In widgets\nParagraph::new(markup!(\"[italic]Styled[/italic] text\"))\n\n## Tests Required\n- [ ] Bold tag parsing\n- [ ] Color name parsing\n- [ ] Hex color parsing\n- [ ] Nested tags\n- [ ] Unclosed tag error\n- [ ] Escape sequences (\\\\[)\n- [ ] Empty tags\n- [ ] Link with URL\n- [ ] Performance: 1000 char markup < 100µs\n\n## Acceptance Criteria\n- [ ] BBCode-style syntax supported\n- [ ] All style attributes (fg, bg, bold, italic, underline)\n- [ ] Link parsing with URL extraction\n- [ ] Error handling with positions\n- [ ] Escape sequence support\n- [ ] Optional emoji expansion\n- [ ] Feature gate: markup\n\n## Location: ftui-text crate (feature = \"markup\")","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:37:44.886882212Z","created_by":"ubuntu","updated_at":"2026-01-31T22:37:56.617722024Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-3mo","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:37:56.617685796Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-6e9","title":"Bubbles Widget Collection (charmed_rust port)","description":"# Bubbles Widget Collection (optional, feature-gated)\n\n## Purpose\nThis epic tracks additional widgets inspired by `charmed_rust` (Bubbletea/Bubbles ecosystem).\n\nThese are **not required** for the core ftui kernel or the first agent harness deliverable, but we keep them as optional feature-gated extensions.\n\n## Reference Source\n- `legacy_reference_library_code/charmed_rust/`\n\n## Plan Alignment\nThe plan explicitly de-scopes “widget zoo” into Phase 7:\n- ship kernel + runtime + harness first\n- only then add extra widgets\n\n## Scope\nWidgets here must:\n- render deterministically\n- respect focus/input conventions\n- avoid terminal side effects (all output goes through ftui’s one-writer routing)\n\n## Success Criteria\n- [ ] Widgets are feature-gated and cannot affect kernel invariants when disabled.\n- [ ] Each widget has snapshot tests + interaction/unit tests where applicable.\n- [ ] Widgets integrate with ftui-style/theme and ftui-runtime subscriptions cleanly.","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-31T22:57:47.683736546Z","created_by":"ubuntu","updated_at":"2026-02-01T00:24:00.738296346Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9","depends_on_id":"bd-10i.6","type":"blocks","created_at":"2026-01-31T23:04:25.246802134Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9","depends_on_id":"bd-10i.9","type":"parent-child","created_at":"2026-01-31T23:59:07.030972351Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":34,"issue_id":"bd-6e9","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.1","title":"Implement TextArea widget (multi-line text editor)","description":"# Implement TextArea widget (multi-line text editor)\n\n## Objective\nImplement a multi-line text editor widget suitable for agent harnesses and future tools.\n\nThis is **not required** for the v1 harness (which needs TextInput), but it’s a valuable Phase 7 extra.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/charmed_rust/crates/bubbles/src/textarea.rs`\n\n## Scope\n- Editing:\n  - insert text (including multi-line paste)\n  - backspace/delete\n  - newline\n  - selection (optional v1; can be phased)\n  - undo/redo (optional; can defer)\n- Navigation:\n  - arrows, home/end\n  - word-left/word-right\n  - page up/down (optional)\n- View:\n  - scrolling viewport within the editor\n  - cursor visibility and scroll-to-cursor behavior\n  - soft-wrap vs hard-wrap policy (explicit)\n\n## Integration Notes\n- Reuse text infrastructure rather than inventing a parallel one:\n  - Rope storage (`bd-3ky.5`)\n  - Editor ops (`bd-3ky.6`)\n  - Cursor utilities (`bd-6e9.7`)\n  - Grapheme segmentation helpers (`bd-6e9.8`)\n- Rendering must be deterministic into `Buffer`/`Frame`.\n- All input must come through ftui Event/InputParser.\n\n## Tests Required\n- Unit tests for editor ops (insert/delete/move) with tricky Unicode.\n- Snapshot tests for rendering under:\n  - narrow widths\n  - long lines\n  - multi-line content\n  - cursor at boundaries\n- PTY test (optional) demonstrating interactive editing without terminal corruption.\n\n## Acceptance Criteria\n- [ ] TextArea supports basic multi-line editing and cursor navigation.\n- [ ] Cursor never splits graphemes; visual column math matches ftui width rules.\n- [ ] Rendering is stable and scroll-to-cursor works.\n- [ ] Unit + snapshot tests cover representative and adversarial cases.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] Multi-line text insertion and deletion works correctly\n- [ ] Cursor movement: left/right/up/down/home/end/word navigation\n- [ ] Text selection with Shift+Arrow, Ctrl+Shift+Arrow, Shift+Home/End\n- [ ] Word wrapping: soft wrap preserves buffer, hard wrap inserts newlines\n- [ ] Viewport scrolling follows cursor and supports manual scroll\n- [ ] Undo/redo: all operations reversible, undo groups by word boundaries\n- [ ] Clipboard: copy/cut/paste including bracketed paste support\n- [ ] Line numbers display option\n- [ ] Placeholder text shown when empty\n- [ ] Character limit enforcement prevents exceeding limit\n- [ ] Validation callback can reject invalid input\n\n### Unicode Requirements\n- [ ] ZWJ sequences (emoji families) treated as single grapheme\n- [ ] Wide characters (CJK) render as 2 cells\n- [ ] Combining characters handled correctly\n- [ ] RTL text renders correctly (if bidi enabled)\n\n### Performance Requirements\n- [ ] Typing latency < 5ms for buffers up to 100K characters\n- [ ] Scrolling latency < 16ms (60 FPS capable)\n- [ ] Memory: < 3x document size overhead\n\n### Logging Requirements\n- [ ] tracing::debug! for cursor position changes\n- [ ] tracing::debug! for selection changes\n- [ ] tracing::trace! for individual character insertions\n- [ ] tracing::info! for undo/redo operations\n- [ ] tracing::warn! for validation rejections\n\n### Test Coverage\n- [ ] Unit tests for all cursor movement functions\n- [ ] Property tests for undo/redo inverse\n- [ ] Integration test with real terminal input\n- [ ] Snapshot tests for visual output","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:58:07.169424449Z","created_by":"ubuntu","updated_at":"2026-02-01T00:30:56.238151970Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.1","depends_on_id":"bd-10i.5","type":"blocks","created_at":"2026-01-31T23:14:44.057936907Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T23:03:47.305100847Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:03:46.260483541Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:03:46.789771048Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-3ky.5","type":"blocks","created_at":"2026-02-01T00:30:02.594005303Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-3ky.6","type":"blocks","created_at":"2026-02-01T00:30:03.223942290Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-6e9","type":"parent-child","created_at":"2026-01-31T22:58:07.169424449Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-6e9.7","type":"blocks","created_at":"2026-01-31T23:03:47.832993109Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.1","depends_on_id":"bd-6e9.8","type":"blocks","created_at":"2026-01-31T23:03:48.372243948Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":33,"issue_id":"bd-6e9.1","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.2","title":"Implement FilePicker widget","description":"# Implement FilePicker widget (optional)\n\n## Objective\nImplement a file picker widget for selecting files/directories inside a TUI.\n\nThis is a Phase 7 extra and should be feature-gated.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/charmed_rust/crates/bubbles/src/filepicker.rs`\n\n## Scope\n- Browse directories\n- Filter entries (optional)\n- Selection of file or directory (configurable)\n- Basic keybindings:\n  - up/down\n  - enter/open\n  - back/go up\n  - search (optional)\n\n## Integration Notes\n- Must integrate with ftui input/events and rendering model.\n- File I/O should be done via async commands/subscriptions where appropriate.\n\n## Tests Required\n- Unit tests for path navigation logic (pure, no filesystem required using temp dirs or mocked lists).\n- Snapshot tests for rendering a small directory listing.\n\n## Acceptance Criteria\n- [ ] FilePicker can navigate up/down, enter directories, and select an entry.\n- [ ] Rendering is deterministic and handles long filenames (truncate/ellipsis policy).\n- [ ] Tests cover navigation logic and at least one rendering snapshot.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:58:08.315042658Z","created_by":"ubuntu","updated_at":"2026-02-01T00:31:06.341837944Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.2","depends_on_id":"bd-6e9","type":"parent-child","created_at":"2026-01-31T22:58:08.315042658Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":43,"issue_id":"bd-6e9.2","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.3","title":"Implement Help widget (keybinding display)","description":"# Implement Help widget (keybinding display)\n\n## Objective\nImplement a help widget that renders a list of keybindings/commands in a readable, styled format.\n\nPhase 7 extra; should be feature-gated.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/charmed_rust/crates/bubbles/src/help.rs`\n\n## Scope\n- Render a list of entries like: `Key` → `Description`\n- Support grouping/sections (optional)\n- Support truncation/wrapping rules for narrow widths\n\n## Tests Required\n- Snapshot tests for common layouts (1-col, 2-col, narrow width).\n- Unit tests for wrapping/truncation logic.\n\n## Acceptance Criteria\n- [ ] Help widget renders keybinding list deterministically.\n- [ ] Narrow-width behavior is defined and tested (wrap vs truncate).\n- [ ] Snapshot tests cover representative cases.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:58:13.947005157Z","created_by":"ubuntu","updated_at":"2026-02-01T00:31:14.240051430Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.3","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:03:48.873064530Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.3","depends_on_id":"bd-6e9","type":"parent-child","created_at":"2026-01-31T22:58:13.947005157Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.3","depends_on_id":"bd-v6y","type":"blocks","created_at":"2026-01-31T23:03:49.377591719Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":32,"issue_id":"bd-6e9.3","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.4","title":"Implement Paginator widget","description":"# Implement Paginator widget\n\n## Objective\nImplement a paginator widget for displaying current page / total pages, optionally with next/prev affordances.\n\nPhase 7 extra; should be feature-gated.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/charmed_rust/crates/bubbles/src/paginator.rs`\n\n## Scope\n- Display modes:\n  - “Page X/Y”\n  - compact “X/Y”\n  - dots/indicators (optional)\n- Basic state:\n  - current page\n  - total pages\n\n## Tests Required\n- Unit tests for formatting across edge cases (0 pages, 1 page, large counts).\n- Snapshot tests for compact and verbose modes.\n\n## Acceptance Criteria\n- [ ] Paginator renders correct values for current/total.\n- [ ] Formatting rules are deterministic and tested.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:58:19.200289100Z","created_by":"ubuntu","updated_at":"2026-02-01T00:31:23.653637915Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.4","depends_on_id":"bd-10x","type":"blocks","created_at":"2026-01-31T23:03:49.892272907Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.4","depends_on_id":"bd-6e9","type":"parent-child","created_at":"2026-01-31T22:58:19.200289100Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":31,"issue_id":"bd-6e9.4","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.5","title":"Implement Stopwatch widget","description":"# Implement Stopwatch widget\n\n## Objective\nImplement a stopwatch component that can start/stop/reset and display elapsed time.\n\nPhase 7 extra; should be feature-gated.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/charmed_rust/crates/bubbles/src/stopwatch.rs`\n\n## Scope\n- State machine:\n  - start\n  - stop/pause\n  - reset\n  - (optional) lap recording\n- Display formatting:\n  - mm:ss\n  - hh:mm:ss\n  - optional subsecond precision\n- Tick integration via runtime subscriptions.\n\n## Tests Required\n- Unit tests for time accumulation semantics (start/stop/reset).\n- Snapshot tests for formatted display.\n\n## Acceptance Criteria\n- [ ] Stopwatch state machine is correct and tested.\n- [ ] Formatting is deterministic and covers edge cases.\n- [ ] Tick integration does not cause unnecessary renders (rate-limited).","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:58:28.476889405Z","created_by":"ubuntu","updated_at":"2026-02-01T00:31:31.394830608Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.5","depends_on_id":"bd-27v","type":"blocks","created_at":"2026-01-31T23:03:50.432150736Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.5","depends_on_id":"bd-6e9","type":"parent-child","created_at":"2026-01-31T22:58:28.476889405Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":42,"issue_id":"bd-6e9.5","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.6","title":"Implement Timer widget (countdown)","description":"# Implement Timer widget (countdown)\n\n## Objective\nImplement a countdown timer component with start/pause/reset and display formatting.\n\nPhase 7 extra; should be feature-gated.\n\n## Reference (for ideas)\n- `legacy_reference_library_code/charmed_rust/crates/bubbles/src/timer.rs`\n\n## Scope\n- State machine:\n  - set duration\n  - start\n  - pause\n  - reset\n  - finished state\n- Display formatting similar to Stopwatch.\n- Tick integration via runtime subscriptions.\n\n## Tests Required\n- Unit tests for countdown semantics and boundary conditions.\n- Snapshot tests for formatted display.\n\n## Acceptance Criteria\n- [ ] Timer countdown semantics are correct and tested.\n- [ ] Finished state behavior is explicit (stops ticking, emits event/message, etc.).\n- [ ] Rendering is deterministic and formatting rules are tested.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:58:32.951730710Z","created_by":"ubuntu","updated_at":"2026-02-01T00:31:39.205502144Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.6","depends_on_id":"bd-27v","type":"blocks","created_at":"2026-01-31T23:03:50.972298462Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.6","depends_on_id":"bd-6e9","type":"parent-child","created_at":"2026-01-31T22:58:32.951730710Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":41,"issue_id":"bd-6e9.6","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.7","title":"Implement Cursor utilities module","description":"# Implement cursor utilities for text editing widgets\n\n## Objective\nProvide cursor movement and coordinate conversion helpers for text editing widgets (TextInput/TextArea) that are:\n- Unicode-aware (graphemes + display width)\n- deterministic\n- reusable across widgets and editor core\n\n## Reference (for ideas)\n- `legacy_reference_library_code/charmed_rust/crates/bubbles/src/cursor.rs`\n\n## Scope\n- A `CursorPosition` type that tracks:\n  - logical position (line + byte offset, or grapheme index)\n  - visual column (display cell column)\n- Movement helpers:\n  - left/right by grapheme\n  - up/down by line\n  - word-left/word-right (define word boundaries explicitly)\n  - start/end of line\n  - start/end of document (optional)\n- Mapping between:\n  - (row, visual_col) ↔ logical offsets\n\n## Design Notes\n- Do not depend on Buffer/GraphemePool internals; cursor utils operate on text, not rendered cells.\n- Visual column must use the same width rules as the rendering pipeline.\n\n## Tests Required\n- Unit tests covering:\n  - ASCII fast path\n  - combining marks\n  - emoji + ZWJ sequences\n  - tabs (if supported; define tab width)\n  - word boundary behavior\n\n## Acceptance Criteria\n- [ ] Cursor movement is grapheme-aware and never splits graphemes.\n- [ ] Visual column calculations match ftui width rules.\n- [ ] Unit tests cover tricky Unicode and boundary conditions.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:58:40.485978763Z","created_by":"ubuntu","updated_at":"2026-02-01T00:30:43.105501613Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.7","depends_on_id":"bd-6e9","type":"parent-child","created_at":"2026-01-31T22:58:40.485978763Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.7","depends_on_id":"bd-6e9.8","type":"blocks","created_at":"2026-02-01T00:30:33.434635358Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.7","depends_on_id":"bd-v6y","type":"blocks","created_at":"2026-01-31T23:03:51.458176794Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":30,"issue_id":"bd-6e9.7","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-6e9.8","title":"Implement grapheme segmentation helpers for ftui-text","description":"# Implement grapheme segmentation helpers for ftui-text\n\n## Background\nPlan requirements:\n- width correctness for emoji/ZWJ/combining marks is a stop-ship gate\n- ftui-text needs grapheme segmentation helpers for wrapping/truncation/alignment\n\nWe should isolate Unicode segmentation logic behind a small set of helpers so:\n- widgets/text algorithms stay readable\n- we can swap implementation details without touching call sites\n\n## Scope\nProvide utilities built on `unicode-segmentation` + `unicode-width`:\n- grapheme iteration\n- grapheme-aware truncation to display width\n- (optional) word boundaries / soft wrap points\n\nExample APIs (shape, not necessarily final):\n```rust\npub fn grapheme_count(s: &str) -> usize;\npub fn graphemes(s: &str) -> impl Iterator<Item = &str>;\npub fn display_width(s: &str) -> usize; // uses ASCII fast path where applicable (bd-v6y)\n\n/// Returns (prefix, width) where prefix fits within max_width.\npub fn truncate_to_width(s: &str, max_width: usize) -> (&str, usize);\n```\n\n## Non-goals\n- Full Unicode normalization/bidi/search subsystems (out of scope for plan v1)\n\n## Tests\n- Grapheme iteration matches expectations on:\n  - ASCII\n  - combining marks\n  - emoji + ZWJ sequences\n- truncate_to_width never splits mid-grapheme\n\n## Acceptance Criteria\n- [ ] Helpers exist and are used by Text wrapping/truncation code.\n- [ ] Unicode width corpus tests (bd-16k) can exercise these helpers.","acceptance_criteria":"## Acceptance Criteria\n\n### Functional Requirements\n- [ ] grapheme_count: Count grapheme clusters in string\n- [ ] grapheme_at: Get grapheme at index (0-based)\n- [ ] grapheme_slice: Extract grapheme range\n- [ ] word_boundaries: Iterator over word break positions\n- [ ] is_word_char: Classify grapheme as word character\n- [ ] display_width: Calculate display width in cells\n- [ ] truncate_to_width: Truncate to max display width\n\n### Unicode Requirements\n- [ ] ZWJ sequences treated as single grapheme (👨‍👩‍👧 = 1)\n- [ ] Combining marks attached to base (e + ́ = 1)\n- [ ] Emoji with skin tone = 1 grapheme\n- [ ] Regional indicators paired correctly (🇺🇸 = 1)\n- [ ] Word boundaries per UAX #29\n- [ ] Width per UAX #11 (East Asian Width)\n\n### Performance Requirements\n- [ ] grapheme_count: O(n) with < 10ns/grapheme\n- [ ] display_width: O(n) with width cache hits\n- [ ] truncate_to_width: O(n) worst case, O(log n) with cache\n\n### Caching Requirements\n- [ ] Width cache for common graphemes\n- [ ] LRU eviction for cache management\n- [ ] Cache hit rate > 90% for typical text\n\n### Logging Requirements\n- [ ] tracing::trace! for cache misses (debug builds)\n- [ ] tracing::debug! for unusual grapheme clusters\n- [ ] tracing::warn! for width lookup failures\n\n### Test Coverage\n- [ ] Corpus test: all Unicode grapheme break tests\n- [ ] Corpus test: East Asian Width edge cases\n- [ ] Property test: truncate never exceeds width\n- [ ] Property test: grapheme count >= 0\n- [ ] Benchmark: ASCII fast path performance","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:58:45.504414906Z","created_by":"ubuntu","updated_at":"2026-01-31T23:28:04.803939453Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.8","depends_on_id":"bd-10i.6","type":"parent-child","created_at":"2026-01-31T23:22:42.515214108Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.8","depends_on_id":"bd-16k","type":"blocks","created_at":"2026-01-31T23:28:04.803899969Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.8","depends_on_id":"bd-v6y","type":"blocks","created_at":"2026-01-31T23:27:57.730831268Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-6e9.9","title":"Bubbles Widget Test Suite","description":"Comprehensive test suite for all bubbles widgets. This ensures every widget is thoroughly tested with unit tests, property tests, integration tests, and e2e scenarios.\n\n## Testing Philosophy\nEvery widget must be tested at multiple levels:\n1. **Unit tests** - Individual method correctness\n2. **Property tests** - Invariant verification with random inputs\n3. **Integration tests** - Widget composition and interaction\n4. **E2E tests** - Full user workflow simulation\n5. **Snapshot tests** - Visual regression detection\n\n## Test Requirements by Widget\n\n### TextArea (bd-6e9.1)\nUnit tests:\n- `test_insert_single_char` - Insert at various cursor positions\n- `test_insert_multiline` - Insert text containing newlines\n- `test_delete_backward` - Backspace at line start joins lines\n- `test_delete_forward` - Delete at line end joins lines\n- `test_cursor_movement_horizontal` - Left/right wraps at line boundaries\n- `test_cursor_movement_vertical` - Up/down maintains visual column\n- `test_selection_shift_arrow` - Selection with shift+arrows\n- `test_selection_word` - Double-click word selection\n- `test_selection_line` - Triple-click line selection\n- `test_undo_single_char` - Undo groups by word boundaries\n- `test_undo_paste` - Paste is single undo unit\n- `test_redo_after_edit` - Redo branch is discarded on new edit\n- `test_word_wrap_soft` - Soft wrap doesn't modify buffer\n- `test_word_wrap_hard` - Hard wrap inserts actual newlines\n- `test_viewport_scroll_cursor_follow` - Viewport follows cursor\n- `test_unicode_grapheme_cluster` - ZWJ sequences treated as single char\n- `test_char_limit_enforcement` - Can't exceed limit\n- `test_validation_callback` - Validation prevents invalid input\n\nProperty tests:\n- `prop_insert_delete_inverse` - Insert then delete restores state\n- `prop_undo_redo_inverse` - Undo then redo restores state\n- `prop_cursor_always_valid` - Cursor never outside buffer bounds\n- `prop_selection_ordered` - Selection start <= end\n\nIntegration tests:\n- `test_textarea_in_form` - TextArea with other form widgets\n- `test_textarea_focus_blur` - Focus/blur event handling\n- `test_textarea_bracketed_paste` - Large paste via bracketed paste\n\nE2E tests:\n- `e2e_edit_document` - Open, edit, save workflow\n- `e2e_search_replace` - Find and replace across document\n\n### Help Widget (bd-6e9.3)\nUnit tests:\n- `test_single_binding_render` - Key + description formatting\n- `test_multiple_bindings_horizontal` - Separator between bindings\n- `test_binding_truncation` - Ellipsis when exceeds width\n- `test_grouped_bindings` - Group headers and sections\n- `test_full_help_toggle` - Short vs full help modes\n\n### Paginator (bd-6e9.4)\nUnit tests:\n- `test_dot_pagination_render` - Correct dots for each page\n- `test_numeric_pagination` - 'N/M' format\n- `test_range_pagination_ellipsis` - '1 2 3 ... 10' format\n- `test_page_navigation_bounds` - Can't go below 0 or above max\n- `test_items_on_page_calculation` - Correct item ranges\n\nProperty tests:\n- `prop_page_always_valid` - Page number always in valid range\n\n### Cursor Utilities (bd-6e9.7)\nUnit tests:\n- `test_visual_column_tabs` - Tab width affects visual column\n- `test_visual_column_wide_chars` - CJK chars are 2 columns\n- `test_move_word_left` - Stops at word boundaries\n- `test_move_word_right` - Skips punctuation correctly\n- `test_byte_to_char_offset` - Correct conversion for UTF-8\n\nProperty tests:\n- `prop_byte_char_roundtrip` - byte->char->byte is identity\n- `prop_visual_always_positive` - Visual column >= 0\n\n### runeutil (bd-6e9.8)\nUnit tests:\n- `test_grapheme_count_ascii` - ASCII string length\n- `test_grapheme_count_emoji` - ZWJ family is 1 grapheme\n- `test_grapheme_slice` - Correct slicing at grapheme boundaries\n- `test_word_boundary_english` - Word splits on spaces/punctuation\n- `test_word_boundary_cjk` - CJK characters are word boundaries\n- `test_display_width_ascii` - ASCII is 1 cell per char\n- `test_display_width_cjk` - CJK is 2 cells per char\n- `test_truncate_to_width` - Truncates at grapheme boundaries\n\nProperty tests:\n- `prop_truncate_never_exceeds` - Result width <= max_width\n- `prop_grapheme_count_non_negative` - Count >= 0\n\n## Logging Requirements\nAll tests must use structured logging with:\n- `tracing::debug!` for test setup/teardown\n- `tracing::info!` for key assertions\n- `tracing::warn!` for unexpected but non-fatal conditions\n- Test failures dump full state snapshot to logs\n\n## Coverage Targets\n- Line coverage: >= 90%\n- Branch coverage: >= 85%\n- Mutation testing survival: <= 20%\n\n## Test Harness\nUse `ftui-test` harness that provides:\n- Deterministic time (frozen or controlled advancement)\n- Mock terminal capabilities\n- Input simulation API\n- Output capture and assertion\n\nDependencies: All bubbles widgets, Testing infrastructure (bd-10i.11)\n\n\n## Acceptance Criteria\n- [ ] Snapshot tests cover each bubbles widget’s core render behavior.\n- [ ] Interaction/unit tests cover state machines (timer/stopwatch/text editing).\n- [ ] Tests are deterministic and failure output is actionable.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T23:15:20.100943766Z","created_by":"ubuntu","updated_at":"2026-02-01T00:31:45.272685410Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-6e9.9","depends_on_id":"bd-10i.11","type":"blocks","created_at":"2026-01-31T23:18:01.603690945Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.9","depends_on_id":"bd-6e9.1","type":"blocks","created_at":"2026-01-31T23:18:04.060257239Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.9","depends_on_id":"bd-6e9.3","type":"blocks","created_at":"2026-01-31T23:18:04.692052140Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.9","depends_on_id":"bd-6e9.4","type":"blocks","created_at":"2026-01-31T23:18:05.281609862Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.9","depends_on_id":"bd-6e9.7","type":"blocks","created_at":"2026-01-31T23:18:05.881517041Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-6e9.9","depends_on_id":"bd-6e9.8","type":"blocks","created_at":"2026-01-31T23:18:06.483627147Z","created_by":"ubuntu","metadata":"{}","thread_id":""}],"comments":[{"id":7,"issue_id":"bd-6e9.9","author":"ubuntu","text":"Reopened: User requested reopening; reverting prior closure.","created_at":"2026-01-31T23:34:20Z"}]}
{"id":"bd-7u8","title":"Implement cursor save/restore strategy (DEC vs ANSI vs emulated)","description":"# Implement Cursor Save/Restore Strategy\n\n## Background\nPlan Section 9.3 describes a critical cursor save/restore strategy for inline mode robustness. Terminals differ in which save/restore sequences they support reliably.\n\n## Problem Statement\nInline mode requires saving cursor position before drawing UI and restoring after. However:\n- DEC save/restore (\\`ESC 7\\` / \\`ESC 8\\`) is preferred but not universal\n- ANSI save/restore (\\`CSI s\\` / \\`CSI u\\`) is an alternative\n- Some terminals/muxes have quirks with either\n- Must handle failures gracefully\n\n## Layered Strategy (from Plan)\n\n### Layer 1: DEC Save/Restore (Preferred)\n\\`\\`\\`rust\nconst DEC_SAVE: &[u8] = b\"\\x1b7\";    // ESC 7 (DECSC)\nconst DEC_RESTORE: &[u8] = b\"\\x1b8\"; // ESC 8 (DECRC)\n\\`\\`\\`\n- Most widely supported on modern terminals\n- Saves more state (cursor position, attributes, charset)\n- Works in tmux/screen with passthrough\n\n### Layer 2: ANSI Save/Restore (Fallback)\n\\`\\`\\`rust\nconst ANSI_SAVE: &[u8] = b\"\\x1b[s\";    // CSI s\nconst ANSI_RESTORE: &[u8] = b\"\\x1b[u\"; // CSI u\n\\`\\`\\`\n- Less widely supported\n- Only saves cursor position (not attributes)\n- May conflict with some terminal modes\n\n### Layer 3: Emulated (Last Resort)\n\\`\\`\\`rust\n// Track cursor position explicitly\nstruct CursorTracker {\n    x: u16,\n    y: u16,\n}\n\nimpl CursorTracker {\n    fn save(&mut self, current_x: u16, current_y: u16) {\n        self.x = current_x;\n        self.y = current_y;\n    }\n    \n    fn restore(&self, writer: &mut impl Write) -> io::Result<()> {\n        write!(writer, \"\\x1b[{};{}H\", self.y + 1, self.x + 1)\n    }\n}\n\\`\\`\\`\n- Works everywhere that supports CUP\n- Requires tracking cursor position throughout\n- More overhead but guaranteed to work\n\n## Strategy Selection\n\\`\\`\\`rust\npub enum CursorSaveStrategy {\n    Dec,       // ESC 7 / ESC 8\n    Ansi,      // CSI s / CSI u\n    Emulated,  // Track and CUP\n    Auto,      // Detect best for environment\n}\n\nimpl CursorSaveStrategy {\n    pub fn detect(caps: &TerminalCapabilities) -> Self {\n        // Most terminals support DEC\n        if !caps.in_screen {\n            return Self::Dec;\n        }\n        // Screen has quirks, try ANSI\n        Self::Ansi\n    }\n}\n\\`\\`\\`\n\n## Implementation\n\\`\\`\\`rust\npub struct CursorManager {\n    strategy: CursorSaveStrategy,\n    saved_position: Option<(u16, u16)>,  // For emulated mode\n}\n\nimpl CursorManager {\n    pub fn save(&mut self, writer: &mut impl Write, current_pos: (u16, u16)) -> io::Result<()> {\n        match self.strategy {\n            CursorSaveStrategy::Dec => writer.write_all(DEC_SAVE),\n            CursorSaveStrategy::Ansi => writer.write_all(ANSI_SAVE),\n            CursorSaveStrategy::Emulated => {\n                self.saved_position = Some(current_pos);\n                Ok(())\n            }\n            CursorSaveStrategy::Auto => {\n                // Try DEC, it's most common\n                writer.write_all(DEC_SAVE)\n            }\n        }\n    }\n    \n    pub fn restore(&mut self, writer: &mut impl Write) -> io::Result<()> {\n        match self.strategy {\n            CursorSaveStrategy::Dec => writer.write_all(DEC_RESTORE),\n            CursorSaveStrategy::Ansi => writer.write_all(ANSI_RESTORE),\n            CursorSaveStrategy::Emulated => {\n                if let Some((x, y)) = self.saved_position {\n                    write!(writer, \"\\x1b[{};{}H\", y + 1, x + 1)?;\n                }\n                Ok(())\n            }\n            CursorSaveStrategy::Auto => writer.write_all(DEC_RESTORE),\n        }\n    }\n}\n\\`\\`\\`\n\n## PTY Test: Cursor Restoration\nTest that verifies cursor is correctly restored:\n1. Move cursor to known position\n2. Save cursor\n3. Move cursor elsewhere\n4. Restore cursor\n5. Query position (DSR) and verify matches saved position\n\n## Tests Required\n- [ ] DEC save/restore works on xterm-like terminals\n- [ ] ANSI save/restore works as fallback\n- [ ] Emulated mode tracks and restores correctly\n- [ ] Auto-detection chooses appropriate strategy\n- [ ] PTY test verifies cursor contract per strategy\n\n## Acceptance Criteria\n- [ ] CursorManager implemented with all three strategies\n- [ ] Auto-detection based on TerminalCapabilities\n- [ ] Integrated into InlinePresenter\n- [ ] PTY tests pass for all strategies\n- [ ] Documented which terminals use which strategy\n\n## Location\n\\`ftui-core/src/cursor.rs\\`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:18:52.006565139Z","created_by":"ubuntu","updated_at":"2026-01-31T23:18:59.328003692Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-7u8","depends_on_id":"bd-10i.2.5","type":"blocks","created_at":"2026-01-31T23:18:59.327962044Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-cw8","title":"Implement Markdown renderer","description":"PHASE 7 EXTRAS - MARKDOWN RENDERER\n\n## Background\nMarkdown rendering is essential for agent harness UIs that display documentation, help text, and AI-generated content.\n\n## Technical Requirements\n\n### Supported Markdown Elements\n- Headers (h1-h6) with styled text\n- Bold, italic, strikethrough, code\n- Links (rendered as OSC 8 hyperlinks if supported)\n- Code blocks with syntax highlighting (optional)\n- Lists (ordered and unordered)\n- Blockquotes\n- Horizontal rules\n- Tables (basic)\n\n### Parser Choice\n- Use pulldown-cmark for parsing (battle-tested)\n- Convert events to ftui Text/Spans\n\n### Renderer Structure\n\npub struct MarkdownRenderer {\n    theme: MarkdownTheme,\n    code_theme: Option<SyntaxTheme>,\n    link_style: Style,\n    max_width: Option<u16>,\n}\n\npub struct MarkdownTheme {\n    h1: Style,\n    h2: Style,\n    h3: Style,\n    // ...\n    code_inline: Style,\n    code_block: Style,\n    blockquote: Style,\n    link: Style,\n}\n\nimpl MarkdownRenderer {\n    pub fn render(&self, markdown: &str) -> Text {\n        // Parse markdown\n        // Convert to styled spans\n        // Handle line breaks and wrapping\n    }\n    \n    pub fn render_to_buffer(&self, markdown: &str, area: Rect, buf: &mut Buffer) {\n        // Render directly to buffer with area constraints\n    }\n}\n\n### Widget Integration\n\npub struct Markdown<'a> {\n    content: &'a str,\n    renderer: MarkdownRenderer,\n}\n\nimpl Widget for Markdown<'_> {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        self.renderer.render_to_buffer(self.content, area, buf);\n    }\n}\n\n### Syntax Highlighting Integration\nOptional feature: syntax-highlight\n\n#[cfg(feature = \"syntax-highlight\")]\npub fn highlight_code_block(code: &str, language: &str) -> Text {\n    // Use syntect or tree-sitter\n}\n\n## Tests Required\n- [ ] Headers render with correct styles\n- [ ] Bold/italic/code inline\n- [ ] Links extracted and styled\n- [ ] Code blocks rendered\n- [ ] Lists with bullets/numbers\n- [ ] Nested lists\n- [ ] Tables basic rendering\n- [ ] Long content wraps correctly\n\n## Acceptance Criteria\n- [ ] All common Markdown elements\n- [ ] Themeable rendering\n- [ ] OSC 8 links (when supported)\n- [ ] Optional syntax highlighting\n- [ ] Feature gate: markdown\n\n## Location: ftui-extras crate (feature = \"markdown\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:38:39.511264647Z","created_by":"ubuntu","updated_at":"2026-01-31T22:39:21.703572700Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-cw8","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:39:21.703540850Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-e211","title":"Implement Text wrapping and truncation with ZWJ/emoji/combining mark correctness","description":"# Implement Text Wrapping and Truncation with Width Correctness\n\n## Background\nPlan Section F and Chapter 11 emphasize that text wrapping and truncation must be WIDTH-CORRECT for ZWJ sequences, emoji, and combining marks. This is a non-negotiable for Unicode correctness.\n\n## Problem Statement\nBreaking text at arbitrary byte or codepoint boundaries corrupts display:\n- ZWJ sequences (👨‍👩‍👧) are single graphemes but multiple codepoints\n- Combining marks (é = e + ́) must stay with base char\n- Regional indicators (🇺🇸) are pairs of codepoints\n- CJK characters are 2 cells wide\n\n## Requirements\n\n### Wrapping Rules\n1. Never break inside a grapheme cluster\n2. Respect cell width (CJK = 2 cells)\n3. Handle ZWJ sequences as atomic units\n4. Word-wrap at whitespace when possible\n5. Character-wrap as fallback for long words\n\n### Truncation Rules\n1. Truncate at grapheme boundary only\n2. Ellipsis (…) counts as 1 cell\n3. If content + ellipsis > width, drop graphemes until it fits\n4. Never leave partial grapheme displayed\n\n## Implementation\n\n### Text Wrapping\n```rust\npub fn wrap_text(text: &str, width: usize) -> Vec<String> {\n    let mut lines = Vec::new();\n    let mut current_line = String::new();\n    let mut current_width = 0;\n    \n    for grapheme in text.graphemes(true) {\n        let grapheme_width = unicode_width::UnicodeWidthStr::width(grapheme);\n        \n        if current_width + grapheme_width > width {\n            // Line full, start new line\n            if !current_line.is_empty() {\n                lines.push(std::mem::take(&mut current_line));\n            }\n            current_width = 0;\n        }\n        \n        current_line.push_str(grapheme);\n        current_width += grapheme_width;\n    }\n    \n    if !current_line.is_empty() {\n        lines.push(current_line);\n    }\n    \n    lines\n}\n```\n\n### Text Truncation\n```rust\npub fn truncate_text(text: &str, max_width: usize, ellipsis: &str) -> String {\n    let text_width = unicode_width::UnicodeWidthStr::width(text);\n    \n    if text_width <= max_width {\n        return text.to_string();\n    }\n    \n    let ellipsis_width = unicode_width::UnicodeWidthStr::width(ellipsis);\n    let target_width = max_width.saturating_sub(ellipsis_width);\n    \n    let mut result = String::new();\n    let mut current_width = 0;\n    \n    for grapheme in text.graphemes(true) {\n        let grapheme_width = unicode_width::UnicodeWidthStr::width(grapheme);\n        \n        if current_width + grapheme_width > target_width {\n            break;\n        }\n        \n        result.push_str(grapheme);\n        current_width += grapheme_width;\n    }\n    \n    result.push_str(ellipsis);\n    result\n}\n```\n\n## Test Cases Required\n\n### Wrapping Tests\n- [ ] ASCII text wraps at word boundaries\n- [ ] CJK text wraps correctly (each char = 2 cells)\n- [ ] Emoji never split mid-sequence\n- [ ] ZWJ family emoji (👨‍👩‍👧‍👦) wrap as unit\n- [ ] Combining marks stay with base (é)\n- [ ] Regional indicators (🇺🇸) wrap as pair\n- [ ] Long words wrap mid-word correctly\n- [ ] Empty lines preserved\n\n### Truncation Tests\n- [ ] Short text unchanged\n- [ ] Long ASCII truncated with ellipsis\n- [ ] CJK truncated at grapheme boundary\n- [ ] Emoji truncated correctly\n- [ ] ZWJ sequence truncated as unit\n- [ ] Ellipsis fits within width\n- [ ] Edge case: width < ellipsis width\n\n### Comprehensive Corpus (from bd-16k)\n- [ ] All ASCII printable characters\n- [ ] Common CJK (日本語, 中文, 한국어)\n- [ ] Common emoji (🎉, ❤️, 🔥, 😀)\n- [ ] ZWJ sequences (👨‍💻, 👩‍🔬, 🏳️‍🌈)\n- [ ] Skin tone modifiers (👋🏻, 👋🏿)\n- [ ] Combining diacritics (é, ñ, ü)\n- [ ] Variation selectors\n- [ ] Zero-width characters (ZWSP, ZWNJ)\n\n## Dependencies\n- Uses unicode-segmentation crate for graphemes()\n- Uses unicode-width crate for width measurement\n- Integrates with LRU width cache (bd-1oz)\n\n## Acceptance Criteria\n- [ ] wrap_text() is grapheme-correct\n- [ ] truncate_text() is grapheme-correct\n- [ ] All test cases pass\n- [ ] Integrated into Text type (bd-2uk)\n- [ ] Performance: < 10µs for typical text (cached)\n\n## Location\n`ftui-text/src/wrap.rs`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T23:20:21.625908161Z","created_by":"ubuntu","updated_at":"2026-01-31T23:27:59.159987979Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-e211","depends_on_id":"bd-1oz","type":"blocks","created_at":"2026-01-31T23:20:27.585419330Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-e211","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:27:59.159939288Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-fbp","title":"Implement inline mode overlay redraw baseline","description":"PHASE 2.5 - INLINE MODE IMPLEMENTATION (CRITICAL)\n\n## Background\nInline mode is a NON-NEGOTIABLE requirement. The overlay redraw baseline is the correctness foundation that works everywhere, before optimization.\n\n## Technical Requirements (from Plan Section D)\n\n### Overlay Redraw Strategy\n1. Save cursor position (DECSC or manual tracking)\n2. Move cursor to UI region start\n3. Clear UI region only (never full screen!)\n4. Render UI frame\n5. Restore cursor position (DECRC)\n\n### UI Region Anchoring\n- Bottom-anchored (default): UI at bottom, logs scroll above\n- Top-anchored (optional): UI at top, logs scroll below\n- Configurable height: ui_height parameter\n\n### Log Write Coordination\nwrite_log() must:\n1. Suspend UI temporarily\n2. Print log line to scrollback region\n3. Re-render UI in its anchored position\n4. Maintain cursor contract\n\n### Cursor Contract\nAfter any present():\n- Cursor is at the correct position per active policy\n- UI region is intact\n- Scrollback is preserved\n\n### Never Clear Full Screen\nThe DECRC/ED2 pattern that clears full screen is FORBIDDEN in inline mode.\nOnly clear the bounded UI region using EL (erase line) or localized ED.\n\n## Implementation\n\npub struct InlinePresenter {\n    ui_height: u16,\n    anchor: Anchor,  // Bottom or Top\n    cursor_saved: bool,\n}\n\nimpl InlinePresenter {\n    pub fn present(&mut self, buffer: &Buffer, writer: &mut TerminalWriter) {\n        // 1. Save cursor\n        writer.write_all(b\"\\x1b7\")?;  // DECSC\n        \n        // 2. Move to UI region\n        let (_, term_height) = writer.size();\n        let ui_start = match self.anchor {\n            Anchor::Bottom => term_height - self.ui_height,\n            Anchor::Top => 0,\n        };\n        writer.move_to(0, ui_start)?;\n        \n        // 3. Clear UI region only (line by line)\n        for row in 0..self.ui_height {\n            writer.write_all(b\"\\x1b[2K\")?;  // EL - clear line\n            if row < self.ui_height - 1 {\n                writer.write_all(b\"\\n\")?;\n            }\n        }\n        \n        // 4. Move back and render\n        writer.move_to(0, ui_start)?;\n        // ... emit diff ...\n        \n        // 5. Restore cursor\n        writer.write_all(b\"\\x1b8\")?;  // DECRC\n    }\n}\n\n## Tests Required\n- [ ] UI renders at correct position (bottom/top)\n- [ ] Scrollback is preserved after present()\n- [ ] Cursor returns to correct position\n- [ ] Log writes don't corrupt UI\n- [ ] Resize re-anchors correctly\n- [ ] PTY test: verify no scrollback corruption\n\n## Acceptance Criteria\n- [ ] Overlay redraw works on all terminals\n- [ ] Cursor contract maintained\n- [ ] UI region bounded, never full-screen clear\n- [ ] Log coordination implemented\n- [ ] PTY tests pass\n\n## Performance Budget\n- Overlay redraw: < 2ms (acceptable for correctness baseline)\n\n## Location: ftui-render crate","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-31T22:30:23.970211625Z","created_by":"ubuntu","updated_at":"2026-01-31T23:18:59.949872182Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-fbp","depends_on_id":"bd-10i.10.1","type":"blocks","created_at":"2026-01-31T22:32:18.333877686Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-fbp","depends_on_id":"bd-10i.4.3","type":"blocks","created_at":"2026-01-31T22:32:18.052629717Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-fbp","depends_on_id":"bd-7u8","type":"blocks","created_at":"2026-01-31T23:18:59.949835924Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-gpe","title":"Implement TextInput widget (agent harness essential)","description":"# Implement TextInput Widget (Agent Harness Essential)\n\n## Background & Strategic Importance\nTextInput is explicitly called out in the plan (Section 12.4) as an \"agent harness essential\" widget. It provides single-line text input for command prompts, search boxes, and user input fields. This is critical for Claude Code / Codex-style agent harness UIs where users need to type commands and queries.\n\n## Why Elevated Priority (P1)\nThe plan states under \"H) Widgets (v1 essentials)\":\n- \"Text input / prompt line\" is a REQUIRED widget for v1\n- Agent harnesses need a way for users to type input\n- This is part of the \"minimum harness primitives\" contract\n- Without TextInput, the Agent Harness reference app (bd-2kj) cannot be built\n\n---\n\n## Technical Design\n\n### Core Data Structure\n\n```rust\nuse tracing::{debug, trace, instrument};\nuse unicode_segmentation::UnicodeSegmentation;\n\n/// Single-line text input widget with cursor, selection, and editing operations.\n///\n/// # Design Rationale\n/// - String storage is UTF-8 with byte-offset cursor (standard Rust)\n/// - All cursor operations are grapheme-cluster aware (not byte or char)\n/// - Selection uses Option<anchor> pattern for shift+arrow selection\n/// - Blink state is external (runtime tick) for consistency\npub struct TextInput {\n    /// Current text content (UTF-8)\n    value: String,\n    /// Cursor position as grapheme index (not byte offset!)\n    cursor: usize,\n    /// Selection anchor as grapheme index, None if no selection\n    selection_anchor: Option<usize>,\n    /// Placeholder text shown when empty\n    placeholder: Option<String>,\n    /// Password mode - mask characters\n    masked: bool,\n    /// Mask character for password mode (default: '•')\n    mask_char: char,\n    /// Horizontal scroll offset (grapheme index) for long text\n    scroll_offset: usize,\n    /// Maximum length in graphemes (None = unlimited)\n    max_length: Option<usize>,\n    /// Style for text\n    style: Style,\n    /// Style for cursor (typically reverse video)\n    cursor_style: Style,\n    /// Style for placeholder\n    placeholder_style: Style,\n    /// Style for selection highlight\n    selection_style: Style,\n}\n\n/// State tracking for stateful widget pattern\npub struct TextInputState {\n    /// Whether cursor is currently visible (blink state)\n    cursor_visible: bool,\n    /// Whether input is focused\n    focused: bool,\n}\n```\n\n### Public API\n\n```rust\nimpl TextInput {\n    /// Create empty text input.\n    pub fn new() -> Self {\n        debug!(\"Creating TextInput\");\n        Self {\n            value: String::new(),\n            cursor: 0,\n            selection_anchor: None,\n            placeholder: None,\n            masked: false,\n            mask_char: '•',\n            scroll_offset: 0,\n            max_length: None,\n            style: Style::default(),\n            cursor_style: Style::default().add_modifier(Modifier::REVERSED),\n            placeholder_style: Style::default().fg(Color::DarkGray),\n            selection_style: Style::default().bg(Color::Blue),\n        }\n    }\n\n    // --- Value access ---\n\n    /// Get current value.\n    pub fn value(&self) -> &str { &self.value }\n\n    /// Set value, clamping cursor to valid position.\n    pub fn set_value(&mut self, value: impl Into<String>) {\n        self.value = value.into();\n        let max = self.grapheme_count();\n        self.cursor = self.cursor.min(max);\n        self.selection_anchor = None;\n        debug!(len = self.value.len(), cursor = self.cursor, \"Value set\");\n    }\n\n    // --- Builder methods ---\n\n    pub fn placeholder(mut self, text: impl Into<String>) -> Self {\n        self.placeholder = Some(text.into());\n        self\n    }\n\n    pub fn masked(mut self) -> Self {\n        self.masked = true;\n        self\n    }\n\n    pub fn mask_char(mut self, c: char) -> Self {\n        self.mask_char = c;\n        self\n    }\n\n    pub fn max_length(mut self, len: usize) -> Self {\n        self.max_length = Some(len);\n        self\n    }\n\n    // --- Cursor movement ---\n\n    /// Move cursor left one grapheme cluster.\n    #[instrument(skip(self), fields(cursor = self.cursor))]\n    pub fn move_cursor_left(&mut self) {\n        if self.cursor > 0 {\n            self.cursor -= 1;\n            self.selection_anchor = None;\n            trace!(new_cursor = self.cursor, \"Cursor left\");\n        }\n    }\n\n    /// Move cursor right one grapheme cluster.\n    pub fn move_cursor_right(&mut self) {\n        let max = self.grapheme_count();\n        if self.cursor < max {\n            self.cursor += 1;\n            self.selection_anchor = None;\n            trace!(new_cursor = self.cursor, \"Cursor right\");\n        }\n    }\n\n    /// Move cursor to start of line.\n    pub fn move_cursor_start(&mut self) {\n        self.cursor = 0;\n        self.selection_anchor = None;\n        debug!(\"Cursor to start\");\n    }\n\n    /// Move cursor to end of line.\n    pub fn move_cursor_end(&mut self) {\n        self.cursor = self.grapheme_count();\n        self.selection_anchor = None;\n        debug!(\"Cursor to end\");\n    }\n\n    /// Move cursor left one word (word = sequence of alphanumeric).\n    pub fn move_cursor_word_left(&mut self) {\n        // Skip any whitespace, then skip to start of word\n        let graphemes: Vec<&str> = self.value.graphemes(true).collect();\n        let mut pos = self.cursor;\n\n        // Skip trailing whitespace\n        while pos > 0 && graphemes.get(pos - 1).map_or(false, |g| g.chars().all(char::is_whitespace)) {\n            pos -= 1;\n        }\n        // Skip word characters\n        while pos > 0 && graphemes.get(pos - 1).map_or(false, |g| g.chars().any(char::is_alphanumeric)) {\n            pos -= 1;\n        }\n\n        self.cursor = pos;\n        self.selection_anchor = None;\n        trace!(new_cursor = self.cursor, \"Cursor word left\");\n    }\n\n    /// Move cursor right one word.\n    pub fn move_cursor_word_right(&mut self) {\n        let graphemes: Vec<&str> = self.value.graphemes(true).collect();\n        let max = graphemes.len();\n        let mut pos = self.cursor;\n\n        // Skip current word\n        while pos < max && graphemes.get(pos).map_or(false, |g| g.chars().any(char::is_alphanumeric)) {\n            pos += 1;\n        }\n        // Skip whitespace\n        while pos < max && graphemes.get(pos).map_or(false, |g| g.chars().all(char::is_whitespace)) {\n            pos += 1;\n        }\n\n        self.cursor = pos;\n        self.selection_anchor = None;\n        trace!(new_cursor = self.cursor, \"Cursor word right\");\n    }\n\n    // --- Editing operations ---\n\n    /// Insert character at cursor position.\n    #[instrument(skip(self), fields(cursor = self.cursor, char = %c))]\n    pub fn insert_char(&mut self, c: char) {\n        // Check max length\n        if let Some(max) = self.max_length {\n            if self.grapheme_count() >= max {\n                trace!(\"Insert blocked: max_length reached\");\n                return;\n            }\n        }\n\n        // Delete selection first if any\n        self.delete_selection();\n\n        // Find byte offset for cursor grapheme position\n        let byte_offset = self.cursor_byte_offset();\n        self.value.insert(byte_offset, c);\n        self.cursor += 1;\n        trace!(new_cursor = self.cursor, \"Inserted char\");\n    }\n\n    /// Delete character before cursor (backspace).\n    pub fn delete_char_before(&mut self) {\n        if self.selection_anchor.is_some() {\n            self.delete_selection();\n            return;\n        }\n\n        if self.cursor > 0 {\n            let byte_start = self.grapheme_byte_offset(self.cursor - 1);\n            let byte_end = self.grapheme_byte_offset(self.cursor);\n            self.value.drain(byte_start..byte_end);\n            self.cursor -= 1;\n            trace!(cursor = self.cursor, \"Deleted char before\");\n        }\n    }\n\n    /// Delete character after cursor (delete key).\n    pub fn delete_char_after(&mut self) {\n        if self.selection_anchor.is_some() {\n            self.delete_selection();\n            return;\n        }\n\n        let max = self.grapheme_count();\n        if self.cursor < max {\n            let byte_start = self.cursor_byte_offset();\n            let byte_end = self.grapheme_byte_offset(self.cursor + 1);\n            self.value.drain(byte_start..byte_end);\n            trace!(cursor = self.cursor, \"Deleted char after\");\n        }\n    }\n\n    /// Delete word before cursor (Ctrl+Backspace).\n    pub fn delete_word_before(&mut self) {\n        let old_cursor = self.cursor;\n        self.move_cursor_word_left();\n        let new_cursor = self.cursor;\n\n        if new_cursor < old_cursor {\n            let byte_start = self.grapheme_byte_offset(new_cursor);\n            let byte_end = self.grapheme_byte_offset(old_cursor);\n            self.value.drain(byte_start..byte_end);\n            debug!(deleted = old_cursor - new_cursor, \"Deleted word before\");\n        }\n    }\n\n    /// Clear all text.\n    pub fn clear(&mut self) {\n        self.value.clear();\n        self.cursor = 0;\n        self.selection_anchor = None;\n        debug!(\"Cleared\");\n    }\n\n    // --- Selection operations ---\n\n    /// Select all text.\n    pub fn select_all(&mut self) {\n        self.selection_anchor = Some(0);\n        self.cursor = self.grapheme_count();\n        debug!(\"Selected all\");\n    }\n\n    /// Get selected text, if any.\n    pub fn selected_text(&self) -> Option<&str> {\n        self.selection_anchor.map(|anchor| {\n            let (start, end) = self.selection_range(anchor);\n            let byte_start = self.grapheme_byte_offset(start);\n            let byte_end = self.grapheme_byte_offset(end);\n            &self.value[byte_start..byte_end]\n        })\n    }\n\n    /// Delete selected text.\n    pub fn delete_selection(&mut self) {\n        if let Some(anchor) = self.selection_anchor.take() {\n            let (start, end) = self.selection_range(anchor);\n            let byte_start = self.grapheme_byte_offset(start);\n            let byte_end = self.grapheme_byte_offset(end);\n            self.value.drain(byte_start..byte_end);\n            self.cursor = start;\n            debug!(start, end, \"Deleted selection\");\n        }\n    }\n\n    // --- Helper methods ---\n\n    fn grapheme_count(&self) -> usize {\n        self.value.graphemes(true).count()\n    }\n\n    fn cursor_byte_offset(&self) -> usize {\n        self.grapheme_byte_offset(self.cursor)\n    }\n\n    fn grapheme_byte_offset(&self, grapheme_idx: usize) -> usize {\n        self.value.grapheme_indices(true)\n            .nth(grapheme_idx)\n            .map(|(i, _)| i)\n            .unwrap_or(self.value.len())\n    }\n\n    fn selection_range(&self, anchor: usize) -> (usize, usize) {\n        if anchor <= self.cursor {\n            (anchor, self.cursor)\n        } else {\n            (self.cursor, anchor)\n        }\n    }\n}\n```\n\n### Rendering Implementation\n\n```rust\nimpl StatefulWidget for TextInput {\n    type State = TextInputState;\n\n    #[instrument(skip(self, area, buf, state), fields(\n        value_len = self.value.len(),\n        cursor = self.cursor,\n        has_selection = self.selection_anchor.is_some()\n    ))]\n    fn render(&self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        if area.width == 0 || area.height == 0 {\n            return;\n        }\n\n        // Determine display text (actual or masked)\n        let display_text: String = if self.masked {\n            std::iter::repeat(self.mask_char)\n                .take(self.grapheme_count())\n                .collect()\n        } else if self.value.is_empty() {\n            self.placeholder.clone().unwrap_or_default()\n        } else {\n            self.value.clone()\n        };\n\n        // Calculate horizontal scroll for long text\n        let visible_width = area.width as usize;\n        let display_graphemes: Vec<&str> = display_text.graphemes(true).collect();\n\n        // Ensure cursor is visible by adjusting scroll_offset\n        // ... scroll calculation logic ...\n\n        // Render visible portion\n        let mut x = area.x;\n        for (i, grapheme) in display_graphemes.iter().skip(self.scroll_offset).enumerate() {\n            if x >= area.x + area.width {\n                break;\n            }\n\n            let style = if self.selection_anchor.is_some()\n                && self.is_in_selection(self.scroll_offset + i)\n            {\n                self.selection_style\n            } else if self.value.is_empty() {\n                self.placeholder_style\n            } else {\n                self.style\n            };\n\n            let grapheme_width = unicode_width::UnicodeWidthStr::width(*grapheme) as u16;\n            buf.set_string(x, area.y, grapheme, style);\n            x += grapheme_width;\n        }\n\n        // Render cursor if focused and visible\n        if state.focused && state.cursor_visible {\n            let cursor_x = area.x + self.cursor_display_x(self.scroll_offset) as u16;\n            if cursor_x < area.x + area.width {\n                let cursor_char = display_graphemes\n                    .get(self.cursor)\n                    .copied()\n                    .unwrap_or(\" \");\n                buf.set_string(cursor_x, area.y, cursor_char, self.cursor_style);\n            }\n        }\n\n        trace!(scroll_offset = self.scroll_offset, \"Rendered TextInput\");\n    }\n}\n```\n\n### Cursor Position for Frame\n\n```rust\nimpl TextInput {\n    /// Get the cursor position for Frame::set_cursor().\n    /// Returns (x, y) relative to render area.\n    pub fn cursor_position(&self, area: Rect) -> (u16, u16) {\n        let x = area.x + self.cursor_display_x(self.scroll_offset) as u16;\n        let y = area.y;\n        (x.min(area.x + area.width - 1), y)\n    }\n}\n\n// In parent view function:\n// frame.set_cursor(input.cursor_position(input_area));\n```\n\n---\n\n## Event Handling Pattern\n\n```rust\n// In parent Model::update()\nfn handle_key(&mut self, key: KeyEvent) -> Cmd<Msg> {\n    match key.code {\n        KeyCode::Char(c) if !key.modifiers.contains(Modifiers::CTRL) => {\n            self.input.insert_char(c);\n        }\n        KeyCode::Backspace => {\n            if key.modifiers.contains(Modifiers::CTRL) {\n                self.input.delete_word_before();\n            } else {\n                self.input.delete_char_before();\n            }\n        }\n        KeyCode::Delete => self.input.delete_char_after(),\n        KeyCode::Left => {\n            if key.modifiers.contains(Modifiers::CTRL) {\n                self.input.move_cursor_word_left();\n            } else {\n                self.input.move_cursor_left();\n            }\n        }\n        KeyCode::Right => {\n            if key.modifiers.contains(Modifiers::CTRL) {\n                self.input.move_cursor_word_right();\n            } else {\n                self.input.move_cursor_right();\n            }\n        }\n        KeyCode::Home => self.input.move_cursor_start(),\n        KeyCode::End => self.input.move_cursor_end(),\n        KeyCode::Enter => return Cmd::msg(Msg::Submit(self.input.value().to_string())),\n        _ => {}\n    }\n    Cmd::none()\n}\n```\n\n---\n\n## Testing Requirements\n\n### Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tracing_test::traced_test;\n\n    #[traced_test]\n    #[test]\n    fn test_empty_input_renders_placeholder() {\n        let input = TextInput::new().placeholder(\"Enter text...\");\n        assert!(input.value().is_empty());\n        // Render should show placeholder\n    }\n\n    #[test]\n    fn test_insert_char() {\n        let mut input = TextInput::new();\n        input.insert_char('a');\n        input.insert_char('b');\n        input.insert_char('c');\n        assert_eq!(input.value(), \"abc\");\n        assert_eq!(input.cursor, 3);\n    }\n\n    #[test]\n    fn test_cursor_movement() {\n        let mut input = TextInput::new();\n        input.set_value(\"hello world\");\n        input.move_cursor_end();\n        assert_eq!(input.cursor, 11);\n        input.move_cursor_left();\n        assert_eq!(input.cursor, 10);\n        input.move_cursor_start();\n        assert_eq!(input.cursor, 0);\n    }\n\n    #[test]\n    fn test_word_movement() {\n        let mut input = TextInput::new();\n        input.set_value(\"hello world test\");\n        input.move_cursor_end();\n        input.move_cursor_word_left();\n        assert_eq!(input.cursor, 12); // Before \"test\"\n        input.move_cursor_word_left();\n        assert_eq!(input.cursor, 6); // Before \"world\"\n    }\n\n    #[test]\n    fn test_backspace_delete() {\n        let mut input = TextInput::new();\n        input.set_value(\"hello\");\n        input.move_cursor_end();\n        input.delete_char_before();\n        assert_eq!(input.value(), \"hell\");\n        input.move_cursor_start();\n        input.delete_char_after();\n        assert_eq!(input.value(), \"ell\");\n    }\n\n    #[test]\n    fn test_unicode_grapheme_handling() {\n        let mut input = TextInput::new();\n        // Emoji with skin tone modifier (single grapheme, multiple code points)\n        input.insert_char('👋');\n        input.insert_char('🏽');\n        // This is actually two graphemes, but testing the concept\n        assert_eq!(input.cursor, 2);\n\n        // ZWJ sequence: family emoji\n        input.clear();\n        input.set_value(\"👨‍👩‍👧\");  // Single grapheme cluster\n        assert_eq!(input.grapheme_count(), 1);\n        input.move_cursor_right();\n        assert_eq!(input.cursor, 1);\n    }\n\n    #[test]\n    fn test_max_length() {\n        let mut input = TextInput::new().max_length(5);\n        for c in \"abcdefgh\".chars() {\n            input.insert_char(c);\n        }\n        assert_eq!(input.value(), \"abcde\"); // Only first 5\n    }\n\n    #[test]\n    fn test_password_masking() {\n        let input = TextInput::new().masked().set_value(\"secret\");\n        // When rendered, should show \"••••••\" instead of \"secret\"\n        assert_eq!(input.value(), \"secret\"); // Internal value unchanged\n    }\n\n    #[test]\n    fn test_selection() {\n        let mut input = TextInput::new();\n        input.set_value(\"hello world\");\n        input.select_all();\n        assert_eq!(input.selected_text(), Some(\"hello world\"));\n        input.delete_selection();\n        assert!(input.value().is_empty());\n    }\n}\n```\n\n### Performance Tests\n\n```rust\n#[test]\nfn test_long_input_performance() {\n    let mut input = TextInput::new();\n    let long_text = \"x\".repeat(10_000);\n    input.set_value(&long_text);\n\n    let start = Instant::now();\n    for _ in 0..1000 {\n        input.move_cursor_right();\n        input.move_cursor_left();\n    }\n    assert!(start.elapsed().as_millis() < 100, \"Cursor ops should be fast\");\n}\n```\n\n---\n\n## Acceptance Criteria\n\n### Functional\n- [ ] Text insertion at cursor position\n- [ ] Cursor movement (left, right, word-left, word-right, home, end)\n- [ ] Backspace and delete (char and word)\n- [ ] Selection with shift+arrow (stretch goal)\n- [ ] Placeholder shown when empty\n- [ ] Password mode with masking\n- [ ] Max length enforcement\n- [ ] Horizontal scroll for long text\n\n### Unicode\n- [ ] Grapheme-cluster aware cursor (not byte or char)\n- [ ] Wide character handling (CJK, emoji)\n- [ ] ZWJ sequences treated as single unit\n\n### Integration\n- [ ] cursor_position() returns correct Frame cursor coords\n- [ ] Works with runtime event loop\n- [ ] Cursor blinks (external state via TextInputState)\n\n### Logging\n- [ ] debug! for major operations (set_value, clear, select_all)\n- [ ] trace! for cursor movement, char insertion\n- [ ] instrument on render() with key fields\n\n---\n\n## Location\n`ftui-widgets/src/widgets/text_input.rs`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:50:16.110227001Z","created_by":"ubuntu","updated_at":"2026-02-01T00:33:45.771023065Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-gpe","depends_on_id":"bd-10i.5.1","type":"blocks","created_at":"2026-01-31T22:53:49.333671503Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-gpe","depends_on_id":"bd-10i.7","type":"parent-child","created_at":"2026-01-31T22:53:50.107013218Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-gpe","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:53:49.726151291Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-jbg","title":"Implement forms and picker widgets","description":"PHASE 7 - EXTRAS: FORMS AND PICKERS\n\n## Background\nInteractive forms and picker dialogs are common UI patterns for configuration, data entry, and selection. Feature-gated as optional extra.\n\n## Technical Requirements\n\n### Form Widget\n- Field types: TextInput, Checkbox, Radio, Select, Number\n- Validation support with error messages\n- Tab navigation between fields\n- Submit/Cancel actions\n- Vertical or horizontal layout\n- Required field indicators\n\n### Form API\n\npub struct Form {\n    fields: Vec<FormField>,\n    focused: usize,\n    on_submit: Option<Box<dyn Fn(&FormData)>>,\n}\n\npub enum FormField {\n    Text { label: String, value: String, placeholder: Option<String> },\n    Checkbox { label: String, checked: bool },\n    Radio { label: String, options: Vec<String>, selected: usize },\n    Select { label: String, options: Vec<String>, selected: usize },\n    Number { label: String, value: i64, min: Option<i64>, max: Option<i64> },\n}\n\nimpl Form {\n    pub fn new(fields: Vec<FormField>) -> Self;\n    pub fn focus_next(&mut self);\n    pub fn focus_prev(&mut self);\n    pub fn submit(&self) -> FormData;\n    pub fn validate(&self) -> Vec<ValidationError>;\n}\n\n### Picker Widgets\n- FilePicker: Browse filesystem with filtering\n- ColorPicker: Visual color selection\n- DatePicker: Calendar-based date selection\n- ConfirmDialog: Yes/No confirmation\n\n### Picker API\n\npub struct FilePicker {\n    current_dir: PathBuf,\n    filter: Option<String>,  // glob pattern\n    show_hidden: bool,\n    selection: Option<PathBuf>,\n}\n\nimpl FilePicker {\n    pub fn new(start_dir: impl AsRef<Path>) -> Self;\n    pub fn filter(mut self, pattern: &str) -> Self;\n    pub fn show_hidden(mut self, show: bool) -> Self;\n    pub fn selected(&self) -> Option<&Path>;\n}\n\n## Tests Required\n- [ ] Form field navigation works\n- [ ] Validation errors display correctly\n- [ ] Submit collects all values\n- [ ] FilePicker navigates directories\n- [ ] ColorPicker returns valid RGB\n\n## Acceptance Criteria\n- [ ] All form field types implemented\n- [ ] Keyboard navigation complete\n- [ ] FilePicker with glob filtering\n- [ ] ConfirmDialog with Yes/No\n- [ ] Accessible focus indicators\n\n## Location: ftui-extras crate (feature = \"forms\")","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-31T22:44:26.319113364Z","created_by":"ubuntu","updated_at":"2026-01-31T22:44:38.747722333Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-jbg","depends_on_id":"bd-376","type":"blocks","created_at":"2026-01-31T22:44:37.248828520Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-jbg","depends_on_id":"bd-yzu","type":"blocks","created_at":"2026-01-31T22:44:38.747690513Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-rk95","title":"Implement GraphemeId encoding with slot+width packing","description":"# Implement GraphemeId encoding with slot+width packing\n\n## Background\nPlan Section 5.1 defines the specific encoding for GraphemeId - the reference to complex grapheme clusters in the GraphemePool. This encoding is critical for the 16-byte Cell constraint.\n\n## Encoding Specification\n```\nGraphemeId: u32\nLayout: [30-24: width (7 bits)][23-0: pool slot (24 bits)]\n```\n\n### Bit Layout\n```\nMSB                                      LSB\n+-------+----------------------------------+\n| Width | Pool Slot Index                  |\n| 7 bits| 24 bits                          |\n+-------+----------------------------------+\nBits: 30-24  23-0\n```\n\n### Capacity\n- Pool slots: 16,777,216 (24 bits = 16M entries)\n- Width range: 0-127 (7 bits, plenty for any display width)\n\n## Implementation\n\n```rust\n/// Grapheme ID: reference to interned string in GraphemePool\n/// Layout: [30-24: width (7 bits)][23-0: pool slot (24 bits)]\n/// \n/// # Design Rationale\n/// - 24 bits for slot allows 16M unique graphemes (far exceeding practical usage)\n/// - 7 bits for width allows display widths 0-127 (most graphemes are 1-2)\n/// - Embedded width avoids pool lookup for width queries\n/// - Total 31 bits leaves bit 31 for CellContent type discrimination\n#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n#[repr(transparent)]\npub struct GraphemeId(u32);\n\nimpl GraphemeId {\n    /// Maximum slot index (24 bits)\n    pub const MAX_SLOT: u32 = 0x00FF_FFFF;\n    \n    /// Maximum width (7 bits)\n    pub const MAX_WIDTH: u8 = 127;\n    \n    /// Create from slot index and display width\n    /// \n    /// # Panics\n    /// Panics in debug mode if slot > MAX_SLOT or width > MAX_WIDTH\n    #[inline]\n    pub fn new(slot: u32, width: u8) -> Self {\n        debug_assert!(slot <= Self::MAX_SLOT, \"slot overflow: {}\", slot);\n        debug_assert!(width <= Self::MAX_WIDTH, \"width overflow: {}\", width);\n        Self((slot & Self::MAX_SLOT) | ((width as u32) << 24))\n    }\n    \n    /// Extract pool slot index (0-16M)\n    #[inline]\n    pub fn slot(&self) -> usize {\n        (self.0 & Self::MAX_SLOT) as usize\n    }\n    \n    /// Extract display width (0-127)\n    #[inline]\n    pub fn width(&self) -> usize {\n        ((self.0 >> 24) & 0x7F) as usize\n    }\n    \n    /// Raw u32 value for storage in CellContent\n    #[inline]\n    pub fn raw(&self) -> u32 {\n        self.0\n    }\n    \n    /// Reconstruct from raw u32\n    #[inline]\n    pub fn from_raw(raw: u32) -> Self {\n        Self(raw)\n    }\n}\n\nimpl std::fmt::Debug for GraphemeId {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"GraphemeId\")\n            .field(\"slot\", &self.slot())\n            .field(\"width\", &self.width())\n            .finish()\n    }\n}\n```\n\n## Integration with CellContent\n\nCellContent uses bit 31 to discriminate between char and GraphemeId:\n- Bit 31 == 0: char (Unicode scalar value in bits 0-30)\n- Bit 31 == 1: GraphemeId (slot + width in bits 0-30)\n\n```rust\nimpl CellContent {\n    pub fn from_grapheme(id: GraphemeId) -> Self {\n        // Set bit 31 to indicate grapheme\n        Self(0x8000_0000 | id.raw())\n    }\n    \n    pub fn grapheme_id(&self) -> Option<GraphemeId> {\n        if self.is_grapheme() {\n            Some(GraphemeId::from_raw(self.0 & !0x8000_0000))\n        } else {\n            None\n        }\n    }\n}\n```\n\n## Tests Required\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_grapheme_id_encoding() {\n        // Test basic encoding\n        let id = GraphemeId::new(12345, 2);\n        assert_eq!(id.slot(), 12345);\n        assert_eq!(id.width(), 2);\n        \n        // Test max values\n        let id_max = GraphemeId::new(GraphemeId::MAX_SLOT, GraphemeId::MAX_WIDTH);\n        assert_eq!(id_max.slot(), 0x00FF_FFFF);\n        assert_eq!(id_max.width(), 127);\n        \n        // Test zero values\n        let id_zero = GraphemeId::new(0, 0);\n        assert_eq!(id_zero.slot(), 0);\n        assert_eq!(id_zero.width(), 0);\n    }\n    \n    #[test]\n    fn test_grapheme_id_roundtrip() {\n        for slot in [0, 1, 100, 10000, 0x00FF_FFFF] {\n            for width in [0, 1, 2, 4, 127] {\n                let id = GraphemeId::new(slot, width);\n                assert_eq!(id.slot() as u32, slot);\n                assert_eq!(id.width() as u8, width);\n            }\n        }\n    }\n    \n    #[test]\n    fn test_cellcontent_grapheme_integration() {\n        let id = GraphemeId::new(42, 2);\n        let content = CellContent::from_grapheme(id);\n        \n        assert!(content.is_grapheme());\n        assert_eq!(content.grapheme_id(), Some(id));\n        assert_eq!(content.width(), 2);\n    }\n    \n    #[test]\n    #[should_panic(expected = \"slot overflow\")]\n    #[cfg(debug_assertions)]\n    fn test_grapheme_id_slot_overflow_debug() {\n        let _ = GraphemeId::new(0x0100_0000, 1); // 25 bits\n    }\n    \n    #[test]\n    #[should_panic(expected = \"width overflow\")]\n    #[cfg(debug_assertions)]\n    fn test_grapheme_id_width_overflow_debug() {\n        let _ = GraphemeId::new(1, 128);\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] GraphemeId fits in u32 with documented layout\n- [ ] slot() and width() extract correctly\n- [ ] Integration with CellContent works\n- [ ] Debug assertions catch overflows\n- [ ] Tests cover edge cases\n\n## Dependencies\n- Blocks: bd-10i.3.1 (CellContent)\n- Blocks: bd-10i.3.5 (GraphemePool)","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-01T00:23:35.288865782Z","created_by":"ubuntu","updated_at":"2026-02-01T00:37:22.879821793Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-rk95","depends_on_id":"bd-10i.3","type":"parent-child","created_at":"2026-02-01T00:37:22.879787097Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-tb84","title":"v1 Definition of Done (Ship Checklist)","description":"# v1 Definition of Done (Ship Checklist)\n\n## Background\nPlan Section 0.11 defines when ftui \"v1\" is done. This is the comprehensive checklist that must be completed before tagging v1.0.0.\n\n## Definition of Done Criteria\n\n### 1. Inline Mode Default is Stable\n- [ ] Streaming logs + UI chrome does not corrupt scrollback\n- [ ] Streaming logs + UI chrome does not corrupt cursor placement\n- [ ] PTY tests confirm behavior on normal exit\n- [ ] PTY tests confirm behavior on panic\n- [ ] Tested on: Linux (xterm-like), macOS Terminal, tmux, screen\n- [ ] No flicker under sustained log output\n- [ ] Resize during logging re-anchors correctly\n\n**Verified by:** bd-2gx Gate 1, bd-fbp, bd-10i.11.2\n\n### 2. Diff/Presenter Correctness Validated\n- [ ] Terminal-model tests for supported sequences pass\n- [ ] Property tests with random buffers pass\n- [ ] Output size baselines for representative workloads documented\n- [ ] Style state never leaks across runs\n- [ ] OSC 8 links properly managed (open/close)\n\n**Verified by:** bd-2gx Gate 2, bd-10i.11.1, bd-10i.4.3\n\n### 3. Unicode Width Correctness Proven\n- [ ] Corpus tests cover ZWJ sequences\n- [ ] Corpus tests cover emoji\n- [ ] Corpus tests cover combining marks\n- [ ] No off-by-one wrapping errors\n- [ ] Truncation at correct grapheme boundaries\n\n**Verified by:** bd-2gx Gate 3, bd-16k, bd-2uk\n\n### 4. Style System is Deterministic and Documented\n- [ ] Explicit masks documented\n- [ ] Inheritance rules documented\n- [ ] Style merge is deterministic (same input = same output)\n- [ ] Theme resolution documented\n- [ ] No \"heisenbug\" style flickers\n\n**Verified by:** bd-10x, bd-22q\n\n### 5. Runtime Supports Required Features\n- [ ] update/view loop works\n- [ ] Ticks scheduling works\n- [ ] Batch commands work\n- [ ] Sequence commands work\n- [ ] Deterministic simulator works\n- [ ] Snapshot tests work\n\n**Verified by:** bd-10i.8.2, bd-10i.8.3\n\n### 6. Core Widgets for Harness UIs Exist and Tested\n- [ ] Viewport/log viewer: bd-29v\n- [ ] Status line / panel: bd-2dc\n- [ ] Text input / prompt line: bd-gpe\n- [ ] Progress: bd-35p\n- [ ] Spinner: bd-35p\n- [ ] All widgets have snapshot tests\n\n**Verified by:** bd-10i.7 (Phase 5)\n\n### 7. Documentation Complete\n- [ ] \"Build an agent harness UI\" tutorial: bd-wo2\n- [ ] Inline vs alt-screen explanation: bd-1u5\n- [ ] IO ownership and one-writer rule guidance: bd-10i.12.6\n- [ ] Windows limitations documented: bd-2ss\n- [ ] API documentation (rustdoc) complete\n\n**Verified by:** bd-10i.12 (Docs epic)\n\n### 8. Quality Gates Pass (All Four)\n- [ ] Gate 1: Inline mode stability\n- [ ] Gate 2: Diff/presenter correctness\n- [ ] Gate 3: Unicode width correctness\n- [ ] Gate 4: Terminal cleanup\n\n**Verified by:** bd-2gx\n\n### 9. Performance Budgets Met\n- [ ] Present (80×24, 5% changed): p50 < 1.0ms, p99 < 3.0ms\n- [ ] Present (120×40, 5% changed): p50 < 2.0ms, p99 < 6.0ms\n- [ ] Cell comparison: < 1ns\n- [ ] Input parse: < 100µs/event\n\n**Verified by:** bd-19x (benchmarks)\n\n### 10. CI/CD Complete\n- [ ] All tests pass on Linux, macOS, Windows\n- [ ] Coverage meets thresholds\n- [ ] Benchmarks run and tracked\n- [ ] Release workflow configured\n- [ ] Dependabot configured\n\n**Verified by:** bd-xn2\n\n## Ship Process\n1. Create v1 tracking issue listing all criteria\n2. Verify all beads above are closed\n3. Run full test suite on all platforms\n4. Update CHANGELOG.md with v1 release notes\n5. Tag v1.0.0\n6. Publish to crates.io\n\n## Acceptance Criteria\n- [ ] All 10 sections verified green\n- [ ] No P0 or P1 issues open\n- [ ] v1.0.0 tagged and published","status":"open","priority":0,"issue_type":"docs","created_at":"2026-01-31T23:19:32.880914588Z","created_by":"ubuntu","updated_at":"2026-01-31T23:19:40.669006523Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-tb84","depends_on_id":"bd-10i.12","type":"blocks","created_at":"2026-01-31T23:19:40.668966638Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-tb84","depends_on_id":"bd-19x","type":"blocks","created_at":"2026-01-31T23:19:39.357620264Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-tb84","depends_on_id":"bd-2gx","type":"blocks","created_at":"2026-01-31T23:19:38.747696054Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-tb84","depends_on_id":"bd-xn2","type":"blocks","created_at":"2026-01-31T23:19:39.952586690Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-v6y","title":"Implement ASCII width fast-path optimization","description":"# Implement ASCII Width Fast-Path Optimization\n\n## Background\nThe plan emphasizes that ASCII must dominate common workloads:\n- Section 0.12: \"ASCII fast-path must remain allocation-free and dominate common workloads\"\n- Section 4.3: ASCII width is a major optimization opportunity\n\nMost harness/log output is ASCII. For ASCII:\n- display width == byte length\n- no grapheme segmentation needed\n- no Unicode tables needed\n\n## Scope\n- Provide a fast, allocation-free `ascii_width` / `display_width` helper.\n- Integrate it into text measurement / wrapping / truncation hot paths.\n\n## Design\n### Core API\n```rust\n/// Returns Some(width) if s is pure ASCII; otherwise None.\n#[inline]\npub fn ascii_width(s: &str) -> Option<usize> {\n    let bytes = s.as_bytes();\n    if bytes.iter().all(|&b| b < 0x80) {\n        Some(bytes.len())\n    } else {\n        None\n    }\n}\n\n#[inline]\npub fn display_width(s: &str) -> usize {\n    ascii_width(s).unwrap_or_else(|| unicode_width::UnicodeWidthStr::width(s))\n}\n```\n\n### Performance notes\n- ASCII detection is O(n) but extremely cheap (tight loop over bytes).\n- Optional micro-optimizations (still safe): use `memchr` or portable SIMD via `std::simd` if available.\n- **Repo policy: unsafe is forbidden**, so any SIMD path must be safe or it is out of scope.\n\n## Integration points\n- Segment/Text measurement\n- Wrapping/truncation (byte-fast for ASCII)\n- Viewport/log viewer rendering\n\n## Tests\n- Pure ASCII returns correct width\n- Mixed ASCII/Unicode returns None from `ascii_width`\n- Empty string returns Some(0)\n- Integration tests: wrapping/truncation correctness unchanged\n\n## Acceptance Criteria\n- [ ] `ascii_width` and `display_width` exist.\n- [ ] ASCII path is allocation-free.\n- [ ] Non-ASCII path matches `unicode_width`.\n- [ ] Integrated into the ftui-text measurement code paths.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-31T22:52:10.389324927Z","created_by":"ubuntu","updated_at":"2026-01-31T23:17:20.444443185Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-v6y","depends_on_id":"bd-10i.6","type":"parent-child","created_at":"2026-01-31T23:13:33.822578175Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-v6y","depends_on_id":"bd-1oz","type":"blocks","created_at":"2026-01-31T23:17:20.444396266Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-v6y","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T23:16:20.236617070Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-vv66","title":"Comprehensive Unit Test Suite with Detailed Logging","description":"# Comprehensive Unit Test Suite with Detailed Logging\n\n## Background\nPlan Section 13.1 requires property tests and unit tests for all kernel components. The user specifically requested \"comprehensive unit tests and e2e test scripts with great, detailed logging so we can be sure that everything is working perfectly after implementation.\"\n\n## Scope\nEvery module in ftui must have a corresponding test module with:\n1. Unit tests for all public APIs\n2. Property tests for invariant preservation\n3. Detailed logging of test execution for debugging\n\n## Test Logging Requirements\nAll tests MUST use structured logging (tracing) with:\n- Test name and module path\n- Input parameters (for property tests, show the generated inputs)\n- Expected vs actual values on failure\n- Timing information for performance-sensitive code\n- Stack traces on failure\n\n## Per-Module Test Coverage (MANDATORY)\n\n### ftui-core Tests\n- [ ] TerminalSession: enter/exit raw mode, panic cleanup, mode tracking\n- [ ] TerminalCapabilities: detection from environment variables\n- [ ] Event types: serialization, comparison, conversion from backend\n\n### ftui-render Tests\n- [ ] Cell: 16-byte layout assertion, bits_eq correctness\n- [ ] CellContent: char encoding, grapheme encoding, width calculation\n- [ ] PackedRgba: RGBA packing, Porter-Duff over operation, opacity\n- [ ] CellAttrs: flag packing, link ID encoding\n- [ ] Buffer: bounds checking, scissor stack invariants, opacity stack invariants\n- [ ] GraphemePool: intern/lookup, refcount correctness, slot reuse\n- [ ] LinkRegistry: register/lookup, deduplication\n- [ ] BufferDiff: change detection, run grouping correctness\n- [ ] Presenter: ANSI output correctness, style tracking, link handling\n\n### ftui-style Tests\n- [ ] Style: merge semantics, mask handling, property inheritance\n- [ ] Color: parsing, downgrade (truecolor→256→16→mono)\n- [ ] Theme: slot resolution, preset correctness\n\n### ftui-text Tests\n- [ ] Text/Span: construction, styling, width measurement\n- [ ] Wrapping: word wrap, character wrap, no mid-grapheme breaks\n- [ ] Truncation: ellipsis placement, width correctness\n- [ ] Measurement: min/max width calculation\n\n### ftui-layout Tests\n- [ ] Rect: intersection, containment, inner margin\n- [ ] Sides: CSS-like tuple conversion\n- [ ] Layout algorithms: flex, grid constraints\n\n### ftui-runtime Tests\n- [ ] Program: event dispatch, command handling\n- [ ] Cmd: batch, sequence, tick scheduling\n- [ ] Simulator: deterministic replay, snapshot capture\n\n## Test Harness Requirements\n\n### Logging Setup\n```rust\n#[cfg(test)]\nmod tests {\n    use tracing::{info, debug, error};\n    use tracing_test::traced_test;\n    \n    #[traced_test]\n    #[test]\n    fn test_cell_bits_eq() {\n        info\\!(\"Testing Cell::bits_eq with identical cells\");\n        let cell_a = Cell::new('A', Style::default());\n        let cell_b = Cell::new('A', Style::default());\n        debug\\!(cell_a = ?cell_a, cell_b = ?cell_b, \"Comparing cells\");\n        assert\\!(cell_a.bits_eq(&cell_b), \"Identical cells should be equal\");\n        info\\!(\"Cell bits_eq test passed\");\n    }\n}\n```\n\n### Property Test Logging\n```rust\n#[cfg(test)]\nproptest\\! {\n    #[test]\n    fn buffer_diff_roundtrip(buffer1 in arb_buffer(80, 24), buffer2 in arb_buffer(80, 24)) {\n        info\\!(width = 80, height = 24, \"Property test: buffer diff roundtrip\");\n        debug\\!(buffer1_hash = ?hash(&buffer1), buffer2_hash = ?hash(&buffer2), \"Input buffers\");\n        \n        let diff = BufferDiff::compute(&buffer1, &buffer2);\n        info\\!(change_count = diff.len(), \"Diff computed\");\n        \n        // Apply diff and verify\n        let mut result = buffer1.clone();\n        apply_diff(&mut result, &buffer2, &diff);\n        \n        for y in 0..24 {\n            for x in 0..80 {\n                prop_assert_eq\\!(\n                    result.get(x, y), buffer2.get(x, y),\n                    \"Cell mismatch at ({}, {})\", x, y\n                );\n            }\n        }\n        info\\!(\"Property test passed\");\n    }\n}\n```\n\n## Test Categories with Counts\n\n| Module | Min Test Count | Notes |\n|--------|----------------|-------|\n| Cell/CellContent | 15+ | Layout, encoding, width |\n| Buffer | 20+ | Bounds, scissor, opacity, clear |\n| GraphemePool | 10+ | Intern, refcount, reuse |\n| BufferDiff | 15+ | Detection, runs, edge cases |\n| Presenter | 25+ | All ANSI sequences, state tracking |\n| InputParser | 30+ | All key codes, mouse, paste |\n| Style | 15+ | Merge, mask, inheritance |\n| Text | 20+ | Width, wrap, truncate |\n\n## Acceptance Criteria\n- [ ] Every public API has at least one test\n- [ ] Property tests cover all invariants from plan Section 2.3\n- [ ] All tests use tracing for logging\n- [ ] Test output includes timing information\n- [ ] cargo test --all produces clear, structured output\n- [ ] Test coverage > 80% for kernel crates\n\n## Dependencies\n- Requires: bd-10i.3 (Phase 1 types exist)\n- Blocks: bd-2gx (Quality Gates)\n\n## Test Framework Stack\n- Unit tests: built-in #[test]\n- Property tests: proptest\n- Logging: tracing + tracing-test\n- Coverage: cargo-llvm-cov\n- Timing: criterion for perf-sensitive\n\n## CI Requirements\n- All tests run on every PR\n- Test failure shows full log output\n- Coverage report generated\n- Test timing tracked for regression","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-01T00:22:11.213562541Z","created_by":"ubuntu","updated_at":"2026-02-01T00:23:03.077330895Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-vv66","depends_on_id":"bd-10i.3","type":"blocks","created_at":"2026-02-01T00:23:01.038361408Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-vv66","depends_on_id":"bd-10i.4","type":"blocks","created_at":"2026-02-01T00:23:02.034341395Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-vv66","depends_on_id":"bd-10i.5","type":"blocks","created_at":"2026-02-01T00:23:03.077288094Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-wo2","title":"Write Agent Harness Tutorial documentation","description":"# Write Agent Harness Tutorial Documentation\n\n## Background & Strategic Importance\nThe plan explicitly requires documentation that includes an \"Agent harness tutorial\". This is THE PRIMARY documentation goal because agent harness UIs are ftui's core use case. Every design decision in ftui has been made with this tutorial's success in mind.\n\n## Why This Documentation Is Critical\n- FrankenTUI exists specifically for Claude Code / Codex-style agent harness UIs\n- Without clear documentation, users cannot adopt ftui for their agents\n- The tutorial IS the marketing - if someone can follow it, they understand ftui's value\n- Plan Section 17 (Playbook) emphasizes this as a key deliverable\n\n---\n\n## Tutorial Structure\n\n### Part 1: Hello World Harness (< 50 LOC)\n\n**Goal:** Demonstrate the absolute minimum harness that compiles and runs.\n\n```rust\n//! Part 1: Hello World Harness\n//!\n//! This minimal example shows ftui's core pattern:\n//! Model → update → view cycle with inline mode.\n\nuse ftui::prelude::*;\n\n/// Our application state - just a counter for now.\nstruct HelloHarness {\n    message: String,\n}\n\nimpl Model for HelloHarness {\n    type Message = ();\n\n    fn init(&mut self) -> Cmd<Self::Message> {\n        Cmd::none()\n    }\n\n    fn update(&mut self, _msg: Self::Message) -> Cmd<Self::Message> {\n        Cmd::quit()\n    }\n\n    fn view(&self, frame: &mut Frame) {\n        let area = frame.buffer.area();\n        frame.buffer.set_string(0, 0, &self.message, Style::default());\n    }\n}\n\nfn main() -> ftui::Result<()> {\n    App::new(HelloHarness {\n        message: \"Hello from ftui!\".to_string(),\n    })\n    .screen_mode(ScreenMode::Inline { ui_height: 1 })\n    .run()\n}\n```\n\n**Key concepts introduced:**\n- `Model` trait with `init()`, `update()`, `view()`\n- `Frame` and `Buffer` for rendering\n- `ScreenMode::Inline` for scrollback preservation\n- `Cmd` for commands (just `none()` and `quit()` here)\n\n---\n\n### Part 2: Adding Log Streaming\n\n**Goal:** Build on Part 1 to show logs scrolling in scrollback.\n\n```rust\n//! Part 2: Log Streaming\n//!\n//! Demonstrates the `write_log()` pattern where log lines\n//! enter native terminal scrollback while UI stays pinned.\n\nuse ftui::prelude::*;\nuse ftui_widgets::LogViewer;\n\nstruct LogHarness {\n    log_viewer: LogViewer,\n    log_count: usize,\n}\n\n#[derive(Clone)]\nenum Msg {\n    AddLog(String),\n    Tick,\n    Quit,\n}\n\nimpl Model for LogHarness {\n    type Message = Msg;\n\n    fn init(&mut self) -> Cmd<Msg> {\n        // Start a tick every 100ms to simulate incoming logs\n        Cmd::tick(Duration::from_millis(100), || Msg::Tick)\n    }\n\n    fn update(&mut self, msg: Msg) -> Cmd<Msg> {\n        match msg {\n            Msg::AddLog(line) => {\n                self.log_viewer.push(line);\n            }\n            Msg::Tick => {\n                self.log_count += 1;\n                self.log_viewer.push(format!(\"[{}] Log entry simulated\", self.log_count));\n                if self.log_count >= 100 {\n                    return Cmd::quit();\n                }\n            }\n            Msg::Quit => return Cmd::quit(),\n        }\n        Cmd::none()\n    }\n\n    fn view(&self, frame: &mut Frame) {\n        // The log viewer fills the available area\n        // In inline mode, this is the fixed UI region at the bottom\n        let area = frame.buffer.area();\n        let mut state = LogViewerState::default();\n        self.log_viewer.render(area, &mut frame.buffer, &mut state);\n    }\n}\n```\n\n**Key concepts introduced:**\n- `LogViewer` widget for streaming logs\n- Tick-based updates for simulating incoming data\n- Message enum pattern\n- State management across renders\n\n---\n\n### Part 3: Interactive Input\n\n**Goal:** Add user interaction with text input.\n\n```rust\n//! Part 3: Interactive Input\n//!\n//! Shows how to handle keyboard events and text input.\n\nuse ftui::prelude::*;\nuse ftui_widgets::{LogViewer, TextInput};\n\nstruct InteractiveHarness {\n    log_viewer: LogViewer,\n    input: TextInput,\n    focused: bool,\n}\n\n#[derive(Clone)]\nenum Msg {\n    Key(KeyEvent),\n    Submit(String),\n    Tick,\n}\n\nimpl Model for InteractiveHarness {\n    type Message = Msg;\n\n    fn init(&mut self) -> Cmd<Msg> {\n        Cmd::batch(vec![\n            Cmd::tick(Duration::from_millis(100), || Msg::Tick),\n            Cmd::listen_keys(|k| Msg::Key(k)),\n        ])\n    }\n\n    fn update(&mut self, msg: Msg) -> Cmd<Msg> {\n        match msg {\n            Msg::Key(key) => {\n                match key.code {\n                    KeyCode::Enter => {\n                        let value = self.input.value().to_string();\n                        self.input.clear();\n                        return Cmd::msg(Msg::Submit(value));\n                    }\n                    KeyCode::Char('q') if key.modifiers.contains(Modifiers::CTRL) => {\n                        return Cmd::quit();\n                    }\n                    KeyCode::Char(c) => self.input.insert_char(c),\n                    KeyCode::Backspace => self.input.delete_char_before(),\n                    KeyCode::Left => self.input.move_cursor_left(),\n                    KeyCode::Right => self.input.move_cursor_right(),\n                    _ => {}\n                }\n            }\n            Msg::Submit(command) => {\n                self.log_viewer.push(format!(\"> {}\", command));\n                self.log_viewer.push(format!(\"Executed: {}\", command));\n            }\n            Msg::Tick => {\n                // Spinner animation, status updates, etc.\n            }\n        }\n        Cmd::none()\n    }\n\n    fn view(&self, frame: &mut Frame) {\n        let area = frame.buffer.area();\n\n        // Log viewer takes most of the space\n        let log_area = Rect::new(0, 0, area.width, area.height - 1);\n        let mut log_state = LogViewerState::default();\n        self.log_viewer.render(log_area, &mut frame.buffer, &mut log_state);\n\n        // Input line at bottom\n        let input_area = Rect::new(0, area.height - 1, area.width, 1);\n        frame.buffer.set_string(0, input_area.y, \"> \", Style::default());\n        let text_area = Rect::new(2, input_area.y, area.width - 2, 1);\n        let mut input_state = TextInputState::new();\n        input_state.focused = true;\n        self.input.render(text_area, &mut frame.buffer, &mut input_state);\n\n        // Set cursor position for terminal\n        let (cx, cy) = self.input.cursor_position(text_area);\n        frame.set_cursor(cx + 2, cy);\n    }\n}\n```\n\n**Key concepts introduced:**\n- Key event handling with pattern matching\n- TextInput widget operations\n- Cursor position reporting to Frame\n- Layout with multiple widgets\n\n---\n\n### Part 4: Tool Status and Indicators\n\n**Goal:** Add agent-style status with spinners and progress.\n\n```rust\n//! Part 4: Tool Status\n//!\n//! Shows spinner animation for running tools and status line.\n\nuse ftui::prelude::*;\nuse ftui_widgets::{LogViewer, TextInput, Spinner, ProgressBar, spinners};\n\nstruct AgentHarness {\n    log_viewer: LogViewer,\n    input: TextInput,\n    spinner: Spinner,\n    spinner_state: SpinnerState,\n    current_tool: Option<String>,\n    status: String,\n}\n\n// ... implementation showing:\n// - Spinner animation via tick\n// - Status line with model/tool info\n// - Progress bars for long operations\n// - Tool start/end state management\n```\n\n---\n\n### Part 5: Modal Alt-Screen\n\n**Goal:** Show how to temporarily switch to alt-screen for complex interactions.\n\n```rust\n//! Part 5: Modal Alt-Screen\n//!\n//! Demonstrates the mixed-mode strategy: inline normally,\n//! but alt-screen for file picker or other modal UI.\n\nimpl AgentHarness {\n    fn enter_file_picker(&mut self) -> Cmd<Msg> {\n        self.mode = HarnessMode::FilePicker;\n        Cmd::enter_alt_screen()\n    }\n\n    fn exit_file_picker(&mut self, selected: Option<PathBuf>) -> Cmd<Msg> {\n        self.mode = HarnessMode::Normal;\n        if let Some(path) = selected {\n            self.log_viewer.push(format!(\"Selected: {}\", path.display()));\n        }\n        Cmd::exit_alt_screen()\n    }\n}\n```\n\n**Key concepts:**\n- `Cmd::enter_alt_screen()` and `Cmd::exit_alt_screen()`\n- Preserving context across mode switches\n- When to use alt-screen (complex modals only)\n\n---\n\n### Part 6: PTY Child Process Capture\n\n**Goal:** Show advanced integration with subprocess output.\n\n```rust\n//! Part 6: PTY Subprocess Capture\n//!\n//! Shows how to capture child process output through ftui\n//! while preserving the one-writer rule.\n\n#[cfg(feature = \"pty\")]\nfn run_tool(&mut self, command: &str) -> Cmd<Msg> {\n    // Spawn child with PTY\n    let (master, slave) = ftui::pty::openpty()?;\n\n    let child = Command::new(\"sh\")\n        .args([\"-c\", command])\n        .stdin(slave.clone())\n        .stdout(slave.clone())\n        .stderr(slave)\n        .spawn()?;\n\n    // Read from master, forward to log viewer\n    // All output serialized through ftui (one-writer preserved)\n    Cmd::stream(master, |line| Msg::ToolOutput(line))\n}\n```\n\n---\n\n## Key Concepts to Explain\n\n### The One-Writer Rule\n\n> \"All bytes that affect terminal state are serialized through a single owner.\"\n\n**Why this matters:**\n- Multiple writers = cursor corruption, escape sequence interleaving\n- Inline mode is especially sensitive (scrollback can be corrupted)\n- ftui enforces this via the runtime owning terminal I/O\n\n**What happens if violated:**\n- Cursor jumps to wrong position\n- Colors bleed across regions\n- Partial escape sequences render as garbage\n\n**How ftui prevents this:**\n- Terminal is owned by runtime during `run()`\n- All output goes through `present()`\n- PTY capture routes through ftui\n\n### Inline vs Alt-Screen Trade-offs\n\n| Feature | Inline Mode | Alt-Screen Mode |\n|---------|-------------|-----------------|\n| Scrollback preserved | ✓ | ✗ |\n| Full-screen clear OK | ✗ | ✓ |\n| Log history after exit | ✓ | ✗ |\n| Agent harness ideal | ✓ | ✗ |\n\n**When to use inline:** Agent harnesses, REPLs, log viewers\n**When to use alt-screen:** Full dashboards, games, temporary modals\n\n### Cursor Contract\n\n> \"After any present(), cursor position is restored per the active policy.\"\n\n**What this means:**\n- In inline mode, cursor returns to input line\n- Frame::set_cursor() tells ftui where you want the cursor\n- Presenter handles the actual restoration\n\n**How to debug cursor corruption:**\n1. Check PTY test output\n2. Verify no writes outside present() cycle\n3. Look for child process stdout leaks\n\n### Sanitization Policy\n\n> \"Untrusted bytes are never executed.\"\n\n**Why logs are sanitized by default:**\n- Tool output may contain ANSI escapes\n- Malicious content could inject cursor moves\n- Security: prevent terminal escape attacks\n\n**How to opt-in to raw ANSI:**\n```rust\nlog_viewer.push(Text::raw(ansi_string)); // Dangerous!\nlog_viewer.push(Text::sanitized(user_input)); // Safe (default)\n```\n\n---\n\n## Code Examples\n\nEach section should have:\n- ✓ Complete, runnable code\n- ✓ Explanation of key lines\n- ✓ Common mistakes to avoid\n- ✓ Performance notes\n\n**Common Mistakes:**\n\n1. **Forgetting to set cursor position:**\n   ```rust\n   // WRONG: No cursor shown\n   fn view(&self, frame: &mut Frame) {\n       self.input.render(area, &mut frame.buffer, &mut state);\n   }\n\n   // RIGHT: Cursor visible at input position\n   fn view(&self, frame: &mut Frame) {\n       self.input.render(area, &mut frame.buffer, &mut state);\n       let (x, y) = self.input.cursor_position(area);\n       frame.set_cursor(x, y);\n   }\n   ```\n\n2. **Blocking in update():**\n   ```rust\n   // WRONG: Freezes UI\n   fn update(&mut self, msg: Msg) -> Cmd<Msg> {\n       std::thread::sleep(Duration::from_secs(5));\n       Cmd::none()\n   }\n\n   // RIGHT: Async via commands\n   fn update(&mut self, msg: Msg) -> Cmd<Msg> {\n       Cmd::perform(async { long_operation().await }, |r| Msg::Done(r))\n   }\n   ```\n\n3. **Writing to stdout directly:**\n   ```rust\n   // WRONG: Violates one-writer rule\n   println!(\"Debug: {}\", value);\n\n   // RIGHT: Use tracing\n   tracing::debug!(value, \"Debug\");\n   ```\n\n---\n\n## Acceptance Criteria\n\n- [ ] Tutorial covers all 6 parts\n- [ ] Each part builds on previous (copy-paste and it compiles)\n- [ ] Code examples compile and run\n- [ ] Key concepts explained clearly with diagrams\n- [ ] Common pitfalls documented with WRONG/RIGHT examples\n- [ ] PTY testing mentioned for verification\n- [ ] Links to API docs for widgets used\n- [ ] Performance notes where relevant\n\n---\n\n## Location\n`docs/tutorials/agent-harness.md`","status":"open","priority":2,"issue_type":"docs","created_at":"2026-01-31T22:51:01.345137543Z","created_by":"ubuntu","updated_at":"2026-02-01T00:37:55.143960390Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-wo2","depends_on_id":"bd-10i.12","type":"parent-child","created_at":"2026-01-31T23:08:51.408671131Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-wo2","depends_on_id":"bd-1u5","type":"blocks","created_at":"2026-02-01T00:37:55.143917219Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-wo2","depends_on_id":"bd-2kj","type":"blocks","created_at":"2026-01-31T22:53:58.911082296Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-wr2","title":"Implement core widgets (Block, Paragraph, Table)","description":"PHASE 5 - CORE WIDGETS\n\n## Background\nCore widgets provide essential UI building blocks. Block is a container with borders/title, Paragraph renders styled text with wrapping, Table displays tabular data.\n\n## Technical Requirements\n\n### Block Widget\n- Border styles: None, Single, Double, Rounded, Thick, Custom\n- Title positioning: Top/Bottom × Left/Center/Right\n- Padding (inner margin)\n- Style for border and background\n- Child content area calculation\n\n### Paragraph Widget\n- Text rendering with word/char wrap modes\n- Alignment: Left, Center, Right, Justify\n- Scroll offset for long content\n- Line height/spacing\n- Style inheritance from parent\n\n### Table Widget\n- Header row with column titles\n- Column constraints (width, alignment)\n- Row selection/highlighting\n- Cell styling\n- Horizontal/vertical scroll\n- Fixed header during scroll\n\n## Design Rationale\nThese three widgets cover the majority of TUI use cases. Block is the universal container, Paragraph handles all text display, Table presents structured data.\n\n## Acceptance Criteria\n- [ ] Block with all border styles\n- [ ] Block title positioning\n- [ ] Paragraph word wrap\n- [ ] Paragraph alignment modes\n- [ ] Table column constraints\n- [ ] Table row selection\n- [ ] All widgets implement Widget trait\n- [ ] Style customization for all components\n- [ ] Comprehensive unit tests\n\n## Widget Trait\nAll widgets implement:\npub trait Widget {\n    fn render(&self, area: Rect, buf: &mut Buffer);\n}\n\n## Location: ftui-widgets crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:23.813896695Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:19.875729497Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-wr2","depends_on_id":"bd-10i.3.6","type":"blocks","created_at":"2026-01-31T22:22:19.331465022Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-wr2","depends_on_id":"bd-2uk","type":"blocks","created_at":"2026-01-31T22:22:19.599179431Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-wr2","depends_on_id":"bd-yzu","type":"blocks","created_at":"2026-01-31T22:22:19.875690904Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-xn2","title":"Create CI/CD pipeline configuration","description":"INFRASTRUCTURE - CI/CD PIPELINE\n\n## Background\nContinuous integration ensures code quality, test coverage, and performance budgets are maintained. Must run on every PR and push to main.\n\n## Technical Requirements\n\n### GitHub Actions Workflow (.github/workflows/ci.yml)\n\n#### Jobs Overview\n| Job | Trigger | Purpose | Blocking |\n|-----|---------|---------|----------|\n| check | PR, push | Format, clippy, tests | Yes |\n| coverage | PR, push | Coverage thresholds | Yes |\n| benchmarks | push to main | Performance budgets | Warn |\n| e2e | PR, push | End-to-end tests | Yes |\n| docs | PR, push | Doc build verification | Yes |\n\n#### Check Job\n- cargo fmt --check\n- cargo clippy --all-targets -- -D warnings\n- cargo test --all-features\n- cargo test --no-default-features\n\n#### Coverage Job\n- Use cargo-llvm-cov for coverage\n- Thresholds:\n  - Overall: ≥ 70%\n  - ftui-core: ≥ 80%\n  - ftui-render: ≥ 75%\n- Upload to codecov.io\n\n#### Benchmarks Job\n- Run on push to main only\n- Performance budgets from plan:\n  - Cell comparison: < 1ns\n  - Present (80×24, 5% changed): p50 < 1.0ms\n  - Diff scan: < 100µs\n  - Layout solve (20 items): < 100µs\n- Fail on 2x regression\n\n#### E2E Job\n- Run scripts/e2e_test.sh\n- Upload artifacts on failure\n- Test on ubuntu-latest and macos-latest\n\n#### Docs Job\n- cargo doc --all-features --no-deps\n- Verify no broken links\n- Upload docs artifact\n\n### Matrix Testing\n- OS: ubuntu-latest, macos-latest, windows-latest\n- Rust: stable, nightly\n- Features: default, all, minimal\n\n### Caching\n- Cache ~/.cargo/registry\n- Cache ~/.cargo/git\n- Cache target/ with hash key\n\n## Acceptance Criteria\n- [ ] check job with format/clippy/tests\n- [ ] coverage job with thresholds\n- [ ] benchmarks job with budgets\n- [ ] e2e job with script execution\n- [ ] docs job with verification\n- [ ] Matrix: 3 OS × 2 toolchains\n- [ ] Proper caching configuration\n- [ ] Badge in README\n\n## Location: .github/workflows/","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:28:30.044639148Z","created_by":"ubuntu","updated_at":"2026-01-31T23:22:13.815675296Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-xn2","depends_on_id":"bd-19x","type":"blocks","created_at":"2026-01-31T22:29:25.095127714Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-xn2","depends_on_id":"bd-2u4","type":"blocks","created_at":"2026-01-31T22:29:25.375726031Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-xn2","depends_on_id":"bd-2vr","type":"blocks","created_at":"2026-01-31T22:29:24.833414137Z","created_by":"ubuntu","metadata":"{}","thread_id":""},{"issue_id":"bd-xn2","depends_on_id":"bd-3aqs","type":"blocks","created_at":"2026-01-31T23:22:13.815637014Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
{"id":"bd-yzu","title":"Implement Flex layout with constraint solving","description":"PHASE 5 - FLEX LAYOUT\n\n## Background\nFlex layout provides 1D constraint-based sizing for rows/columns. Core layout primitive that most complex layouts build upon. Based on CSS Flexbox concepts adapted for terminal grid.\n\n## Technical Requirements\n- Flex struct with direction (Row/Column)\n- Constraint types:\n  - Fixed(u16): exact size\n  - Percent(f32): percentage of parent\n  - Min(u16): minimum size, grow to fill\n  - Max(u16): maximum size, shrink to fit\n  - Ratio(u16, u16): proportional sharing\n- Constraint solving algorithm:\n  1. Allocate Fixed constraints first\n  2. Calculate Percent based on remaining space\n  3. Distribute remainder to Min/Ratio proportionally\n  4. Clamp Max constraints\n- Gap/spacing between items\n- Cross-axis alignment: Start, Center, End, Stretch\n\n## Design Rationale\nFlex is simpler than full 2D grid but handles 90% of TUI layouts. Constraint types mirror Ratatui's proven model. Solving algorithm is deterministic for predictable layouts.\n\n## Acceptance Criteria\n- [ ] Flex struct with direction and items\n- [ ] Full constraint type enum\n- [ ] Deterministic constraint solver\n- [ ] Gap/margin support\n- [ ] Cross-axis alignment\n- [ ] Nested Flex support\n- [ ] Property tests for constraint invariants\n- [ ] Edge case handling (overflow, zero space)\n\n## Performance Budget\n- Layout solve for 20 items: < 100µs\n- No allocations for typical layouts (stack buffer)\n\n## Location: ftui-layout crate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-31T22:19:03.472657582Z","created_by":"ubuntu","updated_at":"2026-01-31T22:22:18.821559934Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-yzu","depends_on_id":"bd-10i.3.7","type":"blocks","created_at":"2026-01-31T22:22:18.821529657Z","created_by":"ubuntu","metadata":"{}","thread_id":""}]}
